# 数据结构与算法

13. **二叉树**

    - 节点：二叉树的最小元素是节点，所以先定义一个节点

      ```javascript
      function Node(data, left, right) {
        this.left = left;
        this.right = right;
        this.data = data;
        this.show = () => {
          return this.data;
        };
      }
      ```

    - **重建二叉树**

      ```javascript
      var buildTree = function (preorder, inorder) {
        if (!preorder.length || !inorder.length) return null;

        // 前序遍历的第一个元素为根节点
        const rootVal = preorder[0];
        const node = new TreeNode(rootVal);

        let i = 0;
        // i有两个含义，一个是根节点在中序遍历结果中的下标
        // 另一个是当前左子树的节点个数
        for (; i < inorder.length; ++i) {
          if (inorder[i] === rootVal) {
            break;
          }
        }

        // 递归处理左右子树
        node.left = buildTree(preorder.slice(1, i + 1), inorder.slice(0, i));
        node.right = buildTree(preorder.slice(i + 1), inorder.slice(i + 1));
        return node;
      };
      ```

    - **前序遍历** (根节点->左子树->右子树)

      - 递归

      ```javascript
      function preOrder(node) {
        if (node !== null) {
          //根节点->左子树->右子树
          console.log(node.show());
          preOrder(node.left);
          preOrder(node.right);
        }
      }
      ```

      - 非递归

      ```javascript
      function preTraverse(tree) {
        var arr = [],
          node = null;
        arr.unshift(tree);
        while (arr.length) {
          node = arr.shift();
          console.log(node.val);
          if (node.right) arr.unshift(node.right);
          if (node.left) arr.unshift(node.left);
        }
      }
      ```

    - **中序遍历** (左子树->根节点->右子树)

      中序遍历是以从最小到最大的顺序访 问所有节点。中序遍历的一种应用就是对树进行排序操作。

      - 递归

      ```javascript
      function middleTraverse(node) {
        if (node === null) return;

        middleTraverse(node.left);
        console.log(node.data);
        middleTraverse(node.right);
      }
      ```

      - 非递归

      ```javascript
      // shift() 头删 unshift() 头插
      // 用一个辅助数组来做
      // 当辅助数组不为空 或者根节node不为空
      //   若node不为空
      //     根节点头插进辅助数组
      //     并且node.left赋值给新的node
      //   若node为空
      //     辅助数组头删节点赋值给node
      //     res.push(node)
      //     node.left重新赋值给node
      function middleTraverseUnRecursion(root) {
        let arr = [],
          node = root;
        let res = [];
        while (arr.length !== 0 || node !== null) {
          if (node === null) {
            node = arr.shift();
            // console.log(node.data);
            res.push(node.data);
            node = node.right;
          } else {
            arr.unshift(node);
            node = node.left;
          }
        }
      }
      ```

    - **后序遍历**(左子树->右子树->根节点)

      - 递归

      ```javascript
      function lastTraverse(node) {
        if (node === null) return;
        lastTraverse(node.left);
        lastTraverse(node.right);
        console.log(node.data);
      }
      ```

    - **广度优先-层序遍历**

      - 递归

      ```javascript
      var result = [];
      var stack = [tree];
      var count = 0;
      var bfs = function () {
        var node = stack[count];
        if (node) {
          result.push(node.value);
          if (node.left) stack.push(node.left);
          if (node.right) stack.push(node.right);
          count++;
          bfs();
        }
      };
      ```

      - 非递归

      ```javascript
      function bfs(node) {
        var result = [];
        var queue = [];
        queue.push(node);
        while (queue.length) {
          node = queue.shift();
          result.push(node.value);
          node.left && queue.push(node.left);
          node.right && queue.push(node.right);
        }
        return result;
      }
      ```

    - **反转二叉树**
      ```javascript
      var invertTree = function (root) {
        if (root !== null) {
          [root.left, root.right] = [root.right, root.left];
          invertTree(root.left);
          invertTree(root.right);
        }
        return root;
      };
      ```

14. **二叉搜索树**

    - ![image](https://pic.leetcode-cn.com/0d58ea8f3bef46b93b74cd044a4185c817bf0932b34b024318ddde90681864eb-Binary_search_tree%5B1%5D.svg)

    - 也称为 二叉查找树、有序二叉树（Ordered Binary Tree）或排序二叉树

    - 特性

      - 若任意节点的左子树不为空，则左子树所有节点的值均小于它的根节点的值
      - 若任意节点的右字数不为空，则右子树所有节点的值均大于它的根节点的值
      - 任意节点的左、右子树分别为二叉搜索树
      - 没有键值相等的节点

    - 优点
      - 于查找、插入的时间复杂度较低。为 O(log⁡n)
      - 中序遍历二叉查找树可得到一个关键字的有序序列
      - 搜索、插入、删除的复杂度等于树高，期望 O(log⁡n)，最坏 O(n)

15. **数组去重**
    - 双 for 循环, splice 剔除并 i--回退
    - indexOf 等于 index
    - filter indexOf === index
    - 新数组 indexOf === index
    - 使用空对象等
    - Set去重

# jQuery

1. **jQuery 选择器**

2. **jQuery 使用建议**
   - 尽量减少对 dom 元素的访问和操作
   - 尽量避免给 dom 元素绑定多个相同类型的事件处理函数
     - 可以将多个相同类型事件处理函数合并到一个处理函数，通过数据状态来处理分支
   - 尽量避免使用 toggle 事件

# 参考资料

> 1. https://juejin.im/post/5c64d15d6fb9a049d37f9c20#heading-4
> 2. https://mp.weixin.qq.com/s/-4QzuupsTwr2NcknN590Dg
> 3. https://mp.weixin.qq.com/s/jdDwmPfMOf4qVnwYx0a6ew
> 4. https://juejin.im/post/5e6055e6f265da5762133c89
> 5. http://www.ruanyifeng.com/blog/2017/05/websocket.html
> 6. https://cn.vuejs.org/v2/guide/
> 7. https://github.com/yukkkkkki/Front-end-Interview-questions
> 8. https://www.cnblogs.com/ainyi/p/9777841.html
> 9. https://www.jianshu.com/p/56b7302d7f7f
> 10. https://www.cnblogs.com/binguo666/p/10928907.html
> 11. https://www.cnblogs.com/staven/p/4774263.html
> 12. https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API
> 13. https://zhuanlan.zhihu.com/p/72616216
> 14. https://juejin.im/post/5c6e5803f265da2dc0065437
> 15. https://juejin.im/post/59e4c02151882578d02f4aca
> 16. https://www.cnblogs.com/harsin/p/11418615.html
> 17. https://juejin.im/post/5c72280351882562914edb61#heading-7
> 18. NicholasC.Zakas, 泽卡斯, Zakas, 李松峰, & 曹力. (2010). JavaScript 高级程序设计. 人民邮电出版社.
> 19. https://juejin.im/post/5c6f9d24e51d4511dd3fd0a2#heading-14
> 20. https://zhuanlan.zhihu.com/p/34453198?group_id=957277540147056640
> 21. https://segmentfault.com/a/1190000017184701
> 22. https://juejin.im/post/5c6c9c99f265da2d896326ae#heading-5
> 23. https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-4
> 24. https://juejin.im/post/5d0a48d86fb9a07ea803cf23#heading-0
> 25. https://juejin.im/post/59ac1c4ef265da248e75892b#heading-12
> 26. https://www.itcodemonkey.com/article/2853.html
> 27. https://juejin.im/post/5ce607a7e51d454f6f16eb3d#heading-37
> 28. https://juejin.im/post/5d1d61766fb9a07ed2248aea#heading-5
> 29. https://www.cnblogs.com/Lina-zhu/p/8891616.html
> 30. https://www.cnblogs.com/ljwk/p/7090320.html
> 31. KyleSimpson, 辛普森, 赵望野, & 梁杰. (2015). 你不知道的 JavaScript. 人民邮电出版社.
> 32. https://juejin.im/post/5ec74c6a518825430956ae65#heading-9
> 33. https://juejin.im/post/5e7c94106fb9a009a0575bc5#heading-8
> 34. https://juejin.im/post/5ec74c6a518825430956ae65#heading-14
> 35. https://juejin.im/post/5c071f68e51d451dcd3c3077
> 36. https://juejin.im/post/5c071f2ff265da6115109302
> 37. https://blog.csdn.net/eva_lu/article/details/79633044
> 38. https://www.jianshu.com/p/1b75a3623d0d
> 39. https://juejin.im/entry/59085cd10ce463006180b4fc
> 40. https://zhangguixu.github.io/2016/12/02/jsonp/
> 41. https://juejin.im/post/5cb5c40ff265da03a158210e#heading-2
> 42. http://www.imooc.com/article/281277?block_id=tuijian_wz
> 43. https://juejin.im/post/5c8efeb1e51d45614372addd#heading-38
> 
> 44. 
> 
>     
> 
>     
> 
>     
