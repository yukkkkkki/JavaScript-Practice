[TOC]

# CSS3

1.  **BFC(Block Formatting Context)块级格式化上下文**
    块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。（盒子里面的子元素的样式不会影响到外面的元素）

    - 规则

      - 属于同一个 BFC 的两个相邻 Box 垂直排列
      - 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠
      - BFC 中子元素的 margin box 的左边，与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)
      - BFC 的区域不会与 float 的元素区域重叠(防止浮动文字环绕)
      - 计算 BFC 的高度时，浮动子元素也参与计算
      - 文字层不会被浮动层覆盖，环绕于周围

    - 触发条件

      - 浮动元素，float !== none
      - 定位元素，position（absolute,fixed）
      - display: inline-block / table-cell/table-caption
      - overflow !== visible （为 hidden/auto/scroll）

    - 应用
      - 阻止 margin 重叠
      - 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div 都位于同一个 BFC 区域之中)
      - 自适应两栏布局
      - 可以阻止元素被浮动元素覆盖

2.  **盒模型**

    - 外边距(margin)、边框(border)、内边距(padding)、内容(content)

    两种模式:

    - 标准模式: box-sizing: content-box(默认); 宽高不包括内边距和边框
    - 怪异模式: box-sizing: border-box

3.  **负外边距**

    - margin-left/margin-top 的负外边距会把元素向左/上拉，盖住其旁边的元素

    - margin-right/margin-bottom 的负外边距会把相邻元素向左/上拉，盖住设置了负外边距的元素

    - 在浮动元素上

      - 与浮动方向相反的负外边距会导致浮动区域缩小，使得相邻元素盖住浮动元素
      - 与浮动方向相同的负外边距会在该方向上把浮动元素向外拉

    - 给未声明宽度的非浮动元素应用负外边距时，左右负外边距会向外拉伸元素，导致元素扩张，有可能盖住相邻元素

4.  **CSS 选择器**

    - id 选择器(#myid)
    - 类选择器(.myclassname)
    - 标签选择器(div, h1, p)
    - 相邻选择器(h1 + p)
    - 子选择器(ul > li)
    - 后代选择器(li a)
    - 通配符选择器(\*)
    - 属性选择器(a\[rel=”external”])

    - 伪类选择器(a:hover, li:nth-child)

      - 超链接伪类：

        | 选择器           | 说明                           |
        | ---------------- | :----------------------------- |
        | a:link           | 未访问                         |
        | a:visited        | 访问过                         |
        | a:hover, a:focus | 鼠标悬停，获取键盘焦点         |
        | a:active         | 活动状态                       |
        | :target          | 用于控制具有锚点目标元素的样式 |
        | :root            | 根元素选择伪类即选择 html      |
        | :empty           | 没有内容和空白的元素           |

      - 结构伪类

        | 选择器               | 示例                    | 说明                                            |
        | :------------------- | :---------------------- | :---------------------------------------------- |
        | :first-child         | p:first-child           | 选择器匹配 p 的父元素的第一个 p 元素            |
        | :last-child          | p:last-child            | 选择所有 p 元素的最后一个子元素                 |
        | :first-of-type       | p:first-of-type         | 选择的每个 p 元素是其父元素的第一个 p 元素      |
        | :last-of-type        | p:last-of-type          | 选择每个 p 元素是其父元素的最后一个 p 元素      |
        | :only-child          | p:only-child            | 选择所有仅有一个子元素的 p 元素                 |
        | :only-of-type        | p:only-of-type          | 选择所有仅有一个子元素为 p 的元素               |
        | :nth-child(n)        | p:nth-child(2/odd/even) | 选择所有 p 元素的父元素的第二/奇数/偶数个子元素 |
        | :nth-last-child(n)   | p:nth-last-child(2)     | 选择所有 p 元素倒数的第二个子元素               |
        | :nth-of-type(n)      | p:nth-of-type(2)        | 选择所有 p 元素第二个为 p 的子元素              |
        | :nth-last-of-type(n) | p:nth-last-of-type(2)   | 选择所有 p 元素倒数的第二个为 p 的子元素        |
        | :not(selector)       | :not(p)                 | 选择所有 p 以外的元素                           |

      - 表单伪类

        | 伪类      | 说明                               |
        | --------- | ---------------------------------- |
        | :enabled  | 选择所有启用的表单元素             |
        | :disabled | 选择所有禁用的表单元素             |
        | :checked  | 选择所有选中的表单元素             |
        | :required | 选择有"required"属性指定的元素属性 |
        | :optional | 选择没有"required"的元素属性       |
        | :valid    | 选择所有有效值的属性               |
        | :invalid  | 选择所有无效的元素                 |

      - 字符伪类

        | 字符伪类      | 说明                         |
        | ------------- | ---------------------------- |
        | :first-letter | 选择每个元素的首字母         |
        | :first-line   | 选择每个元素的首行           |
        | :before       | 在每个元素的内容之前插入内容 |
        | :after        | 在每个元素的内容之后插入内容 |

    - 伪元素选择器

      - ::first-letter
      - ::first-line
      - ::before
      - ::after

      - 伪类选择元素**基于的是当前元素处于的状态**，或者说元素当前所具有的特性，而不是元素的 id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和 class 有些类似，但它是基于文档之外的抽象，所以叫伪类。

      - 与伪类针对特殊状态的元素不同的是，伪元素是**对元素中的特定内容进行操作**，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。

    - **选择器优先级(权重)**：!important(∞) > 行内样式(1000) > #id(100) > .class(10) > tag(1) > \* > 继承 > 默认

      - 两个权重不同的选择器作用在同一元素上，权重值高的 css 规则生效

      - 两个相同权重的选择器作用在同一元素上：以后面出现的选择器为最后规则

      - 权重相同时，与元素距离近的选择器生效

        ```css
        #content h1 { // css样式表中
          padding: 5px;
        }
        <style type="text/css">
          #content h1 { // html头部 因为html头部离元素更近一点，所以生效
            padding: 10px;
          }
        </style>
        ```

    - 嵌套越多，权重就越大(尽量避免嵌套)

      - 伪类的权重，相当于类元素的权重

    - 关于!important 应该注意

      - 用于提升指定样式规则的应用优先权

- !important 的作用是给当前样式加权重，但不能多次叠加

  - !important 优先级最高，但也会被权重高的 important 所覆盖

  - 不推荐使用!important，因为!important 根本没有结构与上下文可言，并且很多时候权重的问题，就是因为不知道在哪里定义了一个!important 而导致的

5.  **id 和 class 的区别**

    - class 是设置标签的类，用于指定元素属于何种样式的类。在 CSS 样式中以"."来命名

    - id 是设置标签的标识。用于定义一个元素的独特的样式。在 CSS 样式定义的时候 以"#"来开头命名 id 名称

      - 具有唯一性且优先级高
      - 用于区分不同结构和内容

    - class 可以重复，id 是唯一的(id 属性一般在一个页面中只可以使用一次，而 class 可以被多次引用)

    - 在布局思路上，一般坚持这样的原则：id 是先确定页面的结构和内容，然后再为它定义样式：而 class 相反，它先定义好一类样式，然后再页面中根据需要把类样式应用到不同的元素和内容上面

6.  **Flex 弹性布局**

    - flex-direction：控制元素在主副轴排列的方向

      - row：从左到右水平排列元素（默认值）
      - row-reverse: 从右向左排列元素
      - column：从上到下垂直排列元素
      - column-reverse：从下到上垂直排列元素

    - flex-wrap：控制换行(默认不换行)

      - nowrap：不拆行或不拆列
      - wrap：在必要的时候拆行或拆列
      - wrap-reverse：在必要的时候以相反的顺序拆行或拆列

    - flex-flow：是 flex-direction 与 flex-wrap 的组合简写模式

    - justify-content：元素在主轴对齐方式

      - flex-start：紧靠主轴起点
      - flex-end：紧靠主轴终点
      - center：从弹性容器中心开始
      - space-between：第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
      - space-around：每个元素两侧的间隔相等
      - space-evenly：元素间距离平均分配

    - align-items：容器中**所有元素**在交叉轴对齐方式

      - center：位于容器的中心
      - flex-start：位于容器的交叉轴开头
      - flex-end：位于容器的交叉轴结尾
      - stretch：元素被拉伸以适应容器(默认值)

    - align-self：用于控制**单个元素**在交叉轴上的排列方式

    - align-content：只适用于多行显示的弹性容器，作用是当 flex 容器在交叉轴上有多余的空间时，对元素的对齐处理

      - stretch：将空间平均分配给元素
      - flex-start：元素紧靠主轴起点
      - flex-end：元素紧靠主轴终点
      - center：元素从弹性容器中心开始
      - space-between：第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
      - space-around：每个元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍
      - space-evenly：元素间距离平均分配

    - flex-grow：将弹性盒子的剩余可用空间，分配给弹性元素。以使用整数或小数声明

    - flex-shrink：与 flex-grow 相反 flex-shrink 是在弹性盒子装不下元素时定义的缩小值

    - flex-basis：定义了在分配多余空间之前，项目占据的主轴空间(main size)。浏览器根据这个属性，计算主轴是否有多余空间

    - flex：是 flex-grow、flex-shrink 、flex-basis 缩写组合。

7.  **定位布局**

    - position:static 默认形为，参考文档流

      - 块级元素垂直堆叠

    - position:relative 相对定位

      - 相对于自己原来的位置移动，当元素发生位置偏移时，原位置留白
      - 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它(不脱离标准流，继续保留原来位置)

    - position:absolute 绝对定位

      - 不受文档流影响，就像漂浮在页面中的精灵，绝对定位元素拥有行内块特性
      - 相对于其最近的定位上下文
        - 如果祖先元素有定位(非静态定位的任意定位)，则**以最近一级的定位祖先元素为参考点**移动位置
        - 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位
      - 绝对定位不再占有原先的位置(脱离标准流)
      - 绝对定位的元素默认会待在自己静态定位时的地方

      - 在绝对定位的情况下

        - 如果没有显式声明元素大小，那么绝对定位元素的大小由自身包含内容的多少来决定。
        - 如果相对于定位上下文的各个边声明偏移值，那么元素会被拉伸以满足设定的规则

      - 应用场景

        - 利用初始位置
        - 创建三角形
        - 利用偏移实现自动大小 > 图片上放置一个半透明盒子，相对于右、下、左绝对定位

    - position:fixed 固定定位

      - 以浏览器的可视窗口为参照点移动元素，固定定位在某个位置
      - 跟父元素没有关系，**不随滚动条滚动**
      - 固定定位不占有原先的位置

    - position:sticky 粘性定位：相对定位和固定定位的混合

      - 以浏览器的可视窗口为参照点移动元素(固定定位特点)
      - 占有原先的位置(相对定位特点)
      - 必须添加 top、left、right、bottom 其中的一个才有效

8.  **z-index**

    - 可以控制盒子层叠的次序。属性值越大，盒子在层叠中的次序就越靠近用户的眼睛

      - 谁大谁上；大小一样，后来居上

    - 在一个堆叠上下文内部，无论 z-index 值多大或多小，都不会影响其他堆叠上下文。

    - 堆叠上下文(stacking context)：影响的是元素 CSS 属性中的 z-index，父元素是否是堆叠上下文，对具有 z-index 属性的子元素的堆叠顺序有影响

      层叠上下文由满足以下任意一个条件的元素形成

      - 根元素(HTML)
      - z-index !== auto 的绝对/相对定位
      - z-index !== auto 的 flex item
      - position: fixed
      - opacity < 1
      - transform !== none
      - mix-blend-mode !== normal
      - filter !== none
      - perspective !== none
      - isolation: isolate
      - -webkit-overflow-scrolling: touch

    - z 轴元素堆叠顺序

      - 普通块级元素中：正 z-index > 内联元素 > 浮动元素 > 块级元素 > border > background >负 z-index

      - 堆叠上下文中：正 z-index > 内联元素 > 浮动元素 > 块级元素 > 负 z-index > border > background

9.  **网格布局(Grid)**

10. **浮动布局**

    - float：定义元素在哪个方向浮动

      - left 向左浮动
      - right 向右浮动
      - none 不浮动

    - 元素浮动后会变为块元素，可以设置宽高

    - clear：用于清除元素浮动影响

11. **清除浮动**

    浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上

    - 浮动带来的问题：

      - 父元素的高度无法被撑开，影响与父元素同级的元素
      - 与浮动元素同级的非浮动元素（内联元素）会跟随其后
      - 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构

- 清除浮动的方法：
  - 额外标签法：在父元素内部最后面添加一个没有高度的子元素，并使用 clear:both(不推荐)
    - 使用 ::after 伪元素为父元素添加后标签
    - 使用 before 和 after 双伪元素清除浮动
    - 通过添加父元素并设置 overflow:hidden (触发 BFC)
    - **overflow 原理**：该属性进行超出隐藏时需要计算盒子内所有元素的高度, 所以会隐式清除浮动

12. **overflow**

    - overflow 属性规定当内容溢出元素框时发生的事情

    - | 值      | 描述                                                   |
      | ------- | :----------------------------------------------------- |
      | visible | 默认值。内容不会被修剪，会呈现在元素框之外             |
      | hidden  | 内容会被修剪，并且其余内容是不可见的                   |
      | scroll  | 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容 |
      | auto    | 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容 |
      | inherit | 规定应该从父元素继承 overflow 属性的值                 |

    - overflow 的作用：

      - 溢出隐藏

        给一个元素设置了 overflow: hidden，那么该元素的内容若超出了给定的宽度和高度属性，那么超出的部分将会被隐藏，不占位

        ```html
        <style type="text/css">
          div {
            width: 150px;
            height: 60px;
            background: skyblue;
            overflow: hidden; /*溢出隐藏*/
          }
        </style>
        <div style="">
          今天天气很好！<br />今天天气很好！<br />
          今天天气很好！<br />今天天气很好！<br />
        </div>
        ```

      - 清除浮动

        - 盒子塌陷：当父元素没有足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为 auto 时，父元素没有其他非浮动的可见元素 ，父元素就会塌陷为零，我们称为 CSS 高度塌陷。

        - 解决方法：父元素设置 overflow: hidden

          ```css
          .box2{
            overflow:auto;
              width:100px;
              height:100px;
              background:red;
            }
            <div class="container">
                <div class="box1"></div>
                <div class="box2"></div>
            </div>
          ```

      - 解决外边距塌陷

        - 父级元素内部有子元素，如果给子元素添加 margin-top 样式，那么父级元素也会跟着下来，造成外边距塌陷

        - 解决方法：父元素添加 overflow: hidden

          ```html
          /*css样式*/
          <style type="text/css">
            .box {
              background: skyblue;
              overflow: hidden; /*解决外边距塌陷*/
            }
            .kid {
              width: 100px;
              height: 100px;
              background: yellow;
              margin-top: 20px;
            }
          </style>

          /*html*/
          <body>
            <div class="box">
              <div class="kid">子元素1</div>
            </div>
          </body>
          ```

13. **元素垂直/居中**

    - 水平居中

      - 行内元素: text-align: center
      - 块级元素：margin: 0 auto
      - absolute + transform
      - flex + justify-content: center

    - 垂直居中

      - line-height: height
      - absolute + transform
      - flex + align-items: center
      - table

      - 行内块的垂直居中(display:inline-block)：vertical-align: middle
      - 容器元素中垂直居中：用::before 伪元素(占据 100%容器高度)，设置 vertical-align：middle

      - 容器内只有一个元素时，display:flex + margin:auto

    - 水平垂直居中

      - absolute + transform

- flex + justify-content + align-items

  - **未知宽高的元素水平垂直居中**

    1.  通过定位和 transform 来实现(absolute + transform)(子绝父相)

    ```CSS
    .parent {
        width: 100%;
        height: 400px;
        background: relative;
        position: relative;
    }

    .children {
        position: absolute;
        top: 50%;
        left: 50%;
        background: red;
        transform: translate(-50%, -50%);
    }
    ```

    2. 利用 flex 布局来实现(flex + justify-content + align-items)

       ```css
       .parent {
         width: 100%;
         height: 400px;
         background: #666;
         display: flex;
         align-items: center;
         justify-content: center;
       }

       .children {
         background: red;
       }
       ```

    3. 将父元素设置为 table，子元素设置为 table-cell，利用 table 属性(table + table-cell + vertical-align + text-align)

       ```css
       .parent {
         display: table;
         width: 100%;
         height: 400px;
         background: #666;
       }
       .children {
         display: table-cell;
         vertical-align: middle;
         text-align: center;
         background: red;
       }
       ```

  - **高度不定，宽 100%，内一 p 高不确定，如何实现垂直居中?**

    - verticle-align: middle;
    - 绝对定位 50%加 translateY(-50%)
    - 绝对定位，上下左右全 0，margin:auto

13. **CSS 动画**

    先定义 @keyframes 规则（0%，100% | from，to）

    - from 表示起始点
    - to 表示终点

    然后定义 animation，以下参数可直接写在 animation 后面

    - animation: name duration timing-function delay iteration-count direction fill-mode play-state;

    | 值                        | 描述                                                                                 |
    | ------------------------- | ------------------------------------------------------------------------------------ |
    | animation-name            | 指定要绑定到选择器的动画的名称                                                       |
    | animation-duration        | 动画指定需要多少秒或毫秒完成。如果动画数量大于时间数量，将重新从时间列表中计算       |
    | animation-timing-function | 设置动画将如何完成一个周期                                                           |
    | animation-delay           | 定义过渡效果何时开始                                                                 |
    | animation-iteration-count | 指定元素播放动画的循环次数。(infinite 表示无限循环执行)                              |
    | animation-direction       | 指定元素动画播放的方向                                                               |
    | animation-fill-mode       | 规定当动画不播放时(当动画完成时，或当动画有一个延迟未开始播放时)，要应用到元素的样式 |
    | animation-play-state      | 指定动画是否正在运行或已暂停                                                         |
    | initial                   | 设置属性为其默认值                                                                   |
    | inherit                   | 从父元素继承属性                                                                     |

    - animation-name

      - 使用多个动画时用逗号分隔
      - 多个动画有相同属性时，后面动画的属性优先使用

    - animation-direction

      - normal：从 0%到 100%运行动画
      - reverse：从 100%到 0%运行动画
      - alternate：先从 0%到 100%，然后从 100%到 0%
      - alternate-reverse：先从 100%到 0%，然后从 0%到 100%

    - animation-delay：liner | ease | ease-in | ease-out | ease-in-out | cubic-bezier(n,n,n,n)

    - animation-play-state

      - paused：暂停
      - running：运行

    - animation-fill-mode
      - none：需要等延迟结束，起始帧属性才应用
      - backwards：动画效果在起始帧，不等延迟结束
      - forwards：结束后停留动画的最后一帧
      - both：包含 backwards 与 forwards 规则，即动画效果在起始帧，不等延迟结束，并且在结束后停止在最后一帧

14. **过渡延迟**

    - transition: property duration timing-function delay;

    | 值                         | 描述                                                                  |
    | -------------------------- | --------------------------------------------------------------------- |
    | transition-property        | 规定设置过渡效果的 CSS 属性的名称。默认值为 all，多个属性使用逗号分隔 |
    | transition-duration        | 规定完成过渡效果需要多少秒或毫秒                                      |
    | transition-timing-function | 规定速度效果的速度曲线                                                |
    | transition-delay           | 定义过渡效果何时开始。                                                |

    - transition-duration：

      - 默认值为 0s 不产生过渡效果；
      - 一个值时，所有属性使用同样的时间
      - 二个值时，奇数属性使用第一个，偶数属性使用第二个
      - 变化属性数量大于时间数量时，后面的属性再从第一个时间开始重复使用

    - transition-timing-function

      | 值                  | 描述                                                                  |
      | ------------------- | --------------------------------------------------------------------- |
      | linear              | 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）      |
      | ease                | 开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)） |
      | ease-in             | 开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)）                       |
      | ease-out            | 开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)）                       |
      | ease-in-out         | 中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)）                    |
      | cubic-bezier(n,n,n) | 在 cubic-bezier 函数中定义自己的值                                    |

      - cubic-bezier(<\x1>, <\y1>, <\x2>, <\y2>)
      - 步进速度

        - steps(n,start)：设置 n 个时间点，第一时间点变化状态
        - steps(n,end)：设置 n 个时间点，第一时间点初始状态
        - step-start：等于 steps(1,start)，可以理解为从下一步开始
        - step-end：等于 steps(1,end)，可以理解为从当前步开始

      - transition-delay
        - 默认为 0s 即立刻开始过渡
        - 值可以为负数
        - 变化属性数量大于时间数量时，后面的属性再从第一个时间开始重复使用

15. **link 与 @import 的区别**

    - link 功能较多，可以定义 RSS，定义 Rel 等作用，而@import 只能用于加载 css
    - 当解析到 link 时，页面会同步加载所引的 css，而@import 所引用的 css 会等到页面加载完才被加载
    - @import 需要 IE5 以上才能使用
    - link 可以使用 js 动态引入，@import 不行

16. **纯 css 实现三角形**

    ```css
    // 宽高都给0，通过设置border的颜色来实现
    .box {
      width: 0px;
      height: 0px;
      border-top: 50px solid rgba(0, 0, 0, 0);
      border-right: 50px solid rgba(0, 0, 0, 0);
      border-bottom: 50px solid green;
      border-left: 50px solid rgba(0, 0, 0, 0);
    }
    ```

17. **至少两种方式实现自适应搜索**

18. **CSS3 新特性**

    - 选择器

      ```css
      :last-child：选择元素最后一个孩子
      :first-child：选择元素第一个孩子
      :nth-child(1)：按照第几个孩子给它设置样式
      :nth-child(even)：按照偶数
      :nth-child(odd)：按照奇数
      enabled：选择匹配E的所有可用UI元素。
      :disabled：选择每个禁用的E元素
      :checked：选择每个被选中的E元素
      :not(selector)：选择非 selector 元素的每个元素
      ::selection：选择被用户选取的元素部分
      ```

      - 伪类：用于向某些选择器添加特殊的效果（没有创建新元素）
      - 伪元素：创建了 html 中不存在的元素，用于将特殊的效果添加到某些选择器

    - @Font-face：加载字体样式。还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。

    - 边框

      - border-radius(圆角)
      - border-image(边框图片)
      - box-shadow / text-shadow(阴影)

    - 背景

      - background-size：规定背景图片的尺寸
      - background-origin：规定背景图片的定位区域

    - 颜色

      - rgba(rgb 为颜色值，a 为透明度)

    - 文本

      - text-shadow：向文本添加阴影
      - text-justify：规定当 text-align 设置为 “justify” 时所使用的对齐方法
      - text-emphasis：向元素的文本应用重点标记以及重点标记的前景色
      - text-outline：规定文本的轮廓
      - text-overflow：规定当文本溢出包含元素时发生的事情
      - text-wrap：规定文本的换行规则
      - word-break：规定非中日韩文本的换行规则
      - word-wrap：允许对长的不可分割的单词进行分割并换行到下一行
      - text-decoration：文本修饰符：overline(上划线)、line-through(中划线)、underline(下划线)

    - 渐变

      - linear-gradient()：创建一个线性渐变的 "图像"。
      - radial-gradient()：用径向渐变创建 "图像"

    - 2D 转换(transform)

      - translate()：元素从其当前位置移动，根据给定的 left(x 坐标) 和 top(y 坐标) 位置参数
      - rotate()：元素顺时针旋转给定的角度。若为负值，元素将逆时针旋转。
      - scale()：元素的尺寸会增加或减少，根据给定的宽度(X 轴)和高度(Y 轴)参数，也可以一个值(宽高)
      - skew()：元素翻转给定的角度，根据给定的水平线(X 轴)和垂直线(Y 轴)参数
      - matrix()：把所有 2D 转换方法组合在一起，需要六个参数，包含数学函数，允许：旋转、缩放、移动以及倾斜元素。

    - 3D 转换

      - rotateX()：元素围绕其 X 轴以给定的度数进行旋转
      - rotateY()：元素围绕其 Y 轴以给定的度数进行旋转
      - perspective：规定 3D 元素的透视效果

    - 动画 animation

    - 过渡 transition

    - 多列布局

      - column-count: 规定元素应该被分隔的列数
      - column-gap: 规定列之间的间隔
      - column-rule: 设置列之间的宽度、样式和颜色规则

    - 用户界面

      - resize：规定是否可由用户调整元素尺寸
        如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll
      - box-sizing：
        - content-box：W3C 的标准盒模型。元素宽度 = 内容宽度 + padding + border
        - border-box：怪异盒模型。元素宽度 = 设定的宽度，padding 和 border 包括进去了
        - inherit：规定应从父元素继承 box-sizing 属性的值
      - outline-offset：对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓

    - 弹性布局 flex
    - 栅格布局 Grid

    - 滤镜 Filter

19. **display:none 与 visibility:hidden 的区别**

    - display:none：元素不可见、**不占据空间**、资源会加载、DOM 可访问

    - visibility:hidden：元素不可见、不能点击、但**占据空间**、资源会加载，可以使用

    - 区别

      |                     | display: none                | visibility: hidden                                  |
      | ------------------- | ---------------------------- | --------------------------------------------------- |
      | 是否占据空间        | 不占据                       | 空间保留                                            |
      | 是否触发重绘和回流  | 会触发重绘和回流             | 只会触发重绘                                        |
      | 元素可见性          | 节点和子孙节点元素全都不可见 | 节点的子孙节点元素可以设置 visibility: visible 显示 |
      | transition 过渡效果 | 会                           | 不会                                                |

      - visibility: hidden 属性值具有继承性，所以子孙元素默认继承了 hidden 而隐藏，但是当子孙元素重置为 visibility: visible 就不会被隐藏

    - 补充

      - opacity:0 意思是该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，那么点击该区域，是可以触发点击事件的
      - opacity 会触发重绘

20. **可继承属性和非继承属性**

    - 常用不可继承属性

      - 宽高:height, width
      - 最小最大宽高：max-height, min-height, max-width, min-width
      - dispaly
      - 文本阴影：text-shadow
      - 背景属性：background
      - 浮动属性：float
      - 生成内容：content
      - 层级属性：z-index
      - 定位属性：position, left, right, top, bottom
      - 盒模型属性：margin, padding, border

    - 常用可继承属性

      - 字体系列属性：font-family, font-size
      - 文本系列属性：text-indent, line-height,color
      - 元素可见性：visibility
      - 表格布局属性：border-style
      - 列表布局属性：list-style, list-style-type
      - 光标属性：cursor

21. **CSS Sprites**

    - 将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background- repeat，background-position 的组合进行背景定位

    - 利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能

    - CSS Sprites 能减少图片的字节。

22. **行内元素和块元素**

    | 元素                                 | 特征                                                                                                                                                                                                                                           |
    | ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | 行内元素                             | 设置宽高无效<br />设置 margin 仅左右方向有效，上下无效<br />设置 padding 上下左右都有效，但会撑大自己的空间<br />不会自动进行换行<br />常见行内元素：span, a, strong, b, em, i, small, big, label, img, input, select, textarea                |
    | 块元素                               | 能够识别宽高<br />margin 和 padding 的上下左右均对其有效<br />可以自动换行<br />多个块状元素标签写在一起，默认排列方式为从上至下<br />常见块级元素：div, h1-h6, p, ul, ol, dl, table, form, header, hr, audio, video, article, section, footer |
    | 行内块状元素                         | 不自动换行<br />能够识别宽高<br />默认排列方式为从左到右                                                                                                                                                                                       |
    | 行内元素、块元素、行内块元素相互转换 | display:inline 转换为行内元素<br />display:block 转换为块状元素<br />display:inline-block 转换为行内块状元素                                                                                                                                   |

23. **如何实现两栏布局**

    - float + margin-left

      ```css
      * {
        /*清除默认格式*/
        margin: 0;
        padding: 0；;
      }

      .left {
        width: 200px;
        background-color: red;
        float: left;
      }

      .right {
        background-color: green;
        margin-left: 200px; //等于左边栏的宽度
      }
      ```

    - absolute + margin-left

      ```css
      * {
        /*清除默认格式*/
        margin: 0;
        padding: 0；;
      }

      .left {
        width: 200px;
        background-color: red;
        float: left;
      }

      .right {
        background-color: green;
        margin-left: 200px; //等于左边栏的宽度
      }
      ```

    - float + BFC

      - 左侧元素浮动 + 右侧元素 BFC(overflow：hidden)

    - flex 布局：父元素 display:flex，右侧元素 flex:1

      ```css
      * {
        /*清除默认格式*/
        margin: 0;
        padding: 0;
      }
      .box {
        display: flex;
      }
      .box1 {
      }
      .box2 {
        flex: 1;
      }
      ```

24. **三栏布局：两边固定中间自适应**

    - **浮动布局**：左右两侧浮动(左侧左浮，右侧右浮) 中间设置 margin-left 和 margin-right

      - 按照 left、right、middle 顺序布局
      - 优点：简单，兼容性好
      - 缺点：浮动布局脱离文档流，需要清除浮动，否则会带来问题，比如：父容器高度塌陷等

    - **绝对布局**：左右两侧绝对定位 中间设置 margin-left margin-right

      - 按照 left、middle、right 顺序布局
      - 优点：方便快捷，问题少
      - 缺点：
        - 元素脱离文档流，导致后面的元素也会脱离文档流，可使用性比较差。
        - 如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况

    - **BFC 三栏布局**：左侧左浮，右侧右浮，中间设置 overflow: hidden 触发 BFC

      - BFC 区域，不会与浮动元素重叠
      - 缺点：主要内容模块无法最先加载，当页面中内容较多时会影响用户体验

    - **flex 布局**：父容器 display:flex，middle 元素 flex：1

      - 按照 left、middle、right 顺序布局
      - 优点：移动端首选
      - 缺点：不兼容 ie9 及以下

    - **table 布局**：父容器设置 display:table，子元素 display:table-cell

      - 按照 left、middle、right 顺序布局
      - 优点：兼容性好
      - 缺点：无法设置栏间距

    - **grid 布局**：父容器设置 display:grid 和 grid-template-columns，子元素设置 min-height

      - **等 grid 看完再回来完善这里**

    - **margin 负值法**

      - 双飞翼布局(浮动元素 margin 负值)

        - middle 放在 content 里，left 和 right 在 content 外
          ```html
          <div class="content">
            <div class="middle"></div>
          </div>
          <div class="left"></div>
          <div class="right"></div>
          ```
        - content 左浮
        - middle 设置 margin-left 和 margin-right
        - left 左浮设置 margin-left 负值
        - right 右浮，设置 margin-left 负值

        ```css
        .content {
          float: left;
          width: 100%;
        }
        .main {
          height: 200px;
          margin-left: 110px;
          margin-right: 220px;
          background-color: green;
        }
        .left {
          float: left;
          height: 200px;
          width: 100px;
          margin-left: -100%;
          background-color: red;
        }
        .right {
          width: 200px;
          height: 200px;
          float: right;
          margin-left: -200px;
          background-color: blue;
        }
        ```

        - 优点：主体内容可以优先加载

      - 圣杯布局

        - 按照 middle、left、right 布局
        - middle、left、right 全都左浮
        - 父容器设置 margin-left 和 margin-right
        - left 设置 margin-left 负值和 left 负值
        - right 设置 margin-left 负值和 right 负值

        ```css
        .container {
          margin-left: 120px;
          margin-right: 220px;
        }
        .main {
          float: left;
          width: 100%;
          height: 300px;
          background-color: red;
        }

        .left {
          float: left;
          width: 100px;
          height: 300px;
          margin-left: -100%;
          position: relative;
          left: -120px;
          background-color: blue;
        }
        .right {
          float: left;
          width: 200px;
          height: 300px;
          margin-left: -200px;
          position: relative;
          right: -220px;
          background-color: green;
        }
        ```

25. **CSS modules**

26. **移动端用什么距离单位**

27. **逻辑像素, 物理像素, 设备像素比**

28. **背景属性**

    - background
    - background-color
    - background-image
    - background-repeat
    - background-position
      - (表示相对于左侧的偏移量 background-position-x，表示相对于右侧的偏移量 background-position-y)
    - background-clip
      - border-box
      - padding-box：将图片裁剪到内边距盒子以内
      - content-box：把图片位于内边距及其之外的部分裁剪掉
    - background-attachment
      - fixed 让背景图在页面滚动时"粘"在页面上
      - scroll(默认值) 会让背景图片相对于元素本身固定
      - local 会让背景图片相对于元素中的内容固定
    - background-size 背景大小
      - contain 可以让浏览器尽可能保持图片最大化，同时不改变图片的宽高比
      - cover 图片会缩放以保证覆盖元素的每一个像素，同时不会变形

# Sass

# LESS

# DOM 相关

1. **事件流**

2. **事件委托(代理)**

3. **Event 对象**

4. **手写 EventEmitter(发布订阅模式--简单版)**

5. **如何阻止事件冒泡和默认事件**

   - 阻止冒泡：stopPropagation()

     - ie8 以下：设置事件对象的 cancelBubble 属性为 true

   - 阻止默认事件：preventDefault()
     - ie：设置事件对象的 returnValue 属性为 false

# BOM 相关

# HTML

1. **语义化**

   - 去掉或者丢失样式的时候能够让页面呈现出清晰的结构
   - 有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
   - 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
   - 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。

2. **H5 新特性**

   - 语义标签

     - \<header>, \<footer> , \<nav>, \<section>, \ <article>, \<aside>, \<details>, \<summary>, \ <dialog>, \<figure>, \<main>, \<mark>, \<time>

   - 增强型表单

     表单元素：

     - \<datalist> 用户会在他们输入数据时看到域定义选项的下拉列表
     - \<progress> 进度条，展示连接/下载进度
     - \<meter> 刻度值，用于某些计量，例如温度、重量等
     - \<keygen> 提供一种验证用户的可靠方法
     - \<output> 用于不同类型的输出

     表单属性：

     - placehoder 输入框默认提示文字
     - required 要求输入的内容是否可为空
     - pattern 描述一个正则表达式验证输入的值
     - min/max 设置元素最小/最大值
     - step 为输入域规定合法的数字间隔
     - height/wdith 用于 image 类型\<input>标签图像高度/宽度
     - autofocus 规定在页面加载时，域自动获得焦点
     - multiple 规定\<input>元素中可选择多个值

   - 音频和视频

     - \<audio>
     - \<video>

   - Canvas 绘图
   - SVG 绘图
   - 地理定位 getCurrentPosition()
   - 拖放 API
   - Web Worker
   - WebStorage
   - WebSocket

3. **Canvas 绘图**

4. **SVG 绘图**

5. **拖放 API**

   > `<div draggable="true"></div>`

   | 事件      | 产生事件的元素           | 描述                                     |
   | --------- | ------------------------ | ---------------------------------------- |
   | dragstart | 被拖放的元素             | 开始拖放操作                             |
   | drag      | 被拖放的元素             | 拖放过程中                               |
   | dragenter | 拖放过程中鼠标经过的元素 | 被拖放的元素开始进入本元素的范围内       |
   | dragover  | 拖放过程中鼠标经过的元素 | 被拖放的元素正在本元素的范围内移动       |
   | dragleave | 拖放过程中鼠标经过的元素 | 被拖放的元素离开本元素的范围             |
   | drop      | 拖放的目标元素           | 有其他元素被拖放到本元素中               |
   | dragend   | 拖放的对象元素           | 拖放操作结束                             |
   | dragexit  | 拖放的对象元素           | 当元素变得不再是拖动操作的选中目标时触发 |

# JavaScript

1. **JavaScript 数据类型**

   - **基本数据类型**：Undefined、Null、Boolean、Number、String

     - 一般存放于内存中的**栈**区，存取速度快，存放量小

       - 栈(stack)：由编译器自动分配释放，存放函数的参数值，局部变量等

     - 基本数据类型值不可变(操作基本数据类型的方法看上去返回了一个修改后的值，实际上返回的是一个新值)

     - null，undefined 的区别:

       - null 表示一个对象被定义了，但存放了空指针，转换为数值时为 0

         - typeof null -- object

       - undefined 表示声明的变量未初始化，转换为数值时为 NAN
         - typeof undefined -- undefined

   - **复杂数据类型**：Object(引用类型)

     - 一般存放与内存中的**堆**区，存取速度慢，存放量大，其引用指针存于栈区，并指向引用本身

       - 堆(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。

   - 数据封装类对象：Object、Array、Boolean、Number 和 String
   - 其他对象：Function、Arguments、Math、Date、RegExp、Error
   - 新类型：Symbol

2. **操作符**

   - 位操作符

     - ~(按位非)
     - &(按位与)
     - |(按位或)
     - ^(按位异或)
     - <<(左移)
     - ">>" (有符号右移)(保留正负号标记)
     - ">>>" (无符号右移)(会把负数的二进制码当成正数的二进制码)

   - 加性操作符(操作数存在字符串的情况)

     - 加法

       - 两个操作数都是字符串，则字符串拼接
       - 只有一个操作数是字符串，则另一个字符转换为字符串，再字符串拼接

     - 减法
       - 若一个操作数是字符串、布尔值、null 或者 undefined，则后台先将其隐式转换(Number)成数值，然后再计算
       - 若一个操作数是对象，则调用对象的 valueOf()方法取得该对象的值，然后再计算

   - 关系运算符
     - 若两个操作数都是字符串，则比较两个字符串对应的字符编码值

3. **JavaScript 的基本规范**

   - 不要在同一行声明多个变量
   - 使用 ===或!==来比较 true/false 或者数值
   - switch 必须带有 default 分支
   - 函数应该有返回值
   - for if else 必须使用大括号
   - 语句结束加分号
   - 命名要有意义，使用驼峰命名法

4. **typeof 和 instanceof 原理**

   - typeof 原理：不同的对象在底层都表示为二进制，在 Javascript 中二进制前（低）三位存储其类型信息。

     - 000: 对象
     - 010: 浮点数
     - 100：字符串
     - 110： 布尔
     - 1： 整数

     所以 typeof null === object

   - instanceof 原理：用来比较一个对象是否为某一个构造函数的实例。(注：只能用于对象，不适用原始类型的值。)

     即，能在实例的**原型对象链**中找到该构造函数的 **prototype**属性所指向的**原型对象**，就返回**true**。

     **instanceof 的语法：**

     ```javascript
     object instanceof constructor;
     // 等同于
     constructor.prototype.isPrototypeOf(object);
     ```

     **instanceof 的代码实现**

     ```javascript
     function instanceof(L, R) {
       //L是表达式左边，R是表达式右边
       const O = R.prototype;
       L = L.__proto__;
       while (true) {
         if (L === null) return false;
         if (L === O)
           // 这里重点：当 L 严格等于 0 时，返回 true
           return true;
         L = L.__proto__;
       }
     }
     ```

     **instanceof 原理**：检测 constructor.prototype 是否存在于参数 object 的 原型链上。instanceof 查找的过程中会遍历 object 的原型链，直到找到 constructor 的 prototype ,如果查找失败，则会返回 false，告诉我们，object 并非是 constructor 的实例

5. **JavaScript 中判断对象类型的几种方法**

   - typeof

   - instanceOf

   - constructor 属性：JavaScript 中，每个对象都有一个 constructor 属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。如给定一个求知的值，通过 typeof 运算符来判断它是基本数据类型的值还是对象。如果是对象，就可以使用 constructor 属性来判断其类型

   - Object.prototype.toString.call()

     - 目前为止发现的判断一个对象类型的最好的办法

     ```javascript
     const b = [];
     Object.prototype.toString.call(b); // "[object Array]"

     const c = {};
     Object.prototype.toString.call(c); // "[object Object]"

     const d = new Date();
     Object.prototype.toString.call(d); // "[object Date]"

     const e = new RegExp();
     Object.prototype.toString.call(e); // "[object RegExp]"
     ```

6. **JavaScript 中函数调用的几种方法**

   - 函数调用：this 指向 window，返回值由 return 决定

     ```javascript
     function f1() {
       console.log(this);
     }
     f1();
     ```

   - 方法调用(函数作为方法调用)：this 指向方法的调用者 ，返回值由 return 决定

     ```javascript
     var obj = {
       hello: function () {
         return "hello," + this.username;
       },
       username: "selena",
     };
     obj.hello(); // "hello, selena"
     ```

     - 上述 hello()直接调用的时候，this 的指向就成了问题。在这种情况下，this 往往被指向全局对象(严格模式下 this 指向 undefined)

   - 构造函数调用：this 指向当前构造函数构建的对象

     - 返回值有以下几种情况

       - 没有返回值，返回 this

         ```javascript
         function Person() {
           this.age = 20;
           this.name = "zs";
           console.log(this);
         }
         var p1 = new Person(); // {age: 20, name:"zs"}
         ```

       - return 了一个基本数据类型

         ```javascript
         function P2() {
           this.age = 18;
           return "abc";
         }

         var p2 = new P2();
         console.log(p2); //{age: 18}
         ```

       - 返回了一个复杂数据类型

         ```javascript
         function P3() {
           this.age = 10;
           return {};
         }

         var p3 = new P3();
         console.log(p3); //Object {}
         console.log(p3.age); //undefined

         function P3() {
           this.age = 10;
           return {};
         }

         var p3 = new P3();
         console.log(p3); //Object {}
         console.log(p3.age); //undefined
         ```

   - 上下文调用

     - call()/apply()
     - this 指向
       - 传递一个 null/undefined -> window
       - 传递一个数字/字符串/布尔值 -> 对应的基本包装类型的对象
       - 传递一个对象 -> 指向该对象
     - 返回值：由 return 语句决定
       ```javascript
       f1.call(null);
       f1.call(undefined);
       f1.call("abc"); // String { "abc" }
       f1.call(true); // Boolean { true }
       f1.call(1); // Number { 1 }
       ```

7. **for-in 和 for-of**

   - for-in：循环一个指定的变量来循环一个对象所有可枚举的属性

     ```javascript
     for (variable in object) {
       statements;
     }
     ```

     - 注：

       - 返回的除了数字索引外，还有自己自定义的属性名字
       - 通过 for-in 循环输出的属性名的顺序是不可预测的
       - 为遍历对象属性而构建，不建议与数组一起使用

     - for-in 遍历数组会出现的问题：

       - index 值 会是字符串（String）类型
       - 循环不仅会遍历数组元素，还会遍历任意其他自定义添加的属性
       - 某些情况下，会以随机顺序循环数组

   - for-of：循环可迭代对象(Array, Map, Set, arguments 等)，对值的每一个特殊属性调用一次迭代

     ```javascript
     for (variable of object) {
       statements;
     }
     ```

   - for-in 和 for-of 的区别

     - for-in 循环遍历数组的结果是数组元素的下标

     - for-of 循环遍历数组的结果是数组元素的值

8. **遍历数组**

   - every()：每一项都为 true，返回 true

     - `arr.every(callback(element[, index[, array]])[, thisArg])`

   - some()：至少有一项为 true，返回 true

     - `arr.some(callback(element[, index[, array]])[, thisArg])`

   - filter()：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素

     - var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])

   - forEach()：对数组的每个元素执行一次给定的函数

     - `arr.forEach(callback(currentValue [, index [, array]])[, thisArg])`
     - 与 map() 或者 reduce() 不同的是，它总是返回 undefined 值，并且不可链式调用
     - forEach 不会直接改变调用它的对象，但是那个对象可能会被 callback 函数改变
     - 除了抛出异常，无法中止或跳出 forEach()循环

   - map()：创建一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值

     ```javascript
     var new_array = arr.map(function callback(currentValue[, index[, array]]) {
       // Return element for new_array
     }[, thisArg])
     ```

     - 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）
     - 调用 map 方法之后追加的数组元素不会被 callback 访问

   - reduce()：对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值

     - `arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])`

       - accumulator：累计器累计回调的返回值; 是上一次调用回调时返回的累积值，或 initialValue
       - currentValue：数组中正在处理的元素。
       - index：数组中正在处理的当前元素的索引。如果提供了 initialValue，则起始索引号为 0，否则从 1 起始
       - array：调用 reduce()的数组

   - reduceRight()：接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值

9. **创建对象方式**

   - 工厂模式

     ```javascript
     function createPerson(name, age, job) {
       var o = new Object();
       o.name = name;
       o.age = age;
       o.job = job;
       o.sayName = function () {
         alert(this.name);
       };
       return o;
     }
     var p1 = createPerson("nic", 29, "software engineer");
     var p2 = createPerson("greg", 27, "doctor");
     ```

     - 虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题

   - 构造函数模式

     ```javascript
     function Person(name, age, job) {
       this.name = name;
       this.age = age;
       this.job = job;
       this.sayName = function () {
         alert(this.name);
       };
     }
     var p1 = new Person("nic", 29, "software engineer");
     var p2 = new Person("greg", 27, "doctor");
     ```

     - 构造函数的主要问题

       - 每个方法都要再每个实例上重新创建一遍(因此不同实例上的同名函数是不相等的)

   - 原型模式

     ```javascript
     function Person() {}

     Person.prototype.name = "nic";
     Person.prototype.age = 29;
     Person.prototype.jon = "software engineer";
     Person.prototype.sayName = function () {
       alert(this.name);
     };

     var p1 = new Person();
     p1.sayName(); // "nic"

     var p2 = new Person();
     p2.sayName(); // "nic"

     alert(p1.sayName == p2.sayName); // true
     ```

     - hasOwnProperty()：检测一个属性是存在于实例中还是原型中。实例中：true；原型中：false。

     - in 操作符：会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中

     - hasPrototypeProperty()：属性先存在于原型中 -> true；ss

       - 当实例重写属性后，该属性就存在于实例中了，返回 false

     - Object.keys()：接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组

     - Object.getOwnPropertyNames()：得到所有实例属性，无论是否可枚举

     - 可以用一个包含所有属性和方法的对象字面量来重写整个原型对象

     - 原型的动态性

       - 对原型对象所做的任何修改都能够立即从实例上反映出来
         - 实例中的指针仅指向原型，而不指向构造函数

     - 原型对象的问题
       - 省略了为构造函数传递初始化参数这一环节，所有实例在默认情况下都将取得相同属性值
       - 其共享的本性(原型中所有属性被很多实例共享)

   - 组合使用构造函数模式和原型模式

     - 构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性

       - 每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用
       - 支持向构造函数传递参数

     ```javascript
     function Person(name, age, job) {
       this.name = name;
       this.age = age;
       this.job = job;
       this.friends = ["shelby", "Court"];
     }

     Person.prototype = {
       constructor: Person,
       sayName: function () {
         alert(this.name);
       },
     };

     var p1 = new Person("nic", 29, "software engineer");
     var p2 = new Person("greg", 27, "doctor");

     p1.friends.push("van");
     alert(p1.friends); // "Shelby,Court,Van"
     alert(p2.friends); // "Shelby,Court"
     alert(p1.friends === p2.friends); // false
     alert(p1.sayName === p2.sayName); // true
     ```

   - 动态原型模式

     - 把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型(仅在必要的情况下)，又保持了同时使用构造函数和原型的优点。

     ```javascript
     function Person(name, age, job) {
       this.name = name;
       this.age = age;
       this.job = job;

       // 方法
       if (typeof this.sayName != "function") {
         Person.prototype.sayName = function () {
           alert(this.name);
         };
       }
     }

     var friend = new Person("nic", 29, "software engineer");
     friend.sayName();
     ```

     - 使用动态原型模式时不能使用对象字面量重写原型(会切断现有实例与新原型之间的联系)。

   - 寄生构造函数模式

     - 基本思想：创建一个函数，该函数的作用仅是封装创建对象的代码，然后再返回新创建的对象

     ```javascript
     function Person(name, age, job) {
       var o = new Object();
       o.name = name;
       o.age = age;
       o.job = job;
       o.sayName = function () {
         alert(this.name);
       };
       return o;
     }

     var friend = new Person("nic", 29, "software engineer");
     friend.sayName(); // "nic"
     ```

     - 注：返回的对象与构造函数或构造函数的原型属性之间没有关系
       - 即构造函数返回的对象与构造函数外部创建的对象没有什么不同(因此不能依赖 instanceof 来确定对象类型)

   - 稳妥构造函数模式

     - 遵循与寄生构造函数类似的模式，但有两点不同

       - 新创建对象的实例方法不引用 this
       - 不适用 new 操作符调用构造函数

     ```javascript
     function Person(name, age, job) {
       // 创建要返回的对象、
       var o = new Object();

       // 可以在这里定义私有变量和函数

       // 添加方法
       o.sayName = function () {
         alert(name);
       };

       // 返回对象
       return o;
     }
     ```

     - 使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有什么意义

10. **执行上下文**

    - 定义了变量或函数有权访问的其他数据，决定了他们各自的行为

    - 包含三个部分

      - 变量对象
      - 作用域链
      - this 指向

    - 类型
      - 全局执行上下文
      - 函数执行上下文
      - eval 执行上下文

11. **作用域 和 作用域链**

    - 作用域指的是一个变量和函数的作用范围

      - 全局作用域
      - 块级作用域

    - 作用域链：JavaScript 上每一个函数执行时，会先在自己创建的 活动对象 (Activation Object )上找对应属性值。若找不到则往父函数的 AO 上找，再找不到则再上一层的 AO,直到找到大全局作用域( window)。 而这一条形成的“AO 链” 就是 JavaScript 中的作用域链。

      - LHS：赋值操作的目标是谁
      - RHS：谁是赋值操作的源头

        - LHS 和 RHS 的特性

          - 都会在所有作用域中查找
          - 严格模式下，找不到所需的变量时，引擎都会抛出 ReferenceError 异常
          - 非严格模式下，LHR 稍微比较特殊，会自动创建一个全局变量
          - 查询成功时，如果对变量的值进行不合理的操作，比如对一个非函数类型的值进行函数调用，引擎会抛出 TypeError 异常

      - 把作用域链比喻成一个建筑，这个建筑代表程序中的嵌套作用域链，第一层楼表示当前的执行作用域，建筑的顶层表示全局作用那个易，LHS 和 RHS 引用都会在当前楼层进行查找，如果没找到，就往上一层找，还是没找到，就继续往上找，直到达到顶层(全局作用域)，可能会找到，也可能没找到，但无论如何到了顶层就会停止查找。——_援引自小黄书_

    - 作用域链的用途：保证对执行环境有权访问的所有变量和函数的有序访问。

    - 延长作用域链
      - try-catch 语句的 catch 块
      - with 语句

12. **变量提升 & 函数提升**

    - 先有声明，后有赋值

    - 函数声明会提升，函数表达式不会提升

      - 声明本身会提升，而包括函数表达式在内的赋值操作并不会提升

      - _以下援引自小黄书_

      ```javascript
      foo(); // TypeError

      var foo = function bar() {
        // ...
      };
      ```

      - 该例中，变量标识符 foo()被提升并分配给所在作用域，因此 foo()不会导致 ReferenceError，但是 foo 此时并没有赋值(如果它是一个函数声明而不是函数表达式，那么就会赋值)，foo()由于对 undefined 值进行函数调用而导致导致非法操作，因此会抛出 TypeError 异常。

    - 函数声明和变量声明都会被提升

      - 函数会首先被提升，然后才是变量

    - 所有的声明(变量和函数)，都会被"移动"到各自作用域的顶端，这个过程被称为提升

13. **原型链**

    - 基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。

    - 原型链：每个构造函数都有一个 prototype 属性，指向它的原型对象，而原型对象都有一个 constructor 属性，指向构造函数，而每个构造函数的实例都包含一个\_\_proto\_\_属性，指向该实例构造函数的原型对象。构造函数、原型和实例形成一个原型链，是一个用来实现继承和共享属性的对象链。

    - 属性查找机制：当访问一个对象的属性(包括方法)时，首先查找这个对象自身有没有该属性，如果没有就查找它的原型，若还没有就查找原型对象的原型，以此类推，一直找到 Object 为止，若找到就输出，若找不到就输出 null。

    - 属性修改机制：只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用`b.prototype.x = function(){...}`，但是这样会造成所有继承于该对象的实例的属性发生改变。

14. **继承**

    - 原型链继承

      ```javascript
      function SuperType() {
        this.property = true;
      }
      superType.prototype.getSuperValue = function () {
        return this.property;
      };

      function subType() {
        this.subproperty = false;
      }

      // 继承了SuperType
      SubType.prototype = new SuperType();

      SubType.prototype.getSubValue = function () {
        return this.subproperty;
      };

      var instance = new SubType();
      alert(instance.getSuperValue()); // true
      ```

      - 确定原型和实例的关系：instanceof 或者 isPrototypeOf()

      - 给原型添加方法的代码一定要放在替换原型的语句之后

      - 在通过原型链实现继承时，不能使用对象字面量创建原型
        方法，因为这样回重写原型链(原型链被切断)。

      - 原型链的问题

        - 包含引用类型值的原型属性会被所有实例共享。

        ```javascript
        function SuperType() {
          this.colors = ["red", "blue", "green"];
        }

        function SubType() {}

        // 继承了SuperType
        SubType.prototype = new SuperType();

        var instance1 = new SubType();
        instance1.colors.push("black");
        alert(instance1.colors); // "red, blue, green, black"

        var instance2 = new SubType();
        alert(instance2.colors); // "red, blue, green, black"
        ```

        - 在创建子类型的实例时，不能向超类型的构造函数中传递参数。(没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数)

    - 借用构造函数：call(), apply()

      - 在子类型构造函数的内部调用超类型构造函数

      ```javascript
      function SuperType() {
        this.colors = ["red", "blue", "green"];
      }

      function SubType() {
        // 继承了SuperType
        SuperType.call(this);
      }

      var instance1 = new SubType();
      instance1.colors.push("black");
      alert(instance1.colors); // "red, blue, green, black"

      var instance2 = new SubType();
      alert(instance2.colors); // "red, blue, green"
      ```

      - 借用构造函数可以在子类型构造函数中向超类型构造函数传递参数

      - 借用构造函数的问题
        - 方法都在构造函数中定义，因此函数复用无从谈起
        - 在超类型的原型中定义的方法，对子类型是不可见的，结果所有类型都只能使用构造函数模式

    - 组合模式

      - 将原型链和借用构造函数结合在一起

      - 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
        - 这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的

      ```javascript
      function SuperType(name) {
        this.name = name;
        this.colors = ["red", "blue", "green"];
      }

      SuperType.prototype.sayName = function () {
        alert(this.name);
      };

      function SubType(name, age) {
        // 继承属性
        SuperType.call(this, name); // 第二次调用
        this.age = age;
      }

      // 继承方法
      SubType.prototype = new SuperType(); // 第一次调用
      SubType.prototype.constructor = SubType;
      SubType.prototype.sayAge = function () {
        alert(this.age);
      };

      var instance1 = new SubType("Nicholas", 29);
      instance1.colors.push("black");
      alert(instance1.colors); // "red, blue, green, black"
      instance1.sayName(); // "Nicholas"
      instance1.sayAge(); // 29

      var instance2 = new SubType("Greg", 27);
      alert(instance2.colors); // "red, blue, green"
      instance1.sayName(); // "Greg"
      instance1.sayAge(); // 27
      ```

      - 问题：无论什么情况，都会调用两次超类型构造函数：
        - 在创建子类型原型的时候
        - 在子类型构造函数内部

    - 原型式继承

      - 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型

      ```javascript
      function object(o) {
        function F() {}
        F.prototype = o;
        return new F();
      }
      ```

      - 先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。

      - Object.create()

        - Object.create(用作新对象原型的对象[, 为新对象定义额外属性的对象])
          `var p1 = Object.create(person)`

        ```javascript
        var p2 = Object.create(person, {
          name: {
            value: "Greg",
          },
        });
        ```

    - 寄生式继承

      - 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再返回对象

      ```javascript
      function createAnother(original) {
        var clone = object(original); // 通过调用函数创建一个新对象
        clone.sayHi = function () {
          // 以某种方式增强这个对象
          alert("hi");
        };
        return clone; // 返回这个对象
      }
      ```

      - 由于不能做到函数复用而降低效率

    - 寄生组合继承(最有效)

      - 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。(本质：使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型)

      ```javascript
      function inheritPrototype(subType, superType) {
        var prototype = object(superType.prototype); //创建对象
        prototype.constructor = subType; // 增强对象
        subType.prototype = prototype; // 指定对象(将新创建的对象赋值给子类型的原型)
      }
      ```

      ```javascript
      function SuperType(name) {
        this.name = name;
        this.colors = ["red", "blue", "green"];
      }

      SuperType.prototype.sayName = function () {
        alert(this.name);
      };

      function SubType(name, age) {
        // 继承属性
        SuperType.call(this, name);
        this.age = age;
      }

      inheritPrototype(SubType, SuperType);

      SubType.prototype.sayAge = function () {
        alert(this.age);
      };
      ```

      - 如此，便只调用一次 SuperType 构造函数，并且因此避免了在 SubType，prototype 上面创建不必要的、多余的属性。原型链也保持不变。

    - ES6 Class extends 继承

      - 子类 extends 父类，然后 constructor 里 super 继承父类

15. **闭包**

    - 指有权访问另一个函数作用域中的变量的函数。本质是利用了作用域的机制，来达到外部作用域访问内部作用域的目的

      - 是 js 特有的**链式作用域**结构

      - 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。(援引自小黄书)

      - 父函数被销毁 的情况下，返回出的子函数的\[\[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包

    - 示例
      ```javascript
      for (var i = 1; i <= 5; i++) {
        (function (j) {
          setTimeout(function timer() {
            console.log(j);
          }, j * 1000);
        })(i);
      }
      ```
    - 闭包的优点

      - 封闭住了变量作用域，有效地**防止了全局变量污染**
      - 可以读取其他函数内部的变量，让这些变量的值始终保持在内存中，不会随着函数的结束而自动销毁
      - 可以很巧妙地实现静态私有变量、私有函数方法等

    - 闭包的缺点

      - 通常当执行期上下文被销毁时，函数的激活对象也就被销毁了。当有闭包引用时，**活动对象就不会被销毁**，因为它仍然被引用。这意味着闭包比非隔离的函数需要**更多的内存**。

        - 闭包函数的执行期上下文的作用域链中保存了自己的 Activation Object(激活对象)，外层函数 assignEvents Execution Context(执行上下文)的 Activation Object(激活对象)，以及 Global Object(全局对象)。(携带包含它的函数的作用域，所以会比其他函数占用更多的内存)

      - 闭包会使得函数中的变量都被保存在内存中，所以存在**内存泄露**的风险

    - 应用场景

      - 模拟块级作用域
        ```javascript
        function outputNumbers(count) {
          (function () {
            for (var i = 0; i < count; i++) {
              alert(i);
            }
          })();
          alert(i); // ReferenceError
        }
        ```
      - 模拟私有属性

        ```javascript
        function getGeneratorFunc() {
          var _name = "John";
          var _age = 22;

          return function () {
            return {
              getName: function () {
                return _name;
              },
              getAge: function () {
                return _age;
              },
            };
          };
        }

        var obj = getGeneratorFunc()();
        obj.getName(); // John
        obj.getAge(); // 22
        obj._age; // undefined
        ```

      - 单例模式
      - 科里化
      - 回调函数：在定时器、事件监听器、ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要用了回调函数，实际上就是在使用闭包(援引自小黄书)。

16. **函数科里化**

17. **防抖和节流(性能和优化)**

18. **对象的拷贝**

    - **浅拷贝**：两个 js 对象指向同一个内存地址，其中一个改变会影响另一个

      - 简单的赋值操作(=)

      - Object.assign(target, ...sources)

        - 返回值: target 对象
        - 把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象，目标对象和 target 是同一个地址，修改 target，目标对象也会变。
        - 拷贝的是对象的属性的引用，而不是对象本身

      - Array.prototype.slice()

        - 返回一个新的数组对象，这一对象是一个由 begin 和 end（不包括 end）决定的原数组的浅拷贝。原始数组不会被改变
        - slice()只能实现一维数组的深拷贝

      - Array.prototype.concat()

        - 合并两个或多个数组。不会更改现有数组，而是返回一个新数组。

      - 解构

      - ...扩展运算符

      - **\$.extend({},obj)**：使用递归思路实现了浅拷贝和深拷贝

        - 第一个参数类型为 Boolean，当为 false 的时候必须省略不写则是浅拷贝，当为 true 的时候为深拷贝

      - 自己实现一个浅拷贝思路：

        - 声明一个新对象
        - 旧对象的属性赋值给新对象

          ```javascript
          function shallowClone(source) {
            var target = {};
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
            return target;
          }
          ```

    - **深拷贝**：会另外拷贝一份一个一模一样的对象，从堆内存中开辟一个新的区域存放新对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

      - Object.assign()

        - 只能实现一维对象的深拷贝

      - JSON.parse(JSON.stringify())

        - 利用 JSON.parse 将该对象转换为其 JSON 字符串表示形式，然后将其解析回对象
          `const deepClone(obj) => JSON.parse(JSON.stringify(obj));`
        - 注意
          - 不能深拷贝含有 undefined、function、symbol 值的对象
          - 无法拷贝不可枚举的属性，无法拷贝对象的原型链
          - 拷贝 Date 引用类型会变成字符串
          - 拷贝 RegExp 引用类型会变成空对象
          - 对象中含有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null
          - 无法拷贝对象的循环引用(即 obj\[key] = obj)

      - 递归实现深拷贝 (浅拷贝 + 递归)

        ```javascript
        function deepClone(source) {
          // 创建一个新对象
          let result = {};

          for (var i in source) {
            if (source.hasOwnProperty(i)) {
              // 如果字段的值也是一个对象则递归操作
              if (typeof source[i] === "object") {
                target[i] = clone(source[i]);
              } else {
                // 否则直接赋值给新对象
                target[i] = source[i];
              }
            }
          }
          return result;
        }
        ```

        - 存在的问题

          - 没有对参数做检验
          - 判断是否对象的逻辑不够严谨
          - 没有考虑数组的兼容

        - 陷入循环的递归过程的解决方案

          - 消除尾递归：判断一个对象的字段是否引用了这个对象或这个对象的任意父级

            ```javascript
            function isObject(x) {
              return Object.prototype.toString.call(x) === "[object Object]";
            }

            function deepClone(source) {
              // 相当于加上一个递归出口
              if (!isObject(source)) return source;

              // ...
            }
            ```

            - 可以解决栈溢出问题，但无法解决循环引用
            - 关于循环引用的问题解决思路有两种：
              - 循环检测
              - 暴力破解

      - 使用循环来破解递归爆栈

        - 类似于循环遍历一棵树，借用一个栈来做，当栈为空时就遍历完了，栈里面存储下一个需要拷贝的节点

          - 首先我们往栈里放入种子数据，key 用来存储放哪一个父元素的那一个子元素拷贝对象；然后遍历当前节点下的子元素，如果是对象就放到栈里，否则直接拷贝

        ```javascript
        function deepClone(x) {
          const root = {};

          // 栈
          const loopList = [
            {
              parent: root,
              key: undefined,
              data: x,
            },
          ];

          while (loopList.length) {
            // 深度优先
            const node = loopList.pop();
            const parent = node.parent;
            const key = node.key;
            const data = node.data;

            // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素
            let res = parent;
            if (typeof key !== "undefined") {
              res = parent[key] = {};
            }

            for (let k in data) {
              if (data.hasOwnProperty(k)) {
                if (typeof data[k] === "object") {
                  // 下一次循环
                  loopList.push({
                    parent: res,
                    key: k,
                    data: data[k],
                  });
                } else {
                  res[k] = data[k];
                }
              }
            }
          }
          return root;
        }
        ```

        - 对于循环引用依然无力应对

      - 破解循环引用

        ```javascript
        // 保持引用关系
        function cloneForce(x) {
          const uniqueList = []; // 用来去重

          let root = {};

          // 循环数组
          const loopList = [
            {
              parent: root,
              key: undefined,
              data: x,
            },
          ];

          while (loopList.length) {
            // 深度优先
            const node = loopList.pop();
            const parent = node.parent;
            const key = node.key;
            const data = node.data;

            // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素
            let res = parent;
            if (typeof key !== "undefined") {
              res = parent[key] = {};
            }

            // 数据已经存在
            let uniqueData = find(uniqueList, data);
            if (uniqueData) {
              parent[key] = uniqueData.target;
              continue; // 中断本次循环
            }

            // 数据不存在
            // 保存源数据，在拷贝数据中对应的引用
            uniqueList.push({
              source: data,
              target: res,
            });

            for (let k in data) {
              if (data.hasOwnProperty(k)) {
                if (typeof data[k] === "object") {
                  // 下一次循环
                  loopList.push({
                    parent: res,
                    key: k,
                    data: data[k],
                  });
                } else {
                  res[k] = data[k];
                }
              }
            }
          }
          return root;
        }

        function find(arr, item) {
          for (let i = 0; i < arr.length; i++) {
            if (arr[i].source === item) {
              return arr[i];
            }
          }
          return null;
        }
        ```

        - 存在问题：无法保持引用；如果数据量很大，不适合该方法

      - 也可以用第三方库：

        - **jquery 的\$.extend**
        - **lodash 的\_.cloneDeep**

19. **js 的垃圾回收机制**

    - 原理：垃圾收集器会按照固定的时间间隔，周期性的找出不再继续使用的变量，然后释放其占用的内存

      - 不再继续使用的变量：生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收

      - 内存生命周期：内存分配 -> 内存使用 -> 内存释放
        - 分配期：分配所需要的内存
        - 使用期：使用分配到的内存（读、写）
        - 释放器：不需要时将其释放和归还

    - 标记清除

      当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“**进入环境**”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能用到它们。而当变量离开环境时，这将其 标记为“离开环境”。标记“**离开环境**”的就回收内存。

      - 工作流程：
        - 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记
        - 去掉环境中的变量以及被环境中的变量引用的变量的标记
        - 那些还存在标记的变量被视为准备删除的变量
        - 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间

20. **内存泄露**

    - 内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

    - JavaScript 常见的内存泄漏及解决办法

      - **意外的全局变量**：

        - 未声明的变量

          - 会在全局对象下创建一个新变量。在浏览器中，全局对象是 window。全局变量是很难被垃圾回收器回收的。

          ```javascript
          function foo(arg) {
            //等同于window.bar="this is a hidden global variable"
            bar = "this is a hidden global variable";
            //这里的this 指向了全局对象（window）,等同于window.bar2="potential accidental global"
            this.bar2 = "potential accidental global";
          }
          ```

        - 使用 this 创建的变量

          ```javascript
          function fn() {
            this.a = "Actually, I'm a global variable";
          }
          fn();
          ```

          - 这里 this 的指向是 window, 因此此时创建的 a 变量也会被挂载到 window 对象下

        - 解决方法：在 JavaScript 程序中开启严格模式'use strict'，使得 this 的指向为 undefined, 这样就可以避免了

        - 注意：那些用来临时存储大量数据的全局变量，确保在处理完这些数据后将其设置为 null 或重新赋值。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。

      - **循环引用**：

        - 在 js 的内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。

        - 循环引用 example：根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。

          ```javascript
          function func() {
            let obj1 = {};
            let obj2 = {};

            obj1.a = obj2; // obj1 引用 obj2
            obj2.a = obj1; // obj2 引用 obj1
          }
          ```

        - 解决方法：在不使用它们的时候手工将它们设为空。上面的例子可以这么做：

          ```javascript
          obj1 = null;
          obj2 = null;
          ```

      - **被遗忘的计时器和回调函数**

        - 定时器引起

          - 在 setInterval 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。如果回调函数内没有做什么事情，并且也没有被 clear 掉的话，就会造成内存泄漏。不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。

          ```javascript
          let someResource = getData();
          setInterval(() => {
            const node = document.getElementById('Node');
            if(node) {
              node.innerhtml = jsON.stringify(someResource));
            }
          }, 1000);
          ```

        - 解决方法：当不需要 interval 或者 timeout 时，最好调用 clearInterval 或者 clearTimeout。

      - **DOM 泄露**

        - IE 的 DOM 回收机制便是采用引用计数，以下主要针对 IE 而言的。

          - 没有清理的 DOM 元素引用

            ```javascript
            var refA = document.getElementById("refA");
            document.body.removeChild(refA);
            // #refA不能回收，因为存在变量refA对它的引用。将其对#refA引用释放，但还是无法回收#refA
            ```

            - 解决办法：refA = null;

          - 给 DOM 对象添加的属性是一个对象的引用

            ```javascript
            var MyObject = {};
            document.getElementById("mydiv").myProp = MyObject;
            ```

            - 解决方法：在 window.onunload 事件中写上: `document.getElementById('mydiv').myProp = null;`

          - DOM 对象与 js 对象相互引用

            ```javascript
            function Encapsulator(element) {
              this.elementReference = element;
              element.myProp = this;
            }
            new Encapsulator(document.getElementById("mydiv"));
            ```

            - 解决方法：在 onunload 事件中写上: `document.getElementById('mydiv').myProp = null;`

          - 给 DOM 对象用 attachEvent 绑定事件

            ```javascript
            function doClick() {}
            element.attachEvent("onclick", doClick);
            ```

            - 解决方法：在 onunload 事件中写上: element.detachEvent('onclick', doClick);

          - 从外到内执行 appendChild。这时即使调用 removeChild 也无法释放

            ```javascript
            var parentdiv = document.createElement("div");
            var childdiv = document.createElement("div");
            document.body.appendChild(parentdiv);
            parentdiv.appendChild(childDiv);
            ```

            - 解决方法： 从内到外执行 appendChild:

            ```javascript
            var parentdiv = document.createElement("div");
            var childdiv = document.createElement("div");
            parentdiv.appendChild(childDiv);
            document.body.appendChild(parentdiv);
            ```

      - **js 的闭包**

        - eg：匿名函数能够访问父级作用域中的变量

          ```javascript
          function fn() {
            var a = "I'm a";
            return function () {
              console.log(a);
            };
          }
          ```

          - 变量 a 被 fn()函数内的匿名函数所引用, 因此这种变量是不会被回收的

        - 闭包在 IE6 下会造成内存泄漏，但是现在已经无须考虑了。值得注意的是**闭包本身不会造成内存泄漏，但闭包过多很容易导致内存泄漏**。**闭包会造成对象引用的生命周期脱离当前函数的上下文**，如果闭包如果使用不当，可以导致环形引用（circular reference），类似于死锁，只能避免，无法发生之后解决，即使有垃圾回收也还是会内存泄露。

      - **console**

        - 控制台日志记录对总体内存配置文件的影响可能是许多开发人员都未想到的极其重大的问题。记录错误的对象可以将大量数据保留在内存中。注意，这也适用于：

          - 在用户键入 JavaScript 时，在控制台中的一个交互式会话期间记录的对象。
          - 由 console.log 和 console.dir 方法记录的对象。

      - 避免内存泄露：

        - 注意程序逻辑，避免“死循环”
        - 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收
        - 避免创建过多的对象 原则：不用了的东西要及时归还

21. **js 事件循环机制**

22. **this 的指向**

    - this 是在函数被调用时发生的绑定，它指向什么**取决于函数的调用位置**

      - 既不指向函数自身，也不指向函数的词法作用域

    - this 的默认绑定

      - strict mode 下，会绑定到 undefined
      - 非严格模式，this 指向全局对象

    - this 的隐式绑定

      - 当函数引用中有上下文对象时，隐式绑定规则会把调用中的 this 绑定到这个上下文对象
        ```javascript
        function foo() {
          console.log(this.a);
        }
        var obj = {
          a: 2,
          foo: foo,
        };
        obj.foo(); // 2
        ```
      - 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用

    - this 的显式绑定

      - 硬绑定

        - call()、apply()、Function.prototype.bind() (ES5)

      - API 调用的"上下文"

    - new 绑定

    - 优先级：new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定

23. **new 运算符的执行过程**

    - 创建(/构造)一个全新的对象
    - 新对象链接到该函数的\[\[prototype\]\]原型
    - 新对象绑定函数调用的 this: apply(属性和方法被加入到对象中)
    - 返回新对象(如果构造函数有自己 retrun 时，则返回该值)

    ```javascript
    var obj = {};
    obj.__proto__ = Base.prototype;
    Base.call(obj);
    ```

24. **改变 this 的指向：call()、apply()、bind()**

    - **call()**

    - **apply()**

    - **bind()**

    - **call()、apply()、bind()的区别**

25. **eval**

    - 把对应的字符串解析成 JS 代码并运行
    - 应该避免使用 eval，不安全，非常耗性能(2 次，一次解析成 js 语句，一次执行)

26. **V8 线程模式**

27. **前端模块化**

    - 有几种规范？
    - commonjs 和 es module 都是怎么实现的？有啥区别？

28. **前端性能优化**

29. **JS 延迟加载的方式**

30. **setTimeout 和 setInterval**

    - **setTimeout**

      - `setTimeout(callback, time);`
      - 定时器：在指定的毫秒数后调用函数或计算表达式
      - 取消：clearTimeout()

    - **setInterval**

      - `setInterval(callback, time);`
      - 计时器：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭
      - 暂停 setInterval()：clearInterval()

    - **setTimeout 和 setInterval 的区别**

      - setTimeout 到达一定的时间触发一次，当方法执行完成定时器就立即停止(但是定时器还在,只不过没用了);
      - setInterval 到达一定时间触发一次，并且会持续触发，直到我们手动清除定时器为止

# ES6

1. **let、const**

   - let：声明变量；块级作用域；不会被变量提升

   - const：声明常量；块级作用域；const 声明不允许修改绑定，但允许修改值
     - 即声明对象时，可以修改对象的属性值

2. **箭头函数**

   - 箭头函数里面根本没有自己的 this，而是引用外层的 this

     ```javascript
     var handler = {
       id: "123456",

       init: function () {
         document.addEventListener(
           "click",
           (event) => this.doSomething(event.type),
           false
         );
       },

       doSomething: function (type) {
         console.log("Handling " + type + " for " + this.id);
       },
     };
     ```

     上面代码的 init 方法中，使用了箭头函数，这导致这个箭头函数里面的 this，总是指向 handler 对象

   - 除了 this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量

     - arguments、super、new.target

   - 使用注意点

     - 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。

       - this 对象的指向是可变的，但是在箭头函数中，它是固定的，这种特性很有利于封装回调函数

     - 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。

     - 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

     - 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

   - 不适合场合
     - 定义对象的方法，且该方法内部包括 this
     - 需要动态 this 的时候，也不应使用箭头函数
     - 如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数

3. **解构赋值**

4. **数组新增方法**

   - Array.of()
   - Array.from()
   - find()
   - findIndex()
   - fill()
   - copyWithin()
   - entries()
   - values()
   - keys()
   - includes()
   - flat()
   - flatMap()

5. **对象新增方法**

   - Object.is()
   - Object.getOwnPropertySymbols()
   - Object.setPrototypeOf()
   - Object.getPrototypeOf()

   - Object.assign()

     - 浅拷贝。只拷贝源对象的自身属性(不拷贝继承属性)
     - 不拷贝对象不可枚举的属性
     - undefined 和 null 无法转成对象，它们不能作为 Object.assign 参数，但是可以作为源对象

       ```javascript
       Object.assign(undefined); // 报错
       Object.assign(null); // 报错

       let obj = { a: 1 };
       Object.assign(obj, undefined) === obj; // true
       Object.assign(obj, null) === obj; // true
       ```

     - 属性名为 Symbol 值的属性，可以被 Object.assign 拷贝

6. **Number 新增方法**

   - Number.isNaN()
   - Number.isFinite()

7. **字符串新增方法**

   - String.raw()
   - repeat()
   - startsWith()
   - endsWith()
   - includes()
   - normalize()

8. **Map**

9. **Set**

   - 类似于数组，但是成员的值都是唯一的，没有重复的值

     - 应用于数组去重`[...new Set(array)]`

   - `let s = new Set()`
   - Set.prototype.size：返回 Set 实例的成员总数
   - add() 添加某个值，返回 Set 结构本身。不会添加重复的值
   - has() 返回一个布尔值，表示该值是否为 Set 的成员
   - delete() 删除某个值，返回一个布尔值，表示删除是否成功
   - clear() 清除所有成员，没有返回值

   - 遍历操作(Set 的遍历顺序就是插入顺序)

     - keys() 返回键名的遍历器
     - values() 返回键值的遍历器
     - entries() 返回键值对的遍历器
     - forEach() 使用回调函数遍历每个成员

   - Set 集合转换为数组：let set = new Set(\[1,2,3]);
   - 数组转换为 Set 集合：array = \[...set]

10. **WeakSet**

    - `const ws = new WeakSet();`

    - 与 Set 有两个区别

      - WeakSet 的成员只能是对象，而不能是其他类型的值
      - WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

        - WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。

    - WeakSet 结构有以下三个方法

      - add()
      - delete()
      - gas()

    - WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。
    - WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

11. **Symbol**

12. **Generator**

13. **Promise**

    - 封装异步操作

    - **promise 实现**

      ```javascript
      <!-- resolve和reject两个回调函数 -->
      var myPromise = new Promise((resolve, reject) => {
        // 需要执行的代码...
        if (/* 异步执行成功 */) {
          resolve(value)
        } else if (/* 异步执行失败 */) {
          reject(error)
        }
      });

      <!-- 两个回调函数 -->
      myPromise.then((value) => {
        // 成功后调用, 使用 value 值
      }, (error) => {
        // 失败后调用, 获取错误信息 error
      })
      ```

      - resolve()和 reject()的使用(援引自小黄书)

        - 如果调用 reject，则 promise 被拒绝，如果有任何值传给 reject，则这个值就是被拒绝的原因值

        - 如果调用 resolve 且没有值传入，或者传入任何非 promise 值，这个 promise 就完成

        - 如果调用 resolve 并传入另外一个 promise，这个 promise 就会采用传入的 promise 的状态

    - **promise 特点**

    - **Promise 优缺点**

    - **promise 的应用**

14. **async & await**

15. **Class**

    - extends 继承

- super 继承

# TypeScript

# 浏览器

1. **跨标签页通讯**

   本质原理就是去运用一些可以 共享的中间介质

   - 通过父页面 window.open()和子页面 postMessage
   - 设置同域下共享的 localStorage 与监听 window.onstorage
     - 父标签页使用 localStorage.setItem(key,value)添加（修改、删除）内容
     - 子标签页监听 storage 事件
   - 设置共享 cookie 与不断轮询检查(setInterval)
   - 借助服务端或者中间层实现

2. **从输入 URL 到展示的过程**

   - 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP
   - 客户端与服务端 TCP 三次握手建立连接
   - 向服务器发起 HTTP 请求，分析 url，设置请求报文(头，主体)
   - 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）
   - 浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构

     - 浏览器的渲染过程

       ![image](https://user-gold-cdn.xitu.io/2018/12/10/16798b8db54caa31?imageView2/0/w/1280/h/960/ignore-error/1)

     - HTML parser --> DOM Tree
     - CSS parser --> Style Tree(样式树)
       - 会阻塞渲染
       - 注：是一个**十分消耗性能**的过程，所以应尽量保证层级扁平，减少过度层叠，**越是具体的 CSS 选择器，执行速度越慢**
     - attachment --> Render Tree(渲染树)
     - layout: 布局
     - GPU painting: 像素绘制页面
     - 载入解析到的资源文件，渲染页面

     - 注：
       - **当 HTML 解析到 script 标签时，会暂停构建 DOM**，完成后才会从暂停的地方重新开始。
         - 想首屏渲染得越快，就越不应该在首屏就加载 JS 文件
       - CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM

   - 当数据传送完毕，发起 TCP 四次挥手断开连接。

3. **存储(localStorage、sessionStorage、cookie)**

   - 前端存储的好处

     - 方便网页的加载，避免了在发送请求收到响应前页面的空白期
     - 也可以在非强制性要求实时最新数据时减少向服务端的请求，加快渲染速度
     - 在网络不佳或无网络时仍有离线数据可以查看

   - Cookie

     - ![image](https://user-gold-cdn.xitu.io/2017/10/2/07ecb36c4820a66de90013f303cac8c0?imageView2/0/w/1280/h/960/ignore-error/1)

     - 作用：与服务器进行交互，作为 HTTP 规范的一部分而存在。(而 Web Storage 仅仅是为了在本地“存储”数据而生。)

     - cookie 的属性

       - name：cookie 的名字
       - value：cookie 的值
       - domain：指域名
       - maxAge：Cookie 失效的时间
         - 正数，则超过 maxAge 秒之后失效
         - 负数，该 Cookie 为临时 Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该 Cookie
         - 为 0，表示删除该 Cookie
       - path：默认是'/'，匹配的是 web 的路由
       - secure：设置为 true 时，此 cookie 只会在 https 和 ssl 等安全协议下传输
       - version：该 Cookie 使用的版本号
         - 0 表示遵循 Netscape 的 Cookie 规范，目前大多数用的都是这种规范
         - 1 表示遵循 W3C 的 RFC2109 规范；规范过于严格，实施起来很难
       - HttpOnly：设置为 true，就不能通过 js 脚本来获取 cookie 的值，能有效的防止 xss 攻击
       - js 操作 cookie：document.cookie

     - 特点：

       - 限制大小，约 4k 左右
       - 不可跨域名 不同域名之间不可访问各自 cookie
       - 可以控制过期时间，不会永久有效，有一定的安全保障，若没有设定，则是 session 级别的。
         - `document.cookie = 'expires=时间/max-age=秒'`
         - cookie 的 session 是在未关闭浏览器的情况下，所有的 tab 级别的页面或新开，或刷新，均属于一个 session
       - 在 HTTP 请求中的 Cookie 是明文传递的，请求头上的数据容易被拦截攻击，所以安全性成问题，除非用 HTTPS

     - 主要应用
       - 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
       - 个性化设置（如用户自定义设置、主题等）
       - 浏览器行为跟踪（如跟踪分析用户行为等）

   - session

     - 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
     - session 中保存的是对象
     - session 不能区分路径
     - session 的运行依赖 session id，而 session id 是存在 cookie 中的

   - Web Storage

     - 实例方法

       - clear 删除所有值
       - getItem(name) 根据传入的键来获取对应的值
       - key(index) 获得所对应索引的键，名称
       - removeItem(name) 删除键对应的键值对
       - setItem(name, value) 为指定的 name 设置一个对应的值

     - **sessionStorage**

       - 用于本地存储一个会话(session)中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，体积限制为 4~5M
       - 同源策略：不同于 Cookie，sessionStorage 访问限制更高，只有当前设定了 sessionStorage 的域下才能访问
       - **单标签页**：两个相同域下的不同标签页不能互通
       - 在关闭标签页或者新开的标签页下都不能访问之前写下的 sessionStorage
       - 刷新标签页依然可以访问 sessionStorage

       - 使用场景

         - 主要针对会话级的小数据的存储。
         - 存储一些在当前页面刷新仍然需要存储，但是关闭后不需要留下的信息
         - 很适合单页应用的使用，可以用来存储登录态信息等

     - **localStorage**

       - 长久储存，除非主动删除数据，否则数据是永远不会过期的，大小一般限定为 4M 左右

       - 同源策略：和 sessionStorage 一样，要访问同一个 localStorage 页面必须来自同一个域名，同种协议，同种端口

         - 不能跨域，但可以使用 postMessage 和 iframe 消除这个影响

       - **跨标签页**：localStorage 设定后，刷新或者重新打开标签页，关闭浏览器重新打开原来的标签页也可以访问到

       - 如果有一些数据，服务器难以承载其压力，但又要与用户的信息绑定的话，可以使用 localStorage 存储一些状态，这样即能缓解服务端压力，也可以存储用户的数据

     - Storage 事件

       - 对 Storage 对象进行任何的操作，都会在文档上触发 Storage 事件， 这个事件的 event 对象有以下属性
         - domain：发生变化的存储空间的域名
         - key：设置或删除的键名
         - newValue：如果是设置值，则是新值。如果是删除键，则为 null
         - oldValue：键被更改之前的值

   - 数据库级别

     - indexeddb：类似 NoSQL，直接使用 js 的方法操作数据

     - Web SQL：类似关系型数据库， 它使用 sql 语句进行相关操作

     - 特点
       - 访问：indexDB 和 Web SQL 和 Web Storage 一样，均是只能在创建数据库的域名下才能访问
       - 存储时间：存储时间为永久，除非用户清除数据，他可用作长期的存储
       - 大小限制：二者其实没有强制限制。只是 indexDB 在数据超过 50 M 之后会从浏览器弹出一个框让你确认
       - 性能：indexDB 查询速度会相对较慢，而 Web SQL 的性能相对较快

4. **重绘和回流**

   - 重绘(Repaint)：当节点需要更改外观、风格等而不会影响布局

     - 比如：改变 color、background-color、visibility 等

   - 回流(Reflow)：布局或者几何属性需要改变

     - 页面首次渲染、浏览器窗口大小发生改变、元素尺寸或位置发生改变、元素内容变化（文字数量或图片大小等等）、元素字体大小变化、添加或者删除可见的 DOM 元素、**激活 CSS 伪类**、查询某些属性或调用某些方法

     - 一些常用且会导致回流的属性和方法
       - clientWidth、clientHeight、clientTop、clientLeft
       - offsetWidth、offsetHeight、offsetTop、offsetLeft
       - scrollWidth、scrollHeight、scrollTop、scrollLeft
       - scrollIntoView()、scrollIntoViewIfNeeded()
       - getComputedStyle()
       - getBoundingClientRect()
       - scrollTo()

   - 注意：

     - 回流必定重绘，重绘不一定回流。
     - 回流所需的成本比重绘高得多，改变深层次的节点很可能导致父节点的一系列回流

   - 重绘和回流与 Event loop 的关系

     1. 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次
     2. 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能
     3. 判断是否触发了 media query
     4. 更新动画并且发送事件
     5. 判断是否有全屏操作事件
     6. 执行 requestAnimationFrame 回调
     7. 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
     8. 更新界面
     9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调

   - 减少重绘和回流

     - CSS

       - 避免使用 table 布局
         - 可能很小的一个小改动会造成整个 table 的重新布局
       - 尽可能在 DOM 树的最末端改变 class
       - 避免设置多层内联样式
       - CSS 选择符从右往左匹配查找，避免 DOM 深度过深
       - 将动画效果应用到 position:absolute/fixed 的元素上
       - 避免使用 CSS 表达式
         - eg：calc()
       - 使用 translate 替代 top
       - 使用 visibility 替换 display: none

         - 因为前者只会引起重绘，后者会触发回流

       - 动画实现的速度的选择

         - 动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame

       - 将频繁运行的动画变为图层
         - 图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层

     - JavaScript

       - 避免频繁操作样式

         - 最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性

       - 避免频繁操作 DOM

         - 创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中
         - 避免把 DOM 结点的属性值放在一个循环里当成循环里的变量

       - 把 DOM 离线后修改

         - 先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘

       - 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流

5. **浏览器架构**

6. **浏览器下事件循环(Event Loop)**

   - 宏任务

   - 微任务

7. **Web Worker**

   现代浏览器为 JavaScript 创造的 多线程环境。
   可以新建并将部分任务分配到 worker 线程并行运行，两个线程可**独立运行，互不干扰**，可通过自带的**消息机制**相互通信。

   - postMessage //向 worker 发送数据
   - onmessage //接收 worker 传过来的数据函数

   **基本用法**

   ```javascript
   // 创建 worker
   const worker = new Worker("work.js");

   // 向主进程推送消息
   worker.postMessage("Hello World");

   // 监听主进程来的消息
   worker.onmessage = function (event) {
     console.log("Received message " + event.data);
   };
   ```

   **限制**

   - 同源限制
   - 无法使用 document / window / alert / confirm
   - 无法加载本地资源

# 服务端与网络

1. **http 和 https**

   - http：超文本传输协议(Hyper Text Transfer Protocol)
     从 WEB 服务器传输超文本标记语言(HTML)到本地浏览器的传送协议，可以使浏览器更加高效，使网络传输减少。

     - 原理

       - 基于 TCP/IP 通信协议来传递数据，传输的数据类型为 HTML 文件, 图片文件, 查询结果等
       - 一般用于 B/S 架构。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。

     - 特点

       - **基于请求和响应**：客户端发起请求，服务端响应
       - **无状态**：协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都**不做持久化处理**。这是为了更快地处理大量事务，确保协议的可伸缩性。
       - **无连接**：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接。不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录 http 状态的技术，一个叫做 Cookie,一个叫做 Session。
         - HTTP/1.1 和部分 HTTP/1.0 的改进：**持久连接**：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。
         - **管线化**：持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应。
       - **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。
       - **灵活**：HTTP 允许传输任意类型的数据对象。传输的类型由 Content-Type 加以标记。

     - http 工作流程

       - 地址解析：解析出协议名、主机名、端口、对象路径等部分
       - 封装 HTTP 请求数据包
       - 封装成 TCP 包，建立 TCP/IP 连接(TCP/IP 三次握手)
       - 客户端向服务端发起 HTTP 请求。(例如：POST/login.html http/1.1)
         - 最后会发送一空白行，标示客户端请求完毕
       - 服务器响应
         - 服务器向客户端发送应答头信息(例如：HTTP/1.1 200 OK)
         - 之后服务端也会发送一个空白行，表示应答头信息发送完毕，接着就以 Content-type 要求的数据格式发送数据给客户端
       - 服务端关闭 TCP 连接
         - 如果服务器或者客户端在其头信息加入 Connection:keep-alive，就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接

   - https：超文本传输安全协议(Hypertext Transfer Protocol Secure)。是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。

     - 原理

       - 客户端向服务器端索要并验证公钥。
         - 这一阶段使用的是非对称加密传输(RSA)，服务端将数字证书发给客户端。其中数字证书包括：公钥和数字签名。客户端在拿到后对两者进行校验.
       - 在非对称加密传输中,两端协商生成"对话密钥"。
       - 双方采用"对话密钥"进行对称加密通信。

     - 特点

       - 优点

         - 内容加密
         - 保护数据完整性
         - 对网站服务器进行真实身份认证

       - 缺点

         - https 协议握手阶段比较费时
         - https 连接缓存不如 http 高效，会增加数据开销和功耗
         - https 连接服务器端资源占用相比于 http 高很多， 会降低用户的访问速度
           - SSL 涉及到的安全算法会消耗 CPU 资源
         - 申请 SSL 证书需要钱，功能越强大的证书费用越高
         - SSL 证书通常需要绑定 IP，不能再同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗

     - https 工作流程

       - ![image](https://pics1.baidu.com/feed/023b5bb5c9ea15ce26b853cd9cdca2f73887b284.jpeg?token=5ee5bde0022bc60fbbcfb1fe34e739b7&s=7EAC3C6259DFC0C8485CE0DB0000C0B1)

       - 客户端通过 URL 访问服务器建立 SSL 连接。
       - 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
       - 客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。
       - 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
       - 服务器利用自己的私钥解密出会话密钥。
       - 服务器利用会话密钥加密与客户端之间的通信。

   - http 和 https 的区别
     - https 协议需要到 CA 申请证书，一般免费证书很少，需要交费
     - http 信息是明文传输，会被他人截获，不安全；https 通过 SSL\TLS 进行加密，传输信息不易被截获，非常安全
     - http 使用的端口是 80，HTTPS 是 443
     - http 的连接很简单,是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全
     - 在 OSI 网络模型中，http 工作于应用层，而 https 工作在传输层

2. **TCP 和 UDP 协议**

3. **DNS 域名解析**

4. **缓存策略: 强缓存 和 协商缓存**

   - 缓存：保存资源副本并在下次请求时直接使用该副本的技术。

   - 缓存的好处

     - 缓解服务器压力(不用每次去请求资源)
     - 减少页面加载时间，提升性能
     - 减少网络传输，减少带宽消耗

   - 缓存的分类

     - 宏观

       - 私有缓存: 用户专享，各级代理不能缓存
       - 共享缓存: 能够被多个用户使用的缓存,也就是那些能被各级代理的缓存

     - 微观：浏览器缓存、代理服务器缓存、网关缓存、数据库缓存

   - 浏览器缓存

     - 浏览器缓存分为强缓存和协商缓存，强缓存会直接读取浏览器缓存，不会向服务器发送请求，而协商缓存先向访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据

     - ![image](https://mmbiz.qpic.cn/mmbiz_jpg/vzEib9IRhZD5sp48Jfr1IrOPOPdmJ4GEIib3icc4wf6TQGp0PqTia9yUlG3OX40jibf3QBmzAIxYmUKX4yTwhaDpwdA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

     - 强缓存(Expires & Cache-Control)

       - 给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期，浏览器需要重新请求

       - 三种情况

         - 第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求
         - 存在缓存标识和缓存结果，但是缓存结果已经失效，则使用协商缓存
         - 存在缓存标识和缓存结果，且该结果尚未失效，强制缓存生效，直接返回该结果

       - Expires：HTTP/1.0 中的定义缓存的字段，告知客户端资源缓存失效的**绝对时间**

         - 返回的是服务器的时间

         > `Expires: Wed Feb 20 2019 11:25:41 GMT`

     - Cache-Control：max-age：HTTP/1.1 定义的关于缓存的字段，它规定了缓存过期的一个**相对时间**

       - public：所有内容都将被缓存(客户端和代理服务器都可缓存)
       - private：所有内容只有客户端可以缓存，Cache-Control 的默认取值
       - no-cache：客户端缓存内容，每次使用需要经过协商缓存来验证决定是否可用
       - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
       - max-age=xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效

     - 优先级：**Cache-Control > Expires**

     - 缺点：该缓存方式优先级高，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源(所以有了协商缓存)

   - 协商缓存(Last-Modified & Etag)

     - 强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

     - 强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道；协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道(协商缓存需要配合强缓存使用)

     - 利用 Last-Modified，If-Modified-Since 和 ETag、If-None-Match 对资源做标识，然后由服务器做分析，如果资源未更新，则返回 304 状态码，那么浏览器则会从缓存中读取资源，否则重新请求资源

     - Last-Modified 与 If-Modified-Since

       - last-modified：资源在服务器上最后一次修改的时间
       - If-Modified-Since：上一次请求时返回的 Last-Modified 的值

       - 服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化

         - 若无变化，返回 304 Not Modified(response header 中不会再添加 Last-Modified 的 header)，不会返回资源内容

         - 若有变化，返回 200，正常返回资源内容

       - 浏览器收到 304 的响应后，就会从缓存中加载资源

       - 浏览器收到 200 的响应后，则从服务器加载新资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值

         - 缺点
           - 周期性修改，但内容未变时，会导致缓存失效
         - 以秒为单位进行更新，如果小于该单位高频进行更新的话，则不适合采用该方法，这时候协商缓存就不那么的可靠了。(所以就有了 ETag、If-None-Match)

     - Etag 与 If-None-Match

       - Etag(response 携带)：服务器根据当前请求的资源生成的一个唯一标识，是一个字符串，只要资源有变化这个标识就会不同，跟最后修改时间没有关系

       - If-None-Match：浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag 的值

       - 服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和资源生成一个新的 ETag，**如果这两个值相同就说明资源没有变化，否则就是有变化**

         - 若无变化，则返回 304 Not Modified，不会返回资源内容(由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化)

         - 若有变化，则返回 200，并正常返回资源内容

       - 浏览器收到 304 的响应后，就会从缓存中加载资源

       - 浏览器收到 200 的响应后，则从服务器加载新资源时，ETag 在重新加载时会被更新，下次请求时，If-None-Match 会启用上次返回的 ETag 值

     - ETag 相对于 Last-Modified 可更加准确地判断文件内容是否被修改；但由于需要对资源进行生成标识，性能方面势必有所牺牲

     - Last-Modified、If-Modified-Since 和 ETag、If-None-Match 一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。

       - 注：分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败

       - 分布式系统尽量关闭掉 ETag(每台机器生成的 ETag 都会不一样）

     - 优先级：**ETag/If-None-Match > Last-Modified/If-Modified-Since**, 同时存在时, 前者覆盖后者

   - 启发式缓存

     - 当请求头中确定缓存过期时间的字段一个都没有，会默认触发浏览器启发式缓存。

   - 缓存的优先级

     - 强缓存 > 协商缓存 > 启发式缓存
     - Cache-Control > Expires > ETag > Last-Modified

     - 浏览器整个缓存策略的过程：
       ![image](https://user-gold-cdn.xitu.io/2018/1/27/16137f262e0adf18?imageView2/0/w/1280/h/960/ignore-error/1)

       - 浏览器先检查 Cache-Control，如果为 no-store，则浏览器所有内容都不会缓存，强制缓存，协商缓存统统都不会触发

5. **http 状态码**

   常见状态码

   | 1XX 接收的请求正在处理 | 2XX 请求正常处理完毕  | 3XX 重定向                                 | 4XX 客户端错误    | 5XX 服务器错误            |
   | ---------------------- | --------------------- | ------------------------------------------ | ----------------- | ------------------------- |
   | 1xx: 接受，继续处理    | 200：成功，并返回数据 | 301: 永久移动，重定向                      | 400: 请求语法错误 | 500: 服务器错误           |
   |                        | 201: 已创建           | 302: 临时移动，可使用原有 URI              | 401: 要求身份认证 | 503：服务器暂时处于超负载 |
   |                        | 202: 已接受           | 303: 资源存在另一个 URI（GET 方法获取请求) | 403: 拒绝请求     | 503：或服务器正在停机维护 |
   |                        | 203: 成功，但未授权   | 304: 资源未修改，可使用缓存                | 404: 资源不存在   |                           |
   |                        | 204: 成功，无内容     | 305: 需代理访问 305: 需代理访问            |                   |                           |
   |                        | 205: 成功，重置内容   | 307: 临时重定向，不会从 POST 变成 GET      |                   |                           |
   |                        | 206: 成功，部分内容   |                                            |                   |                           |

6. **WebSocket**

   特点：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的**双向平等对话**，属于服务器推送技术的一种。(不受同源政策影响)

   - 其他特点:

     - 建立在 TCP 协议之上，服务器端的实现比较容易
     - 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器
     - 数据格式比较轻量，性能开销小，通信高效
     - 可以发送文本，也可以发送二进制数据
     - 没有同源限制，客户端可以与任意服务器通信
     - 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL

   - 新建 WebSocket 实例：var ws = new WebSocket(url)
   - 指定连接成功后的回调函数：**ws.onopen** = fn
   - 指定连接关闭后的回调函数：**ws.onclose** = fn
   - 指定收到服务器数据后的回调函数：**ws.onmessage** = fn
   - 向服务器发送数据：**ws.send()**
   - 指定报错时的回调函数：**ws.onerror** = fn

   - webSocket.readyState

     - CONNECTING：值为 0，表示正在连接
     - OPEN：值为 1，表示连接成功，可以通信了
     - CLOSING：值为 2，表示连接正在关闭
     - CLOSED：值为 3，表示连接已经关闭，或者打开连接失败

7. **Ajax**

8. **get 和 post**

9. **fetch**

10. **跨域，同源策略，如何解决跨域问题**

    - **同源**指的是两个域需要协议，子域名，主域名与端口号都保持一致，四者有一个不同，即属于**跨域**

    - 同源政策的目的

      - 保证用户信息的安全，防止恶意的网站窃取数据

    - 同源策略限制内容

      - Cookie、LocalStorage、IndexedDB 等存储性内容
      - DOM 节点
      - AJAX 请求发送后，结果被浏览器拦截了

    - 特别说明：

      - 如果是协议和端口造成的跨域问题"前台"是无能为力的
      - 在跨域问题上，仅仅是通过"URL 的首部"来识别而不会根据域名对应的 IP 地址是否相同来判断
      - 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了

    - 跨域的**解决方案**

      - **JSONP**

        - 利用 script 标签可以不受限制的从其他域加载资源的能力，进行跨域通信

        - 由两部分组成：回调函数和数据

          - 回调函数是服务端响应带来时，应该调用的函数，需要在 URL 中指定
          - 数据就是服务器返回给浏览器的响应

          - 关键在于：**服务端响应数据是一个函数的调用，真正要发送给客户端的数据作为函数调用的参数**
            ```javascript
            const data = fn({ name: "zs", age: "20" });
            res.send(data);
            ```

        - 优缺点

          - 优点：简单，兼容性好，可用于解决主流浏览器的跨域数据访问的问题
          - 缺点：仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击

        - JSONP 的使用

          - 动态创建一个 script 元素
          - 为 script 指定 src 属性的值，需要将回调函数名拼接给 url，形式为：`callback=functionName`
          - 然后动态地将 script 标签追加到 body 中

          - 前端声明一个函数，函数名作为参数值传递给跨域请求数据的服务器，函数形参为要获取目标函数(服务器返回的 data)；服务器收到请求后，需要进行特殊的处理：把传递进来的函数名和要返回去的数据拼接成一个字符串。最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数，对返回的数据进行操作

          - 简单实现

            ```javascript
            function jsonp(req) {
              var script = document.createElement("script");
              var url = req.url + "?callback=" + req.callback.name;
              script.src = url;
              document = getElementsByTagName("head")[0].appendChild(script);
            }
            ```

            - 前端示例

              ```javascript
              function hello(res) {
                alert("hello" + res.data);
              }

              jsonp({
                url: "",
                callback: hello,
              });
              ```

            - 服务端代码

              ```javascript
              (function (global) {
                var id = 0,
                  container = document.getElementsByTagName("head")[0];

                function jsonp(options) {
                  if (!options || !options.url) return;

                  var scriptNode = document.createElement("script"),
                    data = options.data || {},
                    url = options.url,
                    callback = options.callback,
                    fnName = "jsonp" + id++;

                  // 添加回调函数
                  data["callback"] = fnName;

                  // 拼接url
                  var params = [];
                  for (var key in data) {
                    params.push(
                      encodeURIComponent(key) +
                        "=" +
                        encodeURIComponent(data[key])
                    );
                  }

                  url = url.indexOf("?") > 0 ? url + "&" : url + "?";

                  url += params.join("&");
                  scriptNode.src = url;

                  // 传递的是一个匿名的回调函数，要执行的话，暴露为一个全局方法
                  global[fnName] = function (ret) {
                    callback && callback(ret);
                    container.removeChild(scriptNode);
                    delete global[fnName];
                  };

                  // 出错处理
                  scriptNode.onerror = function () {
                    callback && callback({ error: "error" });
                    container.removeChild(scriptNode);
                    global[fnName] && delete global[fnName];
                  };

                  scriptNode.type = "text/javascript";
                  container.appendChild(scriptNode);
                }
                global.jsonp = jsonp;
              })(this);
              ```

      - 通过 JQuery Ajax 发起 jsonp 请求

        ```javascript
        $.ajax({
          // 请求方式
          type: "get",
          // 请求地址
          url: "http://169.254.200.238:8080/jsonp.do",
          // 标志跨域请求
          dataType: "jsonp",
          // 跨域函数名的键值，即服务端提取函数名的钥匙（默认为callback）
          jsonp: "callbackparam",
          // 客户端与服务端约定的函数名称
          jsonpCallback: "jsonpCallback",
          // 请求成功的回调函数，json既为我们想要获得的数据
          success: function (json) {
            console.log(json);
          },

          // 请求失败的回调函数
          error: function (e) {
            alert("error");
          },
        });
        ```

      - **CORS**(cross-origin-resource) 跨域资源共享

        - 浏览器一旦发现请求跨源，就会在请求报文中自动添加一些附加的 origin 头信息(包括页面源信息：协议、域名和端口号)，有时还会多出一次附加的请求；**服务器**收到请求报文后，如果同意该请求，则在响应报文头部加 Access-Control-Allow-Origin，值与请求报文头的 origin 头部的值一致
        - Access-Control-Allow-Origin：表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源
        - 服务器端设置两个访问头

          - 允许那些客户端访问我
            `res.header('Access-Control-Allow-Origin','*')`

            > \*即请求报文头的 origin 头部的值

          - 允许客户端使用那些请求方式访问我
            `res.header('Access-Control-Allow-Methods','get/post')`

      - 通过这种方式解决跨域问题，会在发送请求时出现两种情况：

        - 简单请求

          - 使用 GET/HEAD/POST 方法之一
          - Content-Type 的值仅限于 text/plain | multipart/form-data | application/x-www-form-urlencoded 中三者之一

        - 复杂请求：不符合以上条件的请求

          - 会在正式通信之前，增加一次 HTTP 查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求

    - **iframe**

      - window.name + iframe

        - window.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值

          ```html
          // a.html(http://localhost:3000/b.html)
          <iframe
            src="http://localhost:4000/c.html"
            frameborder="0"
            onload="load()"
            id="iframe"
          ></iframe>
          <script>
            let first = true;
            // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
            function load() {
              if (first) {
                // 第1次onload(跨域页)成功后，切换到同域代理页面
                let iframe = document.getElementById("iframe");
                iframe.src = "http://localhost:3000/b.html";
                first = false;
              } else {
                // 第2次onload(同域b.html页)成功后，读取同域window.name中数据
                console.log(iframe.contentWindow.name);
              }
            }
          </script>

          // c.html(http://localhost:4000/c.html)
          <script>
            window.name = "我不爱你";
          </script>
          ```

        - a 页面和 b 页面同域，b 为中间代理页面，通过 iframe 的 Src 属性由外域转向本地域，跨域数据由 iframe 的 window.name 从外域传递到本地域。巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作

      - location.hash + iframe

        - 实现原理：a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信

        - 具体实现步骤：一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中

          ```javascript
          // a.html
          <iframe src="http://localhost:4000/c.html#iloveyou"></iframe>
          <script>
            window.onhashchange = function () {
              //检测hash的变化
              console.log(location.hash);
            };
          </script>

          // b.html
          <script>
            window.parent.parent.location.hash = location.hash;
            //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面
          </script>

          // c.html console.log(location.hash); let iframe =
          document.createElement('iframe'); iframe.src =
          'http://localhost:3000/b.html#idontloveyou';
          document.body.appendChild(iframe);
          ```

        - document.domain + iframe

          - 只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式

        - 实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域

    - **postMessage**

      - postMessage 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递
      - otherWindow.postMessage(message, targetOrigin, \[transfer]);

        - message: 将要发送到其他 window 的数据
        - targetOrigin:通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串"\*"（表示无限制）或者一个 URI
        - transfer(可选)：是一串和 message 同时传递的 Transferable 对象

      - example:

        ```javascript
        // a.html
        <iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"></iframe> //等它加载完触发一个事件
        //内嵌在http://localhost:3000/a.html
        <script>
        function load() {
          let frame = document.getElementById('frame');
          frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据
          window.onmessage = function(e) { // 接收返回数据
            console.log(e.data) //我不爱你
          }
        }
        </script>

        // b.html
        window.onmessage = function(e) {
          console.log(e.data) //我爱你
          e.source.postMessage('我不爱你', e.origin)
        }
        ```

        - a 页面设置<\iframe>标签，src 链接到 b 页面，postMessage 向 b 页面发送数据，onmessage 接收 b 页面返回的数据；b 页面 onmessage 接收 a 页面发送的数据，postMessage 向 a 页面发送数据

    - **WebSocket**

      - WebSocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案；
      - 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据
      - WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了

        ```javascript
        // socket.html
        <script>
        let socket = new WebSocket('ws://localhost:3000');
        socket.onopen = function () {
          socket.send('我爱你'); //向服务器发送数据
        }

        socket.onmessage = function (e) {
          console.log(e.data); //接收服务器返回的数据
        }
        </script>

        // server.js
        let express = require('express');
        let app = express();
        let WebSocket = require('ws'); //记得安装ws
        let wss = new WebSocket.Server({port:3000});

        wss.on('connection',function(ws) {
          ws.on('message', function (data) {
            console.log(data);
            ws.send('我不爱你');
          });
        })
        ```

    - **Node 中间件代理(两次跨域)**

      - 同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略

        - 步骤
          - 接受客户端请求
          - 将请求转发给服务器
          - 拿到服务器 响应 数据
        - 将 响应 转发给客户端

    - **nginx 反向代理**

      - 类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求
      - 只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能
      - 实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录

    - 总结

      - CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案
      - JSONP 只支持 GET 请求，JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。
      - 不管是 Node 中间件代理还是 nginx 反向代理，主要是通过同源策略对服务器不加限制。
      - 日常工作中，用得比较多的跨域方案是**cors**和**nginx**反向代理

11. **三次握手 和 四次挥手**

    - 三次握手(根据 IP 建立 TCP 连接)

      - 客户端和服务端互相确认可以收发数据

      - 客户端发送一个 syn 包：即带有 SYN=1，Seq=x 的数据包到服务器端口，并进入 SYN_SENT 状态，等待服务器确认；(第一次握手，由浏览器向服务器发起，告诉服务器我要发生请求了)

      - 服务器收到 syn 包，必须确认客户的 SYN，同时发回一个带 SYN=1， ACK=x+1， Seq=y 的响应包以示传达确认信息，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；（第二次握手，由服务器发起，告诉浏览器我准备好接收信息了）

      - 客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK，即回传一个带 ACK=y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发送信息了，准备接收吧）

      ![image](https://user-gold-cdn.xitu.io/2019/2/22/16914083b8093f55?imageView2/0/w/1280/h/960/format/png/ignore-error/1)

      - 为何建立连接需要三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

    - 四次挥手(关闭 TCP 连接)

      - 通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)

      ![image](https://user-gold-cdn.xitu.io/2019/2/22/169140a85c0fec37?imageView2/0/w/1280/h/960/format/png/ignore-error/1)

      - 第一次挥手：客户端向服务端发送报文，Fin、Ack、Seq，表示已经没有数据传输了，并进入 FIN_WAIT_1 状态。(浏览器发起，发送给服务器，告知服务器请求报文发送完毕，你可以准备关闭了)

      - 第二次挥手：服务端收到 FIN 后，发送响应报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(服务器发起，告诉浏览器，我请求报文接收完了，准备关闭了，你也准备吧)

      - 第三次挥手：服务端向客户端发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(服务器告诉浏览器，我响应报文发送完了，你准备关闭吧)

      - 第四次挥手：客户端收到 FIN 后向服务端发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。服务端收到客户端的报文段后关闭连接(CLOSED)，客户端等待一定时间未收到回复，则正常关闭。(浏览器发起，告诉服务器，我响应报文接收完毕了，我准备关闭了，你也准备吧。)

      - 为什么关闭连接需要四次挥手：关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。

12. **CSRF 和 XSS 区别及防御**

13. **进程 和 线程**

14. **Socket.io**

# Vuejs

1. **生命周期**

   - 总共分 8 个阶段：创建前/后，载入前/后，更新前/后，销毁前/后

   - \_init\_

     - initLifecycle/Event，往 vm 上挂载各种属性
     - callHook: beforeCreated: 实例刚创建
     - initInjection/initState: 初始化注入和 data 响应性
     - created: 创建完成，属性已经绑定， 但还未生成真实 dom
     - 进行元素的挂载： $el / vm.$mount()
     - 是否有 template: 解析成 render function
       - \*.vue 文件: vue-loader 会将<\template>编译成 render function
     - beforeMount: 模板编译/挂载之前
     - 执行 render function，生成真实的 dom，并替换到 dom tree 中
     - mounted: 组件已挂载

   - update:

     - 执行 diff 算法，比对改变是否需要触发 UI 更新
     - flushScheduleQueue
     - watcher.before: 触发 beforeUpdate 钩子 - watcher.run(): 执行 watcher 中的 notify，通知所有依赖项更新 UI
     - 触发 updated 钩子: 组件已更新

   - actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活

   - destroy:

     - beforeDestroy: 销毁开始
     - 销毁自身且递归销毁子组件以及事件监听
     - remove(): 删除节点
     - watcher.teardown(): 清空依赖
     - vm.\$off(): 解绑监听
     - destroyed: 完成后触发钩子

   - 所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。所以不要在 property 或回调上使用箭头函数，因为箭头函数没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止。

   | 生命周期钩子  | 描述                                                                                                                  |
   | ------------- | --------------------------------------------------------------------------------------------------------------------- |
   | beforeCreate  | 在实例初始化之后，数据观测(data observer)和 event/watcher 事件配置之前被调用                                          |
   | created       | 在实例创建完成后被立即调用，实例已完成数据观测，property 和方法的运算，watch/event 事件回调（模板渲染成 html 前调用） |
   | beforeMount   | 在挂载开始之前被调用：相关的 render 函数首次被调用                                                                    |
   | mounted       | 实例被挂载后调用，这时 el 被新创建的 vm.\$el 替换了（模板渲染成 html 后调用）                                         |
   | beforeUpdate  | 数据更新时调用，发生在虚拟 DOM 打补丁之前                                                                             |
   | updated       | 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子                                                     |
   | activated     | 被 keep-alive 缓存的组件激活时调用                                                                                    |
   | deactivated   | 被 keep-alive 缓存的组件停用时调用                                                                                    |
   | beforeDestroy | 实例销毁之前调用。在这一步，实例仍然完全可用                                                                          |
   | destroyed     | 实例销毁后调用。被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁             |
   | errorCaptured | 当捕获一个来自子孙组件的错误时被调用                                                                                  |

   - 注意：
     - mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.\$nextTick：
       ```javascript
       mounted: function() {
         this.$nextTick(function() {
           // Code that will run only after the entire view has been rendered
         })
       }
       ```
     - updated 不会保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 updated 里使用 vm.\$nextTick：
       ```javascript
       updated: function() {
         this.$nextTick(function() {
           // Code that will run only after the entire view has been re-rendered
         })
       }
       ```
     - errorCaptured：此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。

   ```javascript
   new Vue({});
   // 初始化Vue实例
   function _init() {
     initLifeCycle(vm); // 挂载属性
     initEvent(vm); // 初始化事件系统，钩子函数等
     initRender(vm); // 编译slot、vnode
     callHook(vm, 'beforeCreate'); // 触发钩子
     initInjection(vm); // 添加inject功能
     // 完成数据响应性 props/data/watch/computed/methods
     initState(vm);
     initProvide(vm); // 添加 provide 功能
     callHook(vm, 'created'); // 触发钩子
     // 触发钩子
     if(vm.$options.el) {
       vm.$mount(vm.$options.el);
     }
   }

   // 挂载节点实现
   function mountComponent(vm) {
     if(!this.options.render) { // 获取 render function
       // template to render
       // Vue.compile = compileToFunctions
       let { render } = compileToFunctions();
       this.options.render = render;
     }

     callHook('beforeMounte'); // 触发钩子
     // 初始化观察者
     // render 渲染 vdom，
     vdom = vm.render();
     // update: 根据 diff 出的 patchs 挂载成真实的 dom
     vm._update(vdom);
     // 触发钩子
     callHook(vm, 'mounted');
   }

   // 更新节点实现
   function queueWatcher(watcher) {
     nextTick(flushScheduleQueue);
   }

   // 清空队列
   function flushScheduleQueue() {
     for() {
       // beforeUpdate;
       watcher.before();
       // 依赖局部更新节点
       watcher.update();
       callHook('updated');
     }
   }

   // 销毁实例实现
   Vue.prototype.$destory = function() {
     callHook(vm, 'beforeDestory'); // 触发钩子
     remove(); // 自身及子节点
     watcher.teardown(); // 删除依赖
     vm.$off(); // 删除监听
     callHook(vm, 'destoryed'); // 触发钩子
   }
   ```

   - ![image text](https://cn.vuejs.org/images/lifecycle.png?_sw-precache=6f2c97f045ba988851b02056c01c8d62)

2. **Vue 的优点**

   - 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 `kb` ；
   - 简单易学
   - 双向数据绑定：保留了 `angular` 的特点，在数据操作方面更为简单；
   - 组件化：保留了 `react` 的优点，实现了 `html` 的封装和重用，在构建单页面应用方面有着独特的优势；
   - 视图、数据、结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
   - 虚拟 DOM：`dom` 操作是非常耗费性能的， 不再使用原生的 `dom` 操作节点，极大解放 `dom` 操作，但具体操作的还是 `dom` 不过是换了另一种方式；
   - 运行速度更快：相比较于 `react` 而言，同样是操作虚拟 `dom` ，就性能而言， `vue` 存在很大的优势。

3. **Vue 组件间传递参数**

   - 父组件向子组件传递参数

     - props

       注册子组件，props 接收父子间发送的数据

       ```javascript
       Vue.component("blog-post", {
         props: ["title"],
         template: "<h3>{{title}}</h3",
       });
       ```

       - props 值有两种方式：字符串数组、对象

       - prop 验证

         ```javascript
         Vue.component("my-component", {
           props: {
             // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
             propA: Number,
             // 多个可能的类型
             propB: [String, Number],
             // 必填的字符串
             propC: {
               type: String,
               required: true,
             },
             // 带有默认值的数字
             propD: {
               type: Number,
               default: 100,
             },
             // 带有默认值的对象
             propE: {
               type: Object,
               // 对象或数组默认值必须从一个工厂函数获取
               default: function () {
                 return { message: "hello" };
               },
             },
             // 自定义验证函数
             propF: {
               validator: function (value) {
                 // 这个值必须匹配下列字符串中的一个
                 return ["success", "warning", "danger"].indexOf(value) !== -1;
               },
             },
           },
         });
         ```

   - 子组件向父组件传递参数

     - \$emit() -> 自定义事件

       ```javascript
       // 子组件里：
       this.$emit('item-click');

       // 父组件里
       <cpn @item-click="cpnClick"></cpn>
       ```

4. **数据双向绑定**

   - v-model：表单数据的双向绑定

     - 语法糖，其本质是两个操作的结合：`v-bind` 绑定一个 `value` 属性；`v-on` 指令给当前元素绑定事件。
     - 会忽略所有表单元素的 `value`、`checked`、`selected` attribute 的初始值而总是将 Vue 实例的数据作为数据来源。应该在组件的 `data` 选项中声明初始值。

     - 在内部为不同的输入元素使用不同的 property 并抛出不同的事件
       - text 和 textarea 元素使用 `value` property 和 `input` 事件；
       - checkbox 和 radio 使用 `checked` property 和 `change` 事件；
       - select 字段将 `value` 作为 prop 并将 `change` 作为事件。

   - Vue 是数据双向绑定的框架(MVVM)，由三个部分组成：

     - 数据层(Model)：应用的数据及业务逻辑，为开发者编写的业务代码
     - 视图层(View)：应用的展示效果，各类 UI 组件，由 template 和 css 组成的代码
     - 业务逻辑层(ViewModel)：框架封装的核心，它负责将数据与视图关联起来
       - 主要职责：数据变化后更新视图，视图变化后更新数据
       - 故其由两部分组成
         - 监听器（Observer）：观察数据，做到时刻清楚数据的任何变化，然后通知视图更新
         - 解析器（Compiler）：观察 UI，做到时刻清楚视图发生的一切交互，然后更新数据

   - **数据双向绑定原理**

     - ![image](https://user-gold-cdn.xitu.io/2019/8/16/16c986328e407929?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

     - 采用**数据劫持**结合**发布-订阅模式**的方式，通过**Object.defineProperty()**来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者。

       - `Object.defineProperty(obj, prop, descriptor)`

       ```javascript
       var obj  = {}; // 目标对象
       // prop：'name' 需定义或修改的属性的名字
       // descriptor：目标属性所拥有的特性
       Object.defineProperty(obj, 'name', {
         get: function() {
           console.log('获取了')
           return val;
         },
         set: function (newVal) {
             console.log('设置了')
       }
       })

       obj.name = 'yzg'; / /在给obj设置name属性的时候，触发了set这个方法
       var val = obj.name;  //在得到obj的name属性，会触发get方法
       ```

     - 模板编译 Compiler（实现视图到数据的绑定）

       ```javascript
       class Compile {
         //vm-->MVVM中传入的第二个参数就是MVVM的实例，即new MVVM()
         constructor(el, vm) {
           //传入的可能是 #app或者document.getElementById('app'),所以需要进行判断
           this.el = this.isElementNode(el) ? el : document.querySelector(el);
           this.vm = vm;
           //防止用户输入的既不是“#el”字符串也不是document节点
           if (this.el) {
             //如果这个元素能够获取到，我们才开始编译
             //1.先把真实的DOM移入到内存中（优化性能） -->使用节点碎片 fragment
             let fragment = this.nodeToFragment(this.el);
             //2.编译=>提取想要的元素节点（v-model）和文本节点{{}}
             this.compile(fragment)
             //3.把编译好的fragment在放回到页面中
             this.el.appendChild(fragment)
           }
         }

         nodeToFragment(el) { //需要将el中的内容全部放入到内存中
           //文档碎片，不是真正的DOM，是内存中的节点
           let fragment = document.createDocumentFragment();
           let firstChild;
           while (firstChild = el.firstChild) {
             //将el中的真实节点一个一个的移入到文档碎片中
             //el.firstChild指文档中的第一个节点，这一个节点里面可能嵌套很多个节点，但是都没关系，都会一次取走
             fragment.appendChild(firstChild);
           }
           return fragment; // 内存中的节点
         }

         compile(fragment) {
           //需要递归
           let childNodes = fragment.childNodes; //只拿到第一层（父级），拿不到嵌套层的
           Array.from(childNodes).forEach(node => {
             if (this.isElementNode(node)) {
               this.compileElement(node); //这里的需要编译元素
               //是元素节点，还需要继续深入的检查（如果是元素节点，有可能节点里面会嵌套节点，所以要使用递归）
               this.compile(node) //因为外层是箭头函数，所以this始终指向Compile实例
             } else {
               //是文本节点,这里需要编译文本
               this.compileText(node)
             }
           })
         }

         compileElement(node) {
           //编译带v-model、v-text等的（取节点的属性）
           let attrs = node.attributes; //取出当前节点的属性
           Array.from(attrs).forEach(attr => {
             //判断属性名字是不是包含v-
             let attrName = attr.name;
             if (this.isDirective(attrName)) {
               //取到对应的值，放到节点中
               let expr = attr.value;
               let [, type] = attrName.split('-') //解构赋值
               //node  this.vm.$data expr  //这里可能有v-model或v-text  还有可能有v-html（这里只处理前两种）
               CompileUtil[type](node, this.vm, expr)
             }
           })
         }

         compileText(node) {
           //编译带{{}}
           let expr = node.textContent; //取文本中的内容
           let reg = /\{\{([^}]+)\}\}/g;
           if (reg.test(expr)) {
             //node this.vm.$data expr
             CompileUtil['text'](node, this.vm, expr)
           }
         }

         //文本更新
         textUpdater(node, value) {
           node.textContent = value
         },
         //输入框更新
         modelUpdater(node, value) {
           node.value = value
         }

         //数据变化了，应该调用这个watch的callback
         new Watcher(vm, expr, (newValue) => {
           //当值变化后，会调用cb将新值传递过来（）
           updateFn && updateFn(node, this.getVal(vm, expr))
         })

       }
       ```

     - 数据劫持 Observer：对 `data`中的每一个属性值进行监测，只要数据变化了

       ```javascript
       class Observer {
         constructor(data) {
           this.observer(data);
         }

         observer(data) {
           //要对这个data数据原有的属性改成set和get的形式
           if (!data || typeof data !== "object") {
             //排除数据不存在或者不是对象的情况
             return;
           }

           //要将数据一一劫持，先获取到data的key和value
           Object.keys(data).forEach((key) => {
             //该方法是将对象先转换成数组，再循环
             //劫持(定义一个函数，数据响应式)
             this.defineReactive(data, key, data[key]);
             //深度递归劫持（添加set和get方法）
             //这里的递归只会为初始的data中的数据进行劫持，如果在defineReactive函数中使用set新增加则不会进行劫持
             this.observer(data[key]);
           });
         }

         //定义响应式
         defineReactive(obj, key, value) {
           //在获取某个值的时候，可以在获取或更改值的时候，做一些处理
           let that = this;
           let dep = new Dep(); //每个变化的数据都会对应一个数组，这个数组是存放所有更新的操作
           Object.defineProperty(obj, key, {
             enumerable: true,
             configurable: true,
             get() {
               // 读取数据时触发
               // 收集有哪些依赖使用了数据
               // 当getter被触发时，去通知getter中收集的依赖数据发生了相应变化
               Dep.target && dep.addSub(Dep.target);
               return value;
             },
             set(newValue) {
               // 修改数据时触发
               //当给data属性中设置值的时候，更改获取的属性的值
               if (newValue !== value) {
                 // 如果值变化了
                 console.log(this, "this"); //这个this指向的是被修改的值
                 //但是这里的this不是Observer的实例,所以需要在最初保存一下当前this指向
                 that.observer(newValue); //如果是对象继续劫持
                 value = newValue;
                 // 通知数据变化，间接调用`watcher.update()`
                 dep.notify();
               }
             },
           });
         }
       }
       ```

     - 观察者 Watcher：新值和老值进行比对，如果发生变化，就调用更新方法，进行视图的更新

       ```javascript
       class Watcher {
         constructor(vm, expr, cb) {
           this.vm = vm;
           this.expr = expr;
           this.cb = cb;
           //先获取一下旧值this.value = this.get();
         }
         getVal(vm, expr) {
           //获取实例上对应的数据
           expr = expr.split(".");
           return expr.reduce((prev, next) => {
             //vm.$data.a....
             return prev[next];
           }, vm.$data);
         }

         get() {
           Dep.target = this; //将当前watcher实例放入到tartget中
           let value = this.getVal(this.vm, this.expr);
           Dep.target = null;
           return value;
         }
         //对外暴露的方法
         update() {
           let newValue = this.getVal(this.vm, this.expr);
           let oldValue = this.value;
           if (newValue !== oldValue) {
             this.cb(newValue); //对应watch的callback
           }
         }
       }
       ```

       - 发布-订阅模式(观察者模式)

         ```javascript
         //observer.js
         /**发布订阅**/
         // 用来收集依赖(Watcher)、删除依赖和向依赖发送消息等
         class Dep {
           constructor() {
             this.subs = []; //订阅的数组
           }
           addSub(watcher) {
             //添加订阅者
             this.subs.push(watcher);
           }
           removeSub(sub) {
             remove(this.subs, sub);
           }
           notify() {
             //通知
             // 一个数据可能有多个订阅者
             // 当一个数据有变化时，循环依赖列表，通知所有的Watcher
             this.subs.forEach((watcher) => {
               watcher.update();
             });
           }
         }

         function remove(arr, item) {
           if (arr.length) {
             const index = arr.indexOf(item);
             if (index > -1) {
               return arr.splice(index, 1);
             }
           }
         }
         ```

     - 总结

       - Compile：指令解析，初始化视图，并且订阅数据变化，绑定更新函数

       - Observer：对数据进行劫持，对 data 中的每一个属性值进行监测，**将属性转换成 getter/setter 的形式来追踪并通知数据变化**，其响应式核心是`defineProperty`。

         - 因为 data 可能是多层嵌套的对象，所以深度递归劫持，设置递归出口，排除数据不存在或者不是对象的情况。但是此处的递归只会为 data 中初始的数据进行劫持，对于新加进来的则不会，因此在为数据添加 set 方法时，也对数据进行劫持

       - Watcher：订阅者，`Compile`和`Observer`的中介点，用来观察数据变化，在接收数据变更的同时，让 Dep 添加当前 Watcher，并及时通知视图进行更新。

         - 数据变更了通知 watcher，然后它再通知其他地方

         - 只有 Watcher 触发的 getter 才会收集依赖，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中。

       - Data、Observer、Dep 和 Watcher 之间的关系 -- _援引自深入浅出 vuejs_

         - Data 通过 Observer 转换成了 getter/setter 的形式来追踪变化。
         - 当外界通过 Watcher 读取数据时会触发 getter 从而将 watcher 添加到依赖中。
         - 当数据发生了变化，会触发 getter，从而向 Dep 中的依赖(Watcher)发送通知。
         - Watcher 收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。

5. **v-if 和 v-show**

   - **v-if** 用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truethy 值的时候被渲染
   - **v-show** 用于根据条件展示元素
     - 带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display
   - **v-if 和 v-show 的共同点**：都能控制元素的显示和隐藏
   - **v-if 和 v-show 的区别**
     - v-if：是"真正"的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。动态的向 DOM 树内添加或者删除 DOM 元素，若初始值为 `false` ，就不会编译了，如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块
     - v-show：不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。本质就是通过控制 css 中的 `display` 设置为 `none`来控制隐藏，只会编译一次；
     - 一般来说 v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销
     - 当显示与隐藏切换频率高，用 v-show，只有一次切换: v-if

6. **如何让 CSS 只在当前组件中起作用**

   - 在组件中的 `style` 前面加上 `scoped`

     ```html
     <style scoped>
       @media (min-width: 250px) {
         .list-container:hover {
           background: orange;
         }
       }
     </style>
     ```

     这个可选 `scoped` attribute 会自动添加一个唯一的 attribute (比如 `data-v-21e5b78`) 为组件内 CSS 指定作用域，编译的时候 `.list-container:hover` 会被编译成类似 `.list-container[data-v-21e5b78]:hover`

7. **\<keep-alive>\</keep-alive>的作用是什么**

   - `keep-alive` 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染

     ```html
     <!-- 失活的组件将会被缓存！-->
     <keep-alive>
       <component v-bind:is="currentTabComponent"></component>
     </keep-alive>
     ```

   - **Props**：

     - `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存。
     - `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
     - `max` - 数字。最多可以缓存多少组件实例。

     ```html
     <!-- 逗号分隔字符串 -->
     <keep-alive include="a,b">
       <component :is="view"></component>
     </keep-alive>

     <!-- 正则表达式 (使用 `v-bind`) -->
     <keep-alive :include="/a|b/">
       <component :is="view"></component>
     </keep-alive>

     <!-- 数组 (使用 `v-bind`) -->
     <keep-alive :include="['a', 'b']">
       <component :is="view"></component>
     </keep-alive>

     <keep-alive :max="10">
       <component :is="view"></component>
     </keep-alive>
     ```

   - `<keep-alive>` 不会在函数式组件中正常工作，因为它们没有缓存实例。

8. **如何获取 dom**

   - `ref = "domName"`

     `this.$refs.domName`

9. **几种 vue 当中的指令和它的用法**

   | 指令      | 描述                                                                                                                                                           |
   | --------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | v-text    | 更新元素的 `textContent`。                                                                                                                                     |
   | v-html    | 更新元素的 `innerHTML`<br />容易导致 XSS 攻击。故只在可信内容上使用 `v-html`，**永不**用在用户提交的内容上                                                     |
   | v-show    | 根据表达式之真假值，切换元素的 `display` CSS property                                                                                                          |
   | v-if      | 根据表达式的值的 truthiness 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建                                                                  |
   | v-else    | 为 `v-if` 或者 `v-else-if` 添加“else 块”                                                                                                                       |
   | v-else-if | 表示 `v-if` 的“else if 块”。可以链式调用                                                                                                                       |
   | v-for     | 基于源数据多次渲染元素或模板块                                                                                                                                 |
   | v-on      | 缩写：@<br />绑定事件监听器                                                                                                                                    |
   | v-bind    | 缩写：：<br />动态地绑定一个或多个 attribute，或一个组件 prop 到表达式                                                                                         |
   | v-model   | 在表单控件或者组件上创建双向绑定，它会根据控件类型自动选取正确的方法来更新元素                                                                                 |
   | v-slot    | 缩写：#<br />提供具名插槽或需要接收 prop 的插槽                                                                                                                |
   | v-pre     | 跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译                                                           |
   | v-cloak   | 这个指令保持在元素上直到关联实例结束编译。<br />和 CSS 规则如 `[v-cloak] { display: none }` 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 |
   | v-once    | 只渲染元素和组件**一次**。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能                                              |

   - v-on 监听多个方法/自定义事件

     ```javascript
     <!-- 监听多个方法：对象语法 -->
     <button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
     <!-- 监听自定义事件 -->
     <my-component @my-event="handleThis"></my-component>
     ```

   - v-on 修饰符

     - `.stop` - 调用 `event.stopPropagation()`。
     - `.prevent` - 调用 `event.preventDefault()`。
     - `.capture` - 添加事件侦听器时使用 capture 模式。
     - `.self` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
     - `.{keyCode | keyAlias}` - 只当事件是从特定键触发时才触发回调。
     - `.native` - 监听组件根元素的原生事件。
     - `.once` - 只触发一次回调。
     - `.left` - 只当点击鼠标左键时触发。
     - `.right` - 只当点击鼠标右键时触发。
     - `.middle` - 只当点击鼠标中键时触发。
     - `.passive` - 以 `{ passive: true }` 模式添加侦听器

   - v-bind 修饰符

     - `.prop` - 作为一个 DOM property 绑定而不是作为 attribute 绑定。
     - `.camel` - 将 kebab-case attribute 名转换为 camelCase。
     - `.sync` 语法糖，会扩展成一个更新父组件绑定值的 `v-on` 侦听器。

   - v-model 修饰符
     - `.lazy` - 取代 `input` 监听 `change` 事件
     - `.number`- 输入字符串转为有效的数字
     - `.trim` - 输入首尾空格过滤

10. **为什么组件 data 必须是函数**

    > 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？

    - 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响(等于是子组件的 data 属性都指向这个对象的内存地址了)；
    - 如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；
    - new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。

11. **vue-loader**

    - vue-loader 是基于 webpack 的一个 loader，解析和转换.vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模板 template，再分别把它们交给对应的 loader 去处理，核心的作用，就是提取。

    - 特性

      - 默认支持 ES6

      - 允许对 Vue 组件的组成部分使用其它 webpack loader，比如对 `<style>` 使用 Sass 和对 `<template>` 使用 Jade

      - `.vue` 文件中允许自定义节点，然后使用自定义的 loader 进行处理

      - 把 `<style>` 和 `<template>` 中的静态资源当作模块来对待，并使用 webpack loader 进行处理

      - 对每个组件模拟出 CSS 作用域（scoped）

      - 支持开发期组件的热重载

        - 不是当你修改文件的时候简单重新加载页面。启用热重载后，当你修改 `.vue` 文件时，所有该组件的实例会被替换，**并且不需要刷新页面**。它甚至保持应用程序和被替换组件的当前状态

        - 热重载默认是开启的，除非遇到以下情况：

          - webpack 的 `target` 的值是 `node` (服务端渲染)
          - webpack 会压缩代码
          - `process.env.NODE_ENV === 'production'`
          - 可以设置 `hotReload: false` 选项来显式关闭热重载

          ```javascript
          module: {
            rules: [
              {
                test: /\.vue$/,
                loader: "vue-loader",
                options: {
                  hotReload: false, // 关闭热重载
                },
              },
            ];
          }
          ```

12. **为什么使用 key**

    - 作用：主要用在 Vue 的虚拟 DOM 算法( `Diff`)，在复杂的列表渲染中快速准确的找到与`newVnode`相对应的`oldVnode`，提升`diff`效率。（相当于给每个节点一个唯一标识）

    - 如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素

      - 一般设置 key 值得节点可以在 diff 中更快速地找到对应节点，提高 diff 速度

    - 有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误

      ```javascript
      // 参见Vue2源码 core/vdom/patch.js
      // 判断两个节点是否为同一节点：key是首要条件
      function sameVnode (a, b) {
          return (
              a.key === b.key && (
                  (
                      a.tag === b.tag &&
                      a.isComment === b.isComment &&
                      isDef(a.data) === isDef(b.data) &&
                      sameInputType(a, b)
                  ) || (
                      isTrue(a.isAsyncPlaceholder) &&
                      a.asyncFactory === b.asyncFactory &&
                      isUndef(b.asyncFactory.error)
                  )
              )
          )
      }

      // 对新旧vnode进行diff，然后将比对出的结果用来更新真实的DOM
      function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
          ...
          while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
              if (isUndef(oldStartVnode)) {
                  ...
              } else if (isUndef(oldEndVnode)) {
                  ...
              } else if (sameVnode(oldStartVnode, newStartVnode)) {
                  ...
              } else if (sameVnode(oldEndVnode, newEndVnode)) {
                  ...
              } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
                  ...
              } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
                  ...
              } else {
                  if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
                  idxInOld = isDef(newStartVnode.key)
                      ? oldKeyToIdx[newStartVnode.key]
                      : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
                  if (isUndef(idxInOld)) { // New element
                      createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
                  } else {
                      vnodeToMove = oldCh[idxInOld]
                      if (sameVnode(vnodeToMove, newStartVnode)) {
                          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
                          oldCh[idxInOld] = undefined
                          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
                      } else {
                          // same key but different element. treat as new element
                          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
                      }
                  }
                  newStartVnode = newCh[++newStartIdx]
              }
          }
          ...
      }
      ```

    - 设置 key 值一定能提高 diff 效率吗？不一定
      - 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。
      - 建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。
      - 总结：简单列表的渲染可以不使用`key`或者用数组的`index`作为`key`（效果等同于不带`key`），这种模式下性能最高，但是并不能准确的更新列表项的状态。一旦你需要保存列表项的状态，那么就需要用使用唯一的`key`用来准确的定位每一个列表项以及复用其自身的状态，而大部分情况下列表组件都有自己的状态。

13. **创建组件**

    - 全局注册
- 局部注册
    - 模块系统
  - 模块系统中局部注册
      - 基础组件的自动化全局注册
    - 引入组件：在 script 的第一行用 import 引入路径；用 component 中写上组件名称，在 template 中引入组件
    - 封装 Vue 组件的过程
      - 建立组建的模板，写好样式，考虑组件基本逻辑
      - 准备好组件的数据输入，即厘清组件逻辑，定义好 props 里的数据、类型
      - 准备好组件的数据输出，即组件逻辑，做好要暴露出来的方法
      - 封装完毕可直接调用
    
15. **Vue Cli 项目中 src 目录每个文件夹和文件的用法**

    - `assets` 文件夹是放静态资源；
    - `components` 是放组件；
    - `router` 是定义路由相关的配置;
    - `app.vue` 是一个应用主组件；
    - `main.js` 是入口文件。

16. **分别简述 computed 和 watch 的使用场景**

    - `computed`计算属性：类似于过滤器，对绑定到视图的数据进行处理，并监听变化进而执行对应的方法

      - 使用场景：当一个属性受多个属性影响的时候

        - eg：购物车商品结算的时候

      - 作用：减少模板中的计算逻辑；**计算属性的结果会被缓存**；依赖固定的数据类型

      - 注意：

        - 计算属性是基于它们的依赖进行缓存的，只有相关的依赖发生改变时才会重新求值。只要相关的依赖未改变，只会返回之前的结果，不会执行函数。

        - computed 依赖监控自己定义的变量，不能计算已经在 data 里面定义过的值，该变量在 computed 里面定义，然后可以在页面上进行数据绑定

        - 比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化

      ```javascript
      <template>
          <div>
              <label>姓：<input type="text" placeholder="请输入姓氏" v-model="firstName"></label><br/>
              <label>名：<input type="text" placeholder="请输入名字" v-model="lastName"></label>
              // 可以直接绑定计算属性
              <label>姓 名：<input type="text" placeholder="请输入姓名" v-model="fullName"></label>
          </div>
      </template>

      <script>
          export default {
              name: "ComputedAndWatch",
              data(){
                  return {
                      firstName:'',
                      lastName:'',
                  }
              },
              computed:{
                  fullName:{
                      get(){
                          return this.firstName + '·' + this.lastName
                      },
                      // 实现双向绑定
                      set(value){
                        console.log(`${value}`);        // 测试：使用字符串拼接只能使用“ ` ”
                        let names = value.split('·');
                        this.firstName = names[0];
                        this.lastName = names[1];
                      }
                  }
              }
          }
      </script>
      ```

    - `watch` 侦听属性：是一个侦听的动作，用来观察和响应 Vue 实例上的数据变动

      - 使用场景：当一条数据影响多条数据的时候
        - eg：搜索数据
      - 作用：
        - 监控 vue 实例的变化，监控的变量必须在 data 里面声明才可以
        - 监控一个变量或者一个对象，但是只能监控整个对象或单个变量
        - 依赖于固定的数据类型
      - watch 选项允许我们执行异步操作 ，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的

      - 注意：通过 vm 对象的\$watch()或 watch 配置来监视指定的属性，当属性变化时，回调函数自动调用，在函数内部进行计算。watch 不能双向的绑定值

      ```JavaScript
      <div id="watch-example">
        <p>
          Ask a yes/no question:
          <input v-model="question">
        </p>
        <p>{{ answer }}</p>
      </div>
      <script>
      var watchExampleVM = new Vue({
        el: '#watch-example',
        data: {
          question: '',
          answer: 'I cannot give you an answer until you ask a question!'
        },
        watch: {
          // 如果 `question` 发生改变，这个函数就会运行
          question: function (newQuestion, oldQuestion) {
            this.answer = 'Waiting for you to stop typing...'
            this.debouncedGetAnswer()
          }
        },
        created: function () {
          // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。
          // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率
          // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于
          // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，
          // 请参考：https://lodash.com/docs#debounce
          this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
        },
        methods: {
          getAnswer: function () {
            if (this.question.indexOf('?') === -1) {
              this.answer = 'Questions usually contain a question mark. ;-)'
              return
            }
            this.answer = 'Thinking...'
            var vm = this
            axios.get('https://yesno.wtf/api')
              .then(function (response) {
                vm.answer = _.capitalize(response.data.answer)
              })
              .catch(function (error) {
                vm.answer = 'Error! Could not reach the API. ' + error
              })
          }
        }
      })
      </script>
      ```

      - 区别
        - 相同：`computed`和`watch`都起到监听/依赖一个数据，并进行处理的作用
        - 不同：computed 主要用于对同步数据的处理，watch 则主要用于观测某个值的变化去完成一段开销较大的复杂业务逻辑。
          - 能用 computed 的时候优先用 computed，避免了多个数据影响其中某个数据时多次调用 watch 的尴尬情况。

17. **\$nextTick 的使用**

    - vm.\$nextTick([callback])
    - 当你修改了`data` 的值然后马上获取这个 `dom` 元素的值，是不能获取到更新后的值，`$nextTick`将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 `Vue.nextTick` 一样，不同的是回调的 `this` 自动绑定到调用它的实例上

18. **渐进式框架的理解**

    - 渐进式代表的含义：没有多做职责之外的事；把框架分层
      - 视图层渲染 -> 组建机制 -> 路由机制 -> 状态管理 -> 构建工具
    - 主张最少，可以根据不同的需求选择不同的层级
    - Vue.js 只提供了 vue-cli 生态中最核心的**组件系统** 和 **双向数据绑定（也叫数据驱动）**

19. **`Vue` 的两个核心点**

    - **数据驱动（双向数据绑定）**：MVVM，保证数据和视图的一致性
    - **组件系统**：应用类 UI 可以看作全部是由组件树构成的。组件化开发可以很好地降低数据之间的耦合度。将常用的代码封装成组件之后，就能高度的复用，提高代码的可重用性。一个页面/模块可以由多个组件所组成。

20. **单页面应用和多页面应用区别及优缺点**

    - 单页面应用：只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于 pc 端。
      - 优点：用户体验好，快，内容的改变不需要重新加载整个页面，对服务器压力较小，前后端分离，页面效果会比较炫酷
      - 缺点：不利于 SEO；导航不可用，如果一定要导航需要自行实现前进、后退（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多
    - 多页面应用：一个应用中有多个页面，页面跳转时是整页刷新

21. **v-if 和 v-for 的优先级**

    - 当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中。
    - 不推荐 `v-if` 和 `v-for` 同时使用。
    - 如果 `v-if` 和 `v-for` 一起用的话，vue 中会自动提示 `v-if` 应该放到外层去。

22. **assets 和 static 的区别**

    - 相同点：`assets` 和 `static` 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下。
    - 区别：
      - `assets` 中存放的静态资源文件在项目打包时，也就是运行 `npm run build` 时会将 `assets` 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 `static` 文件中跟着 `index.html` 一同上传至服务器。
      - `static` 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 `static` 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 `assets` 中打包后的文件提交较大点。在服务器中就会占据更大的空间
    - 建议：将项目中 `template`需要的样式文件 js 文件等都可以放置在 `assets` 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如`iconfoont.css` 等文件可以放置在 `static` 中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传

23. **Vue 和 jQuery 的区别**

    - jQuery 是使用选择器（ `$` ）选取 DOM 对象，对其进行赋值、取值、事件绑定等操作，其实和原生的 HTML 的区别只在于可以更方便的选取和操作 DOM 对象，而数据和界面是在一起的。比如需要获取 label 标签的内容：`$("lable").val();` ,它还是依赖 DOM 元素的值。
    - Vue 则是通过 Vue 对象将数据和 View 完全分离开来了。对数据进行操作不再需要引用相应的 DOM 对象，可以说数据和 View 是分离的，他们通过 Vue 对象这个 vm 实现相互的绑定。这就是传说中的 MVVM。

23. **SPA首屏加载慢如何解决**

    - 安装动态懒加载所需插件；使用CDN资源；UI组件库按需加载；路由懒加载；开启`gzip`压缩，生成压缩文件。（视具体情况而定）

24. **`delete`、splice和`Vue.delete`删除数组的区别**

    - `delete` 只是被删除的元素变成了 `empty/undefined` 其他的元素的键值还是不变。

    - splice直接删除了数组，改变了数组的键值

    - `Vue.delete` 直接删除了数组 改变了数组的键值

      - 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。

      ```javascript
      var a=[1,2,3,4]
      var b=[1,2,3,4]
      delete a[1] // a: [1, empty, 3, 4]
      b.splice(1,1) // b: [1, 3, 4]
      var c=[1,2,3,4]
      // Vue.delete( target, propertyName/index )
      this.$delete(c,1) // c: [1, 3, 4]
      ```

25. `Vue slot`

27. **`vue`初始化页面闪动问题**

28. **`Vue`更新数组时触发视图更新的方法**

29. **MVC 与 MVVM**

# Vue Router

1. **`Vue-router`路由管理器**

   - 功能：

     - 嵌套的路由/视图表；
     - 模块化的、基于组件的路由配置；
     - 路由参数、查询、通配符；
     - 基于 Vue.js 过渡系统的视图过渡效果；
     - 细粒度的导航控制；
     - 带有自动激活的 CSS class 的链接；
     - HTML5 历史模式或 hash 模式，在 IE9 中自动降级；
     - 自定义的滚动条行为

   - ```html
     <script src="https://unpkg.com/vue/dist/vue.js"></script>
     <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>

     <div id="app">
       <h1>Hello App!</h1>
       <p>
         <!-- 使用 router-link 组件来导航. -->
         <!-- 通过传入 `to` 属性指定链接. -->
         <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->
         <router-link to="/foo">Go to Foo</router-link>
         <router-link to="/bar">Go to Bar</router-link>
       </p>
       <!-- 路由出口 -->
       <!-- 路由匹配到的组件将渲染在这里 -->
       <router-view></router-view>
     </div>
     ```

     ```javascript
     // 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)
     // 1. 定义 (路由) 组件。
     // 可以从其他文件 import 进来
     const Foo = { template: "<div>foo</div>" };
     const Bar = { template: "<div>bar</div>" };
     // 路由懒加载
     const Tmp = () => import("./Tmp.vue");

     // 2. 定义路由
     // 每个路由应该映射一个组件。 其中"component" 可以是通过 Vue.extend() 创建的组件构造器，
     // 或者，只是一个组件配置对象。
     const routes = [
       { path: "/foo", component: Foo },
       { path: "/bar", component: Bar },
       { path: "/tmp", component: Tmp },
     ];

     // 3. 创建 router 实例，然后传 `routes` 配置
     // 还可以传别的配置参数
     const router = new VueRouter({
       routes, // (缩写) 相当于 routes: routes
     });

     // 4. 创建和挂载根实例。
     // 记得要通过 router 配置参数注入路由，从而让整个应用都有路由功能
     const app = new Vue({
       router,
     }).$mount("#app");

     // 通过注入路由器，可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由
     // Home.vue
     export default {
       computed: {
         username() {
           return this.$route.params.username;
         },
       },
       methods: {
         goBack() {
           window.history.length > 1
             ? this.$router.go(-1)
             : this.$router.push("/");
         },
       },
     };
     ```

2. **路由对象属性**

   - `$route.path`：对应当前路由的路径，总是解析为绝对路径（string）

   - `$route.params`：一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象
   - `$route.query`：一个 key/value 对象，表示 URL 查询参数。如果没有查询参数，则是个空对象
     - 例如，对于路径 `/foo?user=1`，则有 `$route.query.user == 1`
   - `$route.hash`：当前路由的 hash 值 (带 `#`) ，如果没有 hash 值，则为空字符串
   - `$route.fullPath`：完成解析后的 URL，包含查询参数和 hash 的完整路径（string）
   - `$route.matched`：`Array<RouteRecord>`，包含当前路由的所有嵌套路径片段的**路由记录** 。路由记录就是 `routes` 配置数组中的对象副本 (还有在 `children` 数组)
   - `$route.name`：当前路由的名称，如果有的话
   - `$route.redirectedFrom`：如果存在重定向，即为重定向来源的路由的名字
   - **`params`和 `query` 的区别**
     - `$route.query`：(如果 URL 中有查询参数)
   
3. **`Vue-Router`动态路由匹配**

   - 当需要把某种模式匹配到的所有路由，全都映射到同个组件时，就可以在`vue-router` 的路由路径中使用“动态路径参数”(dynamic segment)

     ```javascript
     // eg：有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染
     const User = {
       // 当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用
       // 设置多段"路径参数"，就存储多段
       template:
         "<div>User: {{ $route.params.username }} - id: {{$route.params.id}}</div>",
     };
     const router = new VueRouter({
       routes: [
         // 动态路径参数 以冒号开头
         { path: "/user/:username/post/:id", component: User },
       ],
     });
     ```

   - 响应路由参数的变化

     - 当使用路由参数时，原来的组件实例会被复用。这也意味着组件的生命周期钩子不会再被调用

     - ```javascript
       const User = {
         template: '...',
         // 复用组件时，想对路由参数的变化作出响应，可简单地 watch (监测变化) $route 对象
         watch: {
           $route(to, from) {
             // 对路由变化作出响应...
           }
         }
         // 或者使用导航守卫
         beforeRouteUpdate (to, from, next) {
           // ...
         }
       }
       ```

   - 捕获所有路由或 404 Not Found 路由

     - 匹配任意路径：`*`；含有*通配符*的路由应该放在最后。当使用一个通配符，`$route.params`内会自动添加一个名为`pathMatch`参数。它包含了 URL 通过*通配符*被匹配的部分

       ```javascript
       // 给出一个路由 { path: '/user-*' }
       this.$router.push('/user-admin')
       this.$route.params.pathMatch // 'admin'
       // 给出一个路由 { path: '*' }
       this.$router.push('/non-existing')
       this.$route.params.pathMatch // '/non-existing'
       ```

   - 匹配优先级：按照路由的定义顺序：谁先定义的，谁的优先级就最高

4. **嵌套路由**

   ```javascript
   const User = {
     template: `
       <div class="user">
         <h2>User {{ $route.params.id }}</h2>
         <router-view></router-view>
       </div>
     `,
   };
   
   const router = new VueRouter({
     routes: [
       {
         path: "/user/:id",
         name: "user", // 命名路由
         component: User,
         children: [
           {
             // 当 /user/:id/profile 匹配成功，UserProfile 会被渲染在 User 的 <router-view> 中
             path: "profile",
             component: UserProfile,
           },
           {
             // 当 /user/:id/posts 匹配成功，UserPosts 会被渲染在 User 的 <router-view> 中
             path: "posts",
             component: UserPosts,
           },
         ],
       },
     ],
   });
   ```

   - 嵌套路由的 children 里可以继续嵌套路由

5. **编程式的导航**

   - `router.push(location, onComplete?, onAbort?)`

     - | 声明式                    | 编程式             |
       | ------------------------- | ------------------ |
       | `<router-link :to="...">` | `router.push(...)` |

     - 在`Vue`实例内部，可以通过 \$router 访问路由实例。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL

       ```javascript
       // 字符串
       router.push('home')
       // 对象
       router.push({ path: 'home' })
       // 命名的路由
       router.push({ name: 'user', params: { userId: '123' }})
       // 带查询参数，变成 /register?plan=private
       router.push({ path: 'register', query: { plan: 'private' }})
       // 若提供了path，则 params 会被忽略 (query不属于这种情况)
       router.push({ path: '/user', params: { userId }}) // -> /user
       ```

   - `router.replace(location, onComplete?, onAbort?)`

     - | 声明式                            | 编程式                |
       | --------------------------------- | --------------------- |
       | `<router-link :to="..." replace>` | `router.replace(...)` |

     - 与`router.push`很像，但不会向history添加新纪录

   - `router.go(n)`：在 history 记录中向前或者后退多少步，类似 `window.history.go(n)`

   - **`Vue-router` 跳转和 `location.href` 的区别**

     - 使用 `location.href= /url `来跳转，简单方便，但是刷新了页面；使用 `history.pushState( /url )` ，无刷新页面，静态跳转
     - 引进 router ，然后使用 `router.push( /url )` 来跳转，使用了 `diff` 算法，实现了按需加载，减少了 `DOM` 的消耗
     - 使用 router 跳转和使用 `history.pushState()` 没什么差别，因为`Vue-router`就是用了 `history.pushState()` ，尤其是在history模式下

6. **命名视图**

   - 用于同级展示多个视图，而不是嵌套展示

     ```javascript
     <router-view class="view one"></router-view>
     <router-view class="view two" name="a"></router-view>
     <router-view class="view three" name="b"></router-view>
     
     const router = new VueRouter({
       routes: [
         {
           path: '/',
           components: {
             default: Foo,
             a: Bar,
             b: Baz
           }
         }
       ]
     })
     ```

     - 某些复杂布局可使用嵌套命名视图

7. **重定向和别名**

   - 重定向：当用户访问 `/a`时，URL 将会被替换成 `/b`，然后匹配路由为 `/b`

     ```javascript
     const router = new VueRouter({
       routes: [
         // 从 /a 重定向到 /b
         {path: '/a', redirect: '/b'},
         // 重定向的目标也可以是一个命名的路由
         {path: '/a', redirect: {name: 'foo'}},
         // 甚至是一个方法，动态返回重定向目标
         {path: '/a', redirect: tp => {
           // 方法接收 目标路由 作为参数
           // return 重定向的 字符串路径/路径对象
         }}
       ]
     })
     ```

   - 别名：`/a` 的别名是 `/b`，意味着，当用户访问 `/b` 时，URL 会保持为 `/b`，但是路由匹配则为 `/a`，就像用户访问 `/a` 一样

     ```javascript
     const router = new VueRouter({
       routes: [
         { path: '/a', component: A, alias: '/b' }
       ]
     })
     ```

8. **路由组件传参**

   - 在组件中使用`$route`会使之与其对应路径形成高度耦合，从而使组件只能在某些特定的URL上使用，限制了其灵活性，可以使用props将组件和路由解耦

     ```javascript
     const User = {
       props: ['id'],
       template: '<div>User {{ id }}</div>'
     }
     const router = new VueRouter({
       routes: [
         { path: '/user/:id', component: User, props: true },
     
         // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：
         {
           path: '/user/:id',
           components: { default: User, sidebar: Sidebar },
           props: { default: true, sidebar: false }
         }
       ]
     })
     
     // 对象模式
     // 如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用
     const router = new VueRouter({
       routes: [
         { 
           path: '/promotion/from-newsletter', 
           component: Promotion, 
           props: { newsletterPopup: false } }
       ]
     })
     
     // 函数模式
     const router = new VueRouter({
       routes: [
         { 
           path: '/search', 
           component: SearchUser, 
           props: (route) => ({ query: route.query.q }) }
       ]
     })
     ```

9. **路由对象属性**

   - `$route.path`：对应当前路由的路径，总是解析为绝对路径（string）

   - `$route.params`：一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象
   - `$route.query`：一个 key/value 对象，表示 URL 查询参数。如果没有查询参数，则是个空对象
     - 例如，对于路径 `/foo?user=1`，则有 `$route.query.user == 1`
   - `$route.hash`：当前路由的 hash 值 (带 `#`) ，如果没有 hash 值，则为空字符串
   - `$route.fullPath`：完成解析后的 URL，包含查询参数和 hash 的完整路径（string）
   - `$route.matched`：`Array<RouteRecord>`，包含当前路由的所有嵌套路径片段的**路由记录** 。路由记录就是 `routes` 配置数组中的对象副本 (还有在 `children` 数组)
   - `$route.name`：当前路由的名称，如果有的话
   - `$route.redirectedFrom`：如果存在重定向，即为重定向来源的路由的名字
   - **`params`和 `query` 的区别**
     - `$route.query`：(如果 URL 中有查询参数)

10. **`Vue-Router`的两种模式**

11. **`Vue-Router`实现路由懒加载**

12. **$route 和 $router 的区别**

13. router-link在电脑上有用，在安卓上没反应怎么解决**

    - `Vue`路由在Android机上有问题，babel问题，安装babel polypill插件解决

14. **Vue2中注册在router-link上事件无效解决方法**

    - 使用 `@click.native` 。原因：router-link会阻止click事件，.native指直接监听一个原生事件。

15. **`RouterLink`在IE和Firefox中不起作用（路由不跳转）的问题**

    - 方法一：只用a标签，不适用button标签；
    - 方法二：使用button标签和`Router.navigate`方法

16. **`Vue-Router`有哪几种导航钩子**

# Vuex

# axios

1. **axios**

   - 一个基于 promise 的 HTTP 库，用来请求后台资源的模块

   - 特点

     - 从浏览器中创建 XMLHttpRequests
     - node.js 创建 http 请求
     - 支持 Promise API
     - 拦截请求和响应
     - 转换请求数据和响应数据
     - 取消请求
     - 自动换成 json
     - 客户端支持防御 XSRF

   - axios 中的发送字段的参数是 data 跟 params 两个，两者的区别在于 params 是跟请求地址一起发送的，data 的作为一个请求体进行发送，因此 params 一般适用于 get 请求，data 一般适用于 post、put 请求

   - 安装：`npm install axios —save`

   - 使用： js 中`import` 进来，然后 `.get` 或 `.post` 。如果成功，返回在 `.then` 函数中，失败则是在 `.catch` 函数中

     ```javascript
     // 为给定 ID 的 user 创建请求
     axios.get('/user?ID=12345')
       .then(function (response) {
         console.log(response);
       })
       .catch(function (error) {
         console.log(error);
       });
     
     // 上面的请求也可以这样做
     axios.get('/user', {
         params: {
           ID: 12345
         }
       })
       .then(function (response) {
         console.log(response);
       })
       .catch(function (error) {
         console.log(error);
       });
     
     // 执行POST请求
     axios.post('/user', {
         firstName: 'Fred',
         lastName: 'Flintstone'
       })
       .then(function (response) {
         console.log(response);
       })
       .catch(function (error) {
         console.log(error);
       });
     
     // 执行多个并发请求
     function getUserAccount() {
       return axios.get('/user/12345');
     }
     
     function getUserPermissions() {
       return axios.get('/user/12345/permissions');
     }
     
     axios.all([getUserAccount(), getUserPermissions()])
       .then(axios.spread(function (acct, perms) {
         // 两个请求现在都执行完成
       }));
     ```

2. **`axios API` **

   - axios(config)：可以通过向 `axios` 传递相关配置来创建请求

     ```javascript
     // 发送 POST 请求
     axios({
       method: "post",
       url: "/user/12345",
       data: {
         firstName: "Fred",
         lastName: "Flintstone",
       },
     });
     
     // 获取远端图片
     axios({
       method: "get",
       url: "http://bit.ly/2mTM3nY",
       responseType: "stream",
     }).then(function (response) {
       response.data.pipe(fs.createWriteStream("ada_lovelace.jpg"));
     });
     ```

   - axios(url[, config])

     ```javascript
     // 发送 GET 请求（默认的方法）
     axios("/user/12345");
     ```

   - 请求方法的别名

     - axios.request(config)
     - axios.get(url[, config])
     - axios.delete(url[, config])
     - axios.head(url[, config])
     - axios.options(url[, config])
     - axios.post(url[, data[,config]])
     - axios.put(url[, data[,config]])
     - axios.patch(url[, data[,config]])

   - 处理并发请求的助手函数

     - **axios.all(iterable)**：同时发起多个请求 

     - **axios.spread(callback)** 

       ```javascript
       function getUser() {
         return axios.get("/user/1234");
       }
       
       function getUserPermissions() {
         return axios.get("/user/1234/permissions");
       }
       
       axios
         .all([getUser(), getUserPermissions()]) // 返回一个数组[res1, res2]
         .then(
           // spread 将数组[res1, res2]展开为 res1, res2
           axios.spread(function (userResp, permResp) {
             // 只有上面的请求全部成功后才能执行此回调函数
             console.log("UserInfo", userResp);
             console.log("permissionInfo", permResp);
           })
         )
         .catch(function (error) {
           // 只要有一个请求失败，都会失败
           console.log(error);
         });
       ```

   - 创建实例：**axios.create([config])**

     ```javascript
     const instance = axios.create({
       baseURL: "https://some-domain.com/api/",
       timeout: 1000,
       headers: { "X-Custom-Header": "foobar" },
     });
     ```

   - 实例方法

     - axios#request(config)
     - axios#get(url[, config])
     - axios#delete(url[, config])
     - axios#head(url[, config])
     - axios#options(url[, config])
     - axios#post(url[, data[, config]])
     - axios#put(url[, data[, config]])
     - axios#patch(url[, data[, config]])

3. **请求配置**

   ```javascript
   {
      // 用于请求的服务器 URL
     url: '/user',
   
     // 创建请求时使用的方法
     method: 'get', // default
   
     // 将自动加在 url 前面，除非 url 是一个绝对 URL。
     // 它可以通过设置一个 baseURL 便于为 axios 实例的方法传递相对 URL
     baseURL: 'https://some-domain.com/api/',
   
     // 允许在向服务器发送前，修改请求数据
     // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法
     // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream
     transformRequest: [function (data, headers) {
       // 对 data 进行任意转换处理
       return data;
     }],
   
     // 在传递给 then/catch 前，允许修改响应数据
     transformResponse: [function (data) {
       // 对 data 进行任意转换处理
       return data;
     }],
   
     // 即将被发送的自定义请求头
     headers: {'X-Requested-With': 'XMLHttpRequest'},
   
     // 即将与请求一起发送的 URL 参数
     // 必须是一个无格式对象(plain object)或 URLSearchParams 对象
     params: {
       ID: 12345
     },
   
      // 一个负责 params 序列化的函数
     // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
     paramsSerializer: function(params) {
       return Qs.stringify(params, {arrayFormat: 'brackets'})
     },
   
     // 作为请求主体被发送的数据
     // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'
     // 在没有设置 `transformRequest` 时，必须是以下类型之一：
     // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
     // - 浏览器专属：FormData, File, Blob
     // - Node 专属： Stream
     data: {
       firstName: 'Fred'
     },
   
     // 指定请求超时的毫秒数(0 表示无超时时间)
     // 如果请求话费了超过 `timeout` 的时间，请求将被中断
     timeout: 1000,
   
      // 表示跨域请求时是否需要使用凭证
     withCredentials: false, // default
   
     // 允许自定义处理请求，以使测试更轻松
     // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).
     adapter: function (config) {
       /* ... */
     },
   
    // 表示应该使用 HTTP 基础验证，并提供凭据
     // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头
     auth: {
       username: 'janedoe',
       password: 's00pers3cret'
     },
   
      // 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'
     responseType: 'json', // default
   
     // `responseEncoding` indicates encoding to use for decoding responses
     // Note: Ignored for `responseType` of 'stream' or client-side requests
     responseEncoding: 'utf8', // default
   
      // 用作 xsrf token 的值的cookie的名称
     xsrfCookieName: 'XSRF-TOKEN', // default
   
     // `xsrfHeaderName` is the name of the http header that carries the xsrf token value
     xsrfHeaderName: 'X-XSRF-TOKEN', // default
   
      // 允许为上传处理进度事件
     onUploadProgress: function (progressEvent) {
       // Do whatever you want with the native progress event
     },
   
     // 允许为下载处理进度事件
     onDownloadProgress: function (progressEvent) {
       // 对原生进度事件的处理
     },
   
      // 定义允许的响应内容的最大尺寸
     maxContentLength: 2000,
   
     // 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。
     // 如果 validateStatus 返回 true (或者设置为 null 或 undefined)，promise 将被 resolve; 
     // 否则，promise 将被 rejecte
     validateStatus: function (status) {
       return status >= 200 && status < 300; // default
     },
   
     // 定义在 node.js 中 follow 的最大重定向数目
     // 如果设置为0，将不会 follow 任何重定向
     maxRedirects: 5, // default
   
     // `socketPath` defines a UNIX Socket to be used in node.js.
     // e.g. '/var/run/docker.sock' to send requests to the docker daemon.
     // Only either `socketPath` or `proxy` can be specified.
     // If both are specified, `socketPath` is used.
     socketPath: null, // default
   
     // httpAgent 和 httpsAgent 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：
     // `keepAlive` 默认没有启用
     httpAgent: new http.Agent({ keepAlive: true }),
     httpsAgent: new https.Agent({ keepAlive: true }),
   
     // proxy 定义代理服务器的主机名称和端口
     // auth 表示 HTTP 基础验证应当用于连接代理，并提供凭据
     // 这将会设置一个 Proxy-Authorization 头，覆写掉已有的通过使用 header 设置的自定义 Proxy-Authorization 头。
     proxy: {
       host: '127.0.0.1',
       port: 9000,
       auth: {
         username: 'mikeymike',
         password: 'rapunz3l'
       }
     },
   
     // 指定用于取消请求的 cancel token
     // （查看后面的 Cancellation 这节了解更多）
     cancelToken: new CancelToken(function (cancel) {
     })
   }
   ```

4. **配置默认值**

   - 全局的 axios 默认值

     ```javascript
     axios.defaults.baseURL = "https://api.example.com";
     axios.defaults.headers.common["Authorization"] = AUTH_TOKEN;
     axios.defaults.headers.post["Content-Type"] =
       "application/x-www-form-urlencoded";
     ```

   - 自定义实例默认值

     ```javascript
     // Set config defaults when creating the instance
     const instance = axios.create({
       baseURL: "https://api.example.com",
     });
     
     // Alter defaults after instance has been created
     instance.defaults.headers.common["Authorization"] = AUTH_TOKEN;
     ```

   - 配置的优先顺序（后者将优先于前者）

     - 在 `lib/defaults.js` 找到的库的默认值
     - 实例的 `defaults` 属性
     - 请求的 `config` 参数

     ```javascript
     // 使用由库提供的配置的默认值来创建实例
     // 此时超时配置的默认值是 `0`
     var instance = axios.create();
     
     // 覆写库的超时默认值
     // 现在，在超时前，所有请求都会等待 2.5 秒
     instance.defaults.timeout = 2500;
     
     // 为已知需要花费很长时间的请求覆写超时设置
     instance.get("/longRequest", {
       timeout: 5000,
     });
     ```

5. **拦截器**

   - 在请求或响应被 `then` 或 `catch` 处理前拦截它们

     ```javascript
     // 添加请求拦截器
     axios.interceptors.request.use(
       function (config) {
         // 在发送请求之前做些什么
         return config;
       },
       function (error) {
         // 对请求错误做些什么
         return Promise.reject(error);
       }
     );
     
     // 添加响应拦截器
     axios.interceptors.response.use(
       function (response) {
         // 对响应数据做点什么
         return response;
       },
       function (error) {
         // 对响应错误做点什么
         return Promise.reject(error);
       }
     );
     
     // 若想在稍后移除拦截器
     const myInterceptor = axios.interceptors.request.use(function () {
       /*...*/
     });
     axios.interceptors.request.eject(myInterceptor);
     
     // 为自定义axios实例添加拦截器
     const instance = axios.create();
     instance.interceptors.request.use(function () {
       /*...*/
     });
     ```

6. **错误处理**

   ```javascript
   axios.get('/user/12345')
     .catch(function (error) {
       if (error.response) {
         // The request was made and the server responded with a status code
         // that falls out of the range of 2xx
         console.log(error.response.data);
         console.log(error.response.status);
         console.log(error.response.headers);
       } else if (error.request) {
         // The request was made but no response was received
         // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
         // http.ClientRequest in node.js
         console.log(error.request);
       } else {
         // Something happened in setting up the request that triggered an Error
         console.log('Error', error.message);
       }
       console.log(error.config);
     });
   ```

7. **取消**

   - 使用 *cancel token* 取消请求

   - 使用 `CancelToken.source` 工厂方法创建 cancel token

     ```javascript
     const CancelToken = axios.CancelToken;
     const source = CancelToken.source();
     
     axios.get('/user/12345', {
       cancelToken: source.token
     }).catch(function(thrown) {
       if (axios.isCancel(thrown)) {
         console.log('Request canceled', thrown.message);
       } else {
          // 处理错误
       }
     });
     
     axios.post('/user/12345', {
       name: 'new name'
     }, {
       cancelToken: source.token
     })
     
     // 取消请求（message 参数是可选的）
     source.cancel('Operation canceled by the user.');
     ```

   - 通过传递一个 executor 函数到 `CancelToken` 的构造函数来创建 cancel token

     ```javascript
     const CancelToken = axios.CancelToken;
     let cancel;
     
     axios.get('/user/12345', {
       cancelToken: new CancelToken(function executor(c) {
         // executor 函数接收一个 cancel 函数作为参数
         cancel = c;
       })
     });
     
     // cancel the request
     cancel();
     ```

     - 注：可以使用同一个 cancel token 取消多个请求

# webpack

# 设计模式

1. **工厂模式**

2. **单例模式**

   - 单例模式思想在于保证一个特定类仅有一个实例，意味着当你第二次使用同一个类创建信对象时，应得到和第一次创建对象完全相同

   - 特点
     - 可以来划分命名空间，从而清除全局变量所带来的风险
     - 可以把代码组织的更为一体，便于阅读和维护
     - 可以被实例化，且实例化一次

   ```javascript
   var Singleton = function (name) {
     this.name = name;
   };

   Singleton.prototype.getName = function () {
     return this.name;
   };

   // 获取实例对象
   var getInstance = (function () {
     var instance = null;
     return function (name) {
       if (!instance) {
         instance = new Singleton(name);
       }
       return instance;
     };
   })();

   var a = getInstance("aa");
   var b = getInstance("bb");
   console.log(b.getName()); // "aa"
   console.log(a === b); // true
   ```

   - 应用示例：实现一个遮罩层，来防止用户中断页面操作

   ```javascript
   var createMask = function () {
     var div = document.createElement("div");
     div.innerHTML = "遮罩层";
     div.style.display = "none";
     document.body.appendChild(div);
     return div;
   };

   // 创建iframe
   var createIframe = function () {
     var iframe = document.createElement("iframe");
     document.body.appendChild(iframe);
     return iframe;
   };

   // 获取示例的封装代码
   var getInstance = function (fn) {
     var result;
     return function () {
       return result || (result = fn.call(this, arguments));
     };
   };

   // 测试创建遮罩层
   var createSingleMask = getInstance(createMask);
   document.querySelector("body").onclick = function () {
     var win = createSingleMask();
     win.style.display = "block";
   };

   // 测试创建iframe
   var createSingleIframe = getInstance(createIframe);
   document.querySelector("body").onclick = function () {
     var win = createSingleIframe();
     win.src = "https://www.example.com/";
   };
   ```

3. **模块模式**

   - 模块模式是为单例创建私有变量和特权方法，并减少全局变量的使用

   ```javascript
   var singleMode = (function(){
     // 创建私有变量
     var privateNum = 112;
     // 创建私有方法
     function privateFunc(){},
     // 创建公有方法
     function publicMethod1(){},
     function publicMethod2(){},
     // 返回一个对象包含公有方法和属性
     return {
         publicMethod1: publicMethod1,
         publicMethod2: publicMethod2
     };
   })();
   ```

   - 以下代码援引自小黄书

   ```javascript
   function CoolModule() {
     // 私有变量
     var something = "cool";
     var another = [1, 2, 3];

     function doSomething() {
       console.log(something);
     }

     function doAnother() {
       console.log(another.join(" ! "));
     }

     // 返回一个对象包含公有(特权)方法和属性
     return {
       doSomething: doSomething,
       doAnother: doAnother,
     };
   }

   var foo = CoolModule();

   foo.doSomething(); // cool
   foo.doAnother(); // 1!2!3
   ```

   - 模块模式需要具备两个必要条件

     - 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)

     - 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

     - 总结模块模式的两个特点就是：调用包装了函数定义的包装函数，并且将返回值作为该模块的 API

       - 可以给将要作为公共 API 返回的对象命名，于是可以在内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值

   - 使用场景：创建一个对象时，需要进行内部初始化，同时对内部属性跟方法有访问权限限制，就需要使用模块模式了

4. **代理模式**

5. **发布-订阅模式(观察者模式)**

6. **适配器模式**

7. **策略模式**

8. **职责链模式**

# 数据结构与算法

1. **排序对比**

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df75dc1d1a1c?imageView2/0/w/1280/h/960/ignore-error/1)
   **图片名词解释**： n: 数据规模 k:“桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存

2. **排序分类**

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df7d50eb7521?imageView2/0/w/1280/h/960/ignore-error/1)

3. **冒泡排序**：两层循环嵌套，相邻记录两两对比

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df8e57f21157?imageslim)

   ```javascript
   function bubbleSort(arr) {
     var len = arr.length;
     for (var i = 0; i < len; i++) {
       for (var j = 0; j < len - 1 - i; j++) {
         //相邻元素两两对比
         if (arr[j] > arr[j + 1]) {
           //通过解构完成元素交换
           [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
         }
       }
     }
     return arr;
   }
   ```

4. **选择排序**：遍历自身以后的元素，最小/大元素跟自己调换位置

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df986135a5f6?imageslim)

   ```javascript
   function selectSort(arr) {
     var len = arr.length;
     for (let i = 0; i < len - 1; i++) {
       for (let j = i; j < len; j++) {
         if (arr[i] > arr[j]) {
           [arr[i], arr[j]] = [arr[j], arr[i]];
         }
       }
     }
     return arr;
   }
   ```

5. **插入排序**：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df9f6afc4b04?imageslim)

   ```javascript
   function insertSort(arr) {
     //外循环从1开始，默认arr[0]是有序段
     for (let i = 1; i < arr.length; i++) {
       // j = i,将arr[j]依次插入有序段中
       for (let j = i; j > 0; j--) {
         if (arr[j] < arr[j - 1]) {
           [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
         } else {
           break;
         }
       }
     }
     return arr;
   }
   ```

6. **快速排序**：找到一个数作为参考，比这个数字大的放在数字左边，比它小的放在右边； 然后分别再对左边和右变的序列做相同的操作(递归)。(在冒泡排序基础上的递归分治法。)

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfaa8bbf0e52?imageslim)

   - **注：涉及到递归的算法,一定要记得设置出口,跳出递归!**

   ```javascript
   function quickSort(arr) {
     // 跳出递归
     if (arr.length <= 1) return arr;
     var left = [],
       right = [],
       current = arr[0];
     for (let i = 0; i < arr.length; i++) {
       if (arr[i] < current) {
         left.push(arr[i]); // 小的放在左边
       } else {
         right.push(arr[i]); // 大的放在右边
       }
     }
     return quickSort(left).concat(current, quickSort(right));
   }
   ```

   - 改进版

   ```javascript
   function partition(arr, l, r){
     let pivot = arr[l]'
     while(l < r) {
       while(l < r && a[r] > pivot) {
         --r;
       }
       arr[l] = arr[r];
       while(l < r && arr[l] < pivot) {
         ++l;
       }
       arr[r] = arr[l];
     }
     arr[l] = pivot;
     return l;
   }

   function quickSort(arr) {
     let l = 0, r = arr.length - 1;
     if(l < r) {
       let pivot = partition(arr, l, r);
       quickSort(arr, l, pivot - 1);
       quickSort(arr, pivot + 1, r);
     }
     return arr;
   }
   ```

7. **希尔排序**(缩小增量排序)：是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。

   思路： 希尔排序其实大体思路很简单,就是将数组(长度为 len)分成间隔为 t1 的若干数组.进行插入排序;排完后,将数组再分成间隔为 t2(逐步减小)的若干数组,进行插入排序;然后继续上述操作,直到分成间隔为 1 的数组,再进行最后一次插入排序则完成.

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfc27c806ac3?imageslim)

   ```javascript
   function shellSort(arr) {
     var len = arr.length,
       temp,
       gap = 1;
     while (gap < len / 5) {
       //动态定义间隔序列
       gap = gap * 5 + 1;
     }

     for (gap; gap > 0; gap = Math.floor(gap / 5)) {
       for (var i = gap; i < len; i++) {
         temp = arr[i];
         for (var j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {
           arr[j + gap] = arr[j];
         }

         arr[j + gap] = temp;
       }
     }
     return arr;
   }
   ```

8. **归并排序**：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并

   **思路**：将数组分为左和右两部分,然后继续将左右两部分继续(递归)拆分,直到拆分成单个为止;然后将拆分为最小的两个数组,进行比较,合并排成一个数组.接着继续递归比较合并.直到最后合并为一个数组.

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfd071fc35a5?imageslim)

   **步骤**：

   - 把长度为 n 的输入序列分成两个长度为 n/2 的子序列
   - 对这两个子序列分别采用归并排序
   - 将两个排序好的子序列合并成一个最终的排序序列。

   ```javascript
   function mergeSort(arr) {
     var len = arr.length;
     if (len < 2) {
       return arr;
     }

     var middle = Math.floor(len / 2),
       left = arr.slice(0, middle),
       right = arr.slice(middle);
     return merge(mergeSort(left), mergeSort(right));
   }

   function merge(left, right) {
     var result = [];
     while (left.length && right.length) {
       if (left[0] <= right[0]) {
         result.push(left.shift());
       } else {
         result.push(right.shift());
       }
     }

     while (left.length) {
       result.push(left.shift());
     }

     while (right.length) {
       result.push(right.shift());
     }
     return result;
   }
   ```

9. **堆排序**

10. **计数排序**

11. **桶排序**

12. **基数排序**

13. **二叉树**

    - 节点：二叉树的最小元素是节点，所以先定义一个节点

      ```javascript
      function Node(data, left, right) {
        this.left = left;
        this.right = right;
        this.data = data;
        this.show = () => {
          return this.data;
        };
      }
      ```

    - **重建二叉树**

      ```javascript
      var buildTree = function (preorder, inorder) {
        if (!preorder.length || !inorder.length) return null;

        // 前序遍历的第一个元素为根节点
        const rootVal = preorder[0];
        const node = new TreeNode(rootVal);

        let i = 0;
        // i有两个含义，一个是根节点在中序遍历结果中的下标
        // 另一个是当前左子树的节点个数
        for (; i < inorder.length; ++i) {
          if (inorder[i] === rootVal) {
            break;
          }
        }

        // 递归处理左右子树
        node.left = buildTree(preorder.slice(1, i + 1), inorder.slice(0, i));
        node.right = buildTree(preorder.slice(i + 1), inorder.slice(i + 1));
        return node;
      };
      ```

    - **前序遍历** (根节点->左子树->右子树)

      - 递归

      ```javascript
      function preOrder(node) {
        if (node !== null) {
          //根节点->左子树->右子树
          console.log(node.show());
          preOrder(node.left);
          preOrder(node.right);
        }
      }
      ```

      - 非递归

      ```javascript
      function preTraverse(tree) {
        var arr = [],
          node = null;
        arr.unshift(tree);
        while (arr.length) {
          node = arr.shift();
          console.log(node.val);
          if (node.right) arr.unshift(node.right);
          if (node.left) arr.unshift(node.left);
        }
      }
      ```

    - **中序遍历** (左子树->根节点->右子树)

      中序遍历是以从最小到最大的顺序访 问所有节点。中序遍历的一种应用就是对树进行排序操作。

      - 递归

      ```javascript
      function middleTraverse(node) {
        if (node === null) return;

        middleTraverse(node.left);
        console.log(node.data);
        middleTraverse(node.right);
      }
      ```

      - 非递归

      ```javascript
      // shift() 头删 unshift() 头插
      // 用一个辅助数组来做
      // 当辅助数组不为空 或者根节node不为空
      //   若node不为空
      //     根节点头插进辅助数组
      //     并且node.left赋值给新的node
      //   若node为空
      //     辅助数组头删节点赋值给node
      //     res.push(node)
      //     node.left重新赋值给node
      function middleTraverseUnRecursion(root) {
        let arr = [],
          node = root;
        let res = [];
        while (arr.length !== 0 || node !== null) {
          if (node === null) {
            node = arr.shift();
            // console.log(node.data);
            res.push(node.data);
            node = node.right;
          } else {
            arr.unshift(node);
            node = node.left;
          }
        }
      }
      ```

    - **后序遍历**(左子树->右子树->根节点)

      - 递归

      ```javascript
      function lastTraverse(node) {
        if (node === null) return;
        lastTraverse(node.left);
        lastTraverse(node.right);
        console.log(node.data);
      }
      ```

    - **广度优先-层序遍历**

      - 递归

      ```javascript
      var result = [];
      var stack = [tree];
      var count = 0;
      var bfs = function () {
        var node = stack[count];
        if (node) {
          result.push(node.value);
          if (node.left) stack.push(node.left);
          if (node.right) stack.push(node.right);
          count++;
          bfs();
        }
      };
      ```

      - 非递归

      ```javascript
      function bfs(node) {
        var result = [];
        var queue = [];
        queue.push(node);
        while (queue.length) {
          node = queue.shift();
          result.push(node.value);
          node.left && queue.push(node.left);
          node.right && queue.push(node.right);
        }
        return result;
      }
      ```

    - **反转二叉树**
      ```javascript
      var invertTree = function (root) {
        if (root !== null) {
          [root.left, root.right] = [root.right, root.left];
          invertTree(root.left);
          invertTree(root.right);
        }
        return root;
      };
      ```

14. **二叉搜索树**

    - ![image](https://pic.leetcode-cn.com/0d58ea8f3bef46b93b74cd044a4185c817bf0932b34b024318ddde90681864eb-Binary_search_tree%5B1%5D.svg)

    - 也称为 二叉查找树、有序二叉树（Ordered Binary Tree）或排序二叉树

    - 特性

      - 若任意节点的左子树不为空，则左子树所有节点的值均小于它的根节点的值
      - 若任意节点的右字数不为空，则右子树所有节点的值均大于它的根节点的值
      - 任意节点的左、右子树分别为二叉搜索树
      - 没有键值相等的节点

    - 优点
      - 于查找、插入的时间复杂度较低。为 O(log⁡n)
      - 中序遍历二叉查找树可得到一个关键字的有序序列
      - 搜索、插入、删除的复杂度等于树高，期望 O(log⁡n)，最坏 O(n)

15. **数组去重**
    - 双 for 循环, splice 剔除并 i--回退
    - indexOf 等于 index
    - filter indexOf === index
    - 新数组 indexOf === index
    - 使用空对象等
    - Set去重

# jQuery

1. **jQuery 选择器**

2. **jQuery 使用建议**
   - 尽量减少对 dom 元素的访问和操作
   - 尽量避免给 dom 元素绑定多个相同类型的事件处理函数
     - 可以将多个相同类型事件处理函数合并到一个处理函数，通过数据状态来处理分支
   - 尽量避免使用 toggle 事件

# 参考资料

> 1. https://juejin.im/post/5c64d15d6fb9a049d37f9c20#heading-4
> 2. https://mp.weixin.qq.com/s/-4QzuupsTwr2NcknN590Dg
> 3. https://mp.weixin.qq.com/s/jdDwmPfMOf4qVnwYx0a6ew
> 4. https://juejin.im/post/5e6055e6f265da5762133c89
> 5. http://www.ruanyifeng.com/blog/2017/05/websocket.html
> 6. https://cn.vuejs.org/v2/guide/
> 7. https://github.com/yukkkkkki/Front-end-Interview-questions
> 8. https://www.cnblogs.com/ainyi/p/9777841.html
> 9. https://www.jianshu.com/p/56b7302d7f7f
> 10. https://www.cnblogs.com/binguo666/p/10928907.html
> 11. https://www.cnblogs.com/staven/p/4774263.html
> 12. https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API
> 13. https://zhuanlan.zhihu.com/p/72616216
> 14. https://juejin.im/post/5c6e5803f265da2dc0065437
> 15. https://juejin.im/post/59e4c02151882578d02f4aca
> 16. https://www.cnblogs.com/harsin/p/11418615.html
> 17. https://juejin.im/post/5c72280351882562914edb61#heading-7
> 18. NicholasC.Zakas, 泽卡斯, Zakas, 李松峰, & 曹力. (2010). JavaScript 高级程序设计. 人民邮电出版社.
> 19. https://juejin.im/post/5c6f9d24e51d4511dd3fd0a2#heading-14
> 20. https://zhuanlan.zhihu.com/p/34453198?group_id=957277540147056640
> 21. https://segmentfault.com/a/1190000017184701
> 22. https://juejin.im/post/5c6c9c99f265da2d896326ae#heading-5
> 23. https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-4
> 24. https://juejin.im/post/5d0a48d86fb9a07ea803cf23#heading-0
> 25. https://juejin.im/post/59ac1c4ef265da248e75892b#heading-12
> 26. https://www.itcodemonkey.com/article/2853.html
> 27. https://juejin.im/post/5ce607a7e51d454f6f16eb3d#heading-37
> 28. https://juejin.im/post/5d1d61766fb9a07ed2248aea#heading-5
> 29. https://www.cnblogs.com/Lina-zhu/p/8891616.html
> 30. https://www.cnblogs.com/ljwk/p/7090320.html
> 31. KyleSimpson, 辛普森, 赵望野, & 梁杰. (2015). 你不知道的 JavaScript. 人民邮电出版社.
> 32. https://juejin.im/post/5ec74c6a518825430956ae65#heading-9
> 33. https://juejin.im/post/5e7c94106fb9a009a0575bc5#heading-8
> 34. https://juejin.im/post/5ec74c6a518825430956ae65#heading-14
> 35. https://juejin.im/post/5c071f68e51d451dcd3c3077
> 36. https://juejin.im/post/5c071f2ff265da6115109302
> 37. https://blog.csdn.net/eva_lu/article/details/79633044
> 38. https://www.jianshu.com/p/1b75a3623d0d
> 39. https://juejin.im/entry/59085cd10ce463006180b4fc
> 40. https://zhangguixu.github.io/2016/12/02/jsonp/
> 41. https://juejin.im/post/5cb5c40ff265da03a158210e#heading-2
> 42. http://www.imooc.com/article/281277?block_id=tuijian_wz
> 43. https://juejin.im/post/5c8efeb1e51d45614372addd#heading-38
> 44. https://blog.csdn.net/u014346301/article/details/52689558
> 45. https://blog.csdn.net/Q846169253/article/details/81841919
> 46. https://juejin.im/post/5daebfc2518825502a44602a
> 47. https://juejin.im/post/5eb6f99b5188256d46198cad
> 48. https://zhuanlan.zhihu.com/p/25070186?refer=learncoding
> 49. https://juejin.im/post/5d63a2bbe51d453c2577b7b5
> 50. https://leetcode-cn.com/tag/binary-search-tree/
> 51. https://mp.weixin.qq.com/s/bvYqA16mU_rRYT1G37onug
> 52. https://juejin.im/post/5afa98bf51882542c832e5ec
> 53. https://juejin.im/post/5c6c182ee51d45760b1c8e30#heading-4
> 54. https://mp.weixin.qq.com/s/1RyLXMQEtGAT-al0Ev8Ikg
> 55. https://es6.ruanyifeng.com/#docs/set-map
> 56. https://mp.weixin.qq.com/s/3R8BxWk6JjUxF4OIdWBc_g
> 57. https://juejin.im/post/5bbad07ce51d450e894e4228
> 58. https://juejin.im/post/5ad5b908f265da23870f540d
> 59. http://www.fly63.com/article/detial/225?type=2
> 60. https://juejin.im/post/5e10a97f5188253a765ec7e1
> 61. https://juejin.im/post/5b40581e5188251ac446c716
> 62. https://juejin.im/post/59cf06745188253fbe466f78
> 63. https://juejin.im/post/592045b0570c350069a1d7b5
> 64. https://juejin.im/entry/578444c979bc440050a89fab
> 65. https://juejin.im/post/5cac9d4d5188251b090abcf1
> 66. https://juejin.im/post/5bb1cc2af265da0ae5052496
> 67. https://juejin.im/post/5c6bcdc8e51d45209a1ca3b6
> 68. https://juejin.im/post/59d1f59bf265da06700b0934
> 69. https://juejin.im/post/5ad5b9116fb9a028e014fb19
> 70. https://www.jianshu.com/p/fdcc92914a3e
> 71. https://www.jianshu.com/p/9fbb75a9f87a
> 72. https://blog.csdn.net/qq_41638795/article/details/83304388
> 73. http://www.axios-js.com/zh-cn/docs/index.html
> 74. https://www.cnblogs.com/Sherlock09/p/11023593.html
> 75. https://mp.weixin.qq.com/s/_P0-uCz11hvFIwdLQ1mL-Q
> 76. https://vue-loader-v14.vuejs.org/zh-cn/
> 77. https://juejin.im/post/6844904160396050440
> 78. https://juejin.im/post/6844903956898447367
> 79. https://juejin.im/post/6844903942254510087#heading-4
> 80. https://juejin.im/post/6844903917243858951#heading-6
> 81. https://juejin.im/post/6844903917243858951
