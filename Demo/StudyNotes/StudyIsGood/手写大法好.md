# JS手写实现

1. **sleep函数**

   ```javascript
   function sleep(fn, wait) {
     return new Promise((resolve, reject) => {
       setTimeout(() => {
         resolve(fn);
       }, wait);
     });
   }
   
   let sayHello = (name) => console.log(`hello ${name}`);
   async function autoRun() {
     let demo1 = await sleep(sayHello('demo1'), 1000);
     let demo2 = await sleep(sayHello('demo2'), 1000);
     let demo3 = await sleep(sayHello('demo3'), 1000);
   }
   ```

2. **实现浅拷贝：只拷贝对象或者数组的第一层内容**

   ```javascript
   const shallowCopy = (target) => {
     if (typeof target === 'object' && target !== null) {
       const cloneTarget = Array.isArray(target) ? [] : {};
       for (let prop in target) {
         // for in遍历数组返回下标，for of遍历对象返回key
         // 遍历对象自身可枚举属性（不考虑继承属性和原型对象）
         if (target.hasOwnProperty(prop)) {
           cloneTarget[prop] = target[prop];
         }
       }
       return cloneTarget;
     } else {
       return target;
     }
   };
   ```

3. **递归实现深拷贝：层层拷贝对象或数组的每一层内容**

   ```javascript
   function deepCopy(target) {
     if (target === null) return null;
     if (typeof target !== 'object') return target;
     const cloneTarget = Array.isArray(target) ? [] : {};
     for (let prop in target) {
       if (target.hasOwnProperty(prop)) {
         cloneTarget[prop] = deepCopy(target[prop]);
       }
     }
     return cloneTarget;
   }
   ```

4. **实现instanceOf 的机制**

   ```javascript
   function _instanceof(instanceObject, classFunc) {
     const O = classFunc.prototype; // 取得当前构造函数的原型
     let proto = instanceObject.__prop__; // 取得当前实例对象的原型链
     while (true) {
       if (proto === null) return false; // 找到了 Object的基类 Object.prototype.__proto__
       if (proto === O) return true; // 在当前实例对象的原型链上，找到了当前类
       proto = proto.__proto__; // 沿着原型链__ptoto__一层一层向上查找
     }
   }
   ```

   - 优化版

   ```javascript
   function _instanceof(instanceObject, classFunc) {
     const O = classFunc.prototype;
     let proto = Object.getPrototypeOf(instanceObject); // 取得当前实例对象的原型链上的属性
     while (true) {
       if (proto === null) return false;
       if (proto === O) return true;
       proto = Object.getPrototypeOf(proto); // 沿着原型链__ptoto__一层一层向上查找
     }
   }
   ```

5. **实现函数防抖**

   - 触发事件后在规定时间内回调函数**只能执行一次**，如果在**规定时间内又触发了该事件，则会重新开始算规定时间**

   - 非立即执行版：事件触发 -> 延时 -> 执行回调函数参考链接

     ```javascript
     function debounce(fn, delay) {
       let timer;
       return function() {
         let that = this;
         let _args = arguments;
         if(timer) clearTimeout(timer);
         timer = setTimeout(() => {
           fn.apply(that, _args);
         });
       };
     }
     ```

   - 立即执行版：事件触发 - > 执行回调函数 - > 延时

     ```javascript
     function debounce(fn, delay, immediate = true) {
       let timer;
       return function() {
         let that = this;
         let _args = arguments;
         if(timer) clearTimeout(timer);
         let callNow = immediate && !timer;
         timer = setTimeout(() => { // 在下一个delay之前，令timer = null
           timer = null;
         }, delay);
         if(callNow) fn.apply(that, _args);
       }
     }
     // 测试：
     const fn = debounce(() => {
       console.log("hello");
     }, 1000);
     for (let i = 0; i < 10; i++) {
       fn();
     }
     ```

   - 合并版

     ```javascript
     function debounce(fn, delay, immediate) {
       let timer;
       return function() {
         let that = this;
         let _args = arguments;
         if(timer) clearTimeout(timer);
         if(immediate) {
           let callNow = !timer;
           timer = setTimeout(() => {
             timer = null;
           }, delay);
           if(callNow) fn.apply(that, _args);
         } else {
           timer = setTimeout(() => {
             fn.apply(that, _args);
           }, delay);
         }
       }
     }
     ```

6. **实现函数节流**

   - 在规定时间段内**只能调用一次回调函数**。如果在**规定时间内又触发了该事件，则什么也不做**, 也不会重置定时器

   - 时间戳版：通过闭包保存上一次的时间戳, 然后与事件触发的时间戳比较，如果大于规定时间, 则执行回调,否则就什么都不处理

     ```javascript
     function throttle(fn, delay) {
       let previous = 0;
       return function() {
         let now = Date.now();
         let that = this;
         let _args = arguments;
         if(now - previous > delay) {
           fn.apply(that, _args);
           previous = now;
         }
       }
     }
     ```

   - 定时器版：通过闭包保存上一次定时器状态,然后事件触发时,如果定时器为 null(即代表此时间隔已经大于规定时间)，则设置新的定时器.到时间后执行回调函数,并将定时器置为 null

     ```javascript
     function throttle(fn, delay) {
       let timer;
       return function() {
         let that = this;
         let _args = arguments;
         if(!timer) {
           timer = setTimeout(() => {
             timeout = null;
             fn.apply(that, _args);
           },delay)
         }
       }
     }
     
     // 测试
     const fn = throttle(() => {
       console.log('节流试试');
     }, 1000);
     const fn = function () {
       console.log('节流试试');
     };
     for (let i = 0; i < 100; i++) {
       fn();
     }
     ```

   - 合并版本

     ```javascript
     function throttle(fn, delay, type) {
       if(type === 1) {
         let previous = 0;
       } else if (type === 2) {
         let timer;
       }
       return fn() {
         let that = this;
         let _args = arguments;
         if(type === 1) {
           let now = Date.now();
           if(now - previous > delay) {
             fn.apply(that, _args);
             previous = now;
           }
         } else if (type === 2) {
           if(!timer) {
             timer = setTimeout(() => {
               timer = null;
               fn.apply(that, _args);
             }, wait);
           }
         }
       }
     }
     ```

7. **实现 Object.create**：创建一个新对象，使用现有的对象来提供新创建的对象的\__proto__

   ```javascript
   function _create(prototype) {
     if(prototype === null || typeof prototype !== 'object') {
       throw new TypeError(`Object prototype may only be an Object: ${prototype}`);
     }
     // 让空对象的 __proto__指向 传进来的 对象(prototype)
     // 目标 {}.__proto__ = prototype
     function Temp() {}
     Temp.prototype = prototype;
     return new temp();
   }
   ```

8. **实现内置 new 的原理**

   ```javascript
   function _new(classFunc) {
     let obj = {}; // 创建/构造一个全新的对象
     obj.__proto__ = classFunc.prototype; // 新对象链接到该函数的[[prototype]]原型
     let result = classFunc.call(obj, ...args); // 新对象绑定函数调用的 this
     // 分析函数的返回值
     if(result !== null && /^(object|function)$/.test(typeof result)) {
       return result;
     }
     return obj;
   }
   ```

9. **实现call方法**

10. **实现apply方法**

11. **实现bind方法**

12. **ES5实现数组扁平化flat方法**

    ```javascript
    function myFlat() {
      let that = this;
      let newArr = [];
      const cycleArr = arr => {
        for(let i = 0; i < arr.length; i++) {
          let item = arr[i];
          if(Array.isArray(item)) {
            cycleArr(item);
            continue;
          } else {
            newArr.push(item);
          }
        }
      };
      cycleArr(that);
      return newArr;
    }
    Array.prototype.myFlat = myFlat;
    let arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10];
    arr = arr.myFlat();
    ```

13. **ES6实现数组扁平化flat方法**

    ```javascript
    const myFlat = function(arr) {
      let newArr = [];
      const cycleArr = arr => {
        for(let i = 0; i < arr.length; i++) {
          let item = arr[i];
          if(Array.isArray(item)) {
            cycleArr(item);
            continue;
          } else {
            newArr.push(item);
          }
        }
      }
      cycleArr(arr);
      return newArr;
    }
    console.log(myFlat([1, 2, 3, [4, 5, 6]]));
    ```

14. 使用reduce实现数组扁平化flat方法

> 1. https://juejin.im/post/6870319532955828231#heading-31
> 2. https://www.jianshu.com/p/01184f1a2f7e