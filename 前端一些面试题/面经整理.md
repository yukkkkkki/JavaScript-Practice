# CSS 相关

1. **BFC(Block Formatting Context)块级格式化上下文**
   块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。（盒子里面的子元素的样式不会影响到外面的元素）

   - 规则

     - 属于同一个 BFC 的两个相邻 Box 垂直排列
     - 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠
     - BFC 中子元素的 margin box 的左边，与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)
     - BFC 的区域不会与 float 的元素区域重叠(防止浮动文字环绕)
     - 计算 BFC 的高度时，浮动子元素也参与计算
     - 文字层不会被浮动层覆盖，环绕于周围

   - 触发条件

     - 浮动元素，float 除 none 以外的值
     - 定位元素，position（absolute,fixed）
     - display: inline-block / table-cell/table-caption
     - overflow !== visible （为 hidden/auto/scroll）

   - 应用
     - 阻止 margin 重叠
     - 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div 都位于同一个 BFC 区域之中)
     - 自适应两栏布局
     - 可以阻止元素被浮动元素覆盖

2. **盒模型**

   外边距(margin)、边框(border)、内边距(padding)、内容(content)

   两种模式:

   - 标准模式: box-sizing: content-box(默认); 宽高不包括内边距和边框
   - 怪异模式: box-sizing: border-box

3. **负外边距**

   - margin-left/margin-top 的负外边距会把元素向左/上拉，盖住其旁边的元素

   - margin-right/margin-bottom 的负外边距会把相邻元素向左/上拉，盖住设置了负外边距的元素

   - 在浮动元素上

     - 与浮动方向相反的负外边距会导致浮动区域缩小，使得相邻元素盖住浮动元素
     - 与浮动方向相同的负外边距会在该方向上把浮动元素向外拉

   - 给未声明宽度的非浮动元素应用负外边距时，左右负外边距会向外拉伸元素，导致元素扩张，有可能盖住相邻元素

4. **CSS 选择器**

   - id 选择器(#myid)
   - 类选择器(.myclassname)
   - 标签选择器(div, h1, p)
   - 相邻选择器(h1 + p)
   - 子选择器(ul > li)
   - 后代选择器(li a)
   - 通配符选择器(\*)
   - 属性选择器(a\[rel=”external”])
   - 伪类选择器(a:hover, li:nth-child)
     - a:link：未访问
     - a:visited：访问过
     - a:hover, a:focus：鼠标悬停，获取键盘焦点
     - a:active：活动状态
   - 伪元素选择器(::before, ::after)

     - CSS 伪类用于向某些选择器添加特殊的效果
     - CSS 伪元素用于将特殊的效果添加到某些选择器(不想给页面添加额外的标记)

   - **选择器优先级**：!important > 行内样式 > #id > .class > tag > \* > 继承 > 默认

5. **id 和 class 的区别**

   - class 是设置标签的类，用于指定元素属于何种样式的类。在 CSS 样式中以"."来命名

   - id 是设置标签的标识。用于定义一个元素的独特的样式。在 CSS 样式定义的时候 以"#"来开头命名 id 名称

     - 具有唯一性且优先级高
     - 用于区分不同结构和内容

   - class 可以重复，id 是唯一的(id 属性一般在一个页面中只可以使用一次，而 class 可以被多次引用)

   - 在布局思路上，一般坚持这样的原则：id 是先确定页面的结构和内容，然后再为它定义样式：而 class 相反，它先定义好一类样式，然后再页面中根据需要把类样式应用到不同的元素和内容上面

6. **Flex 弹性布局**

   - flex-direction：控制元素在主副轴排列的方向

     - row：从左到右水平排列元素（默认值）
     - row-reverse: 从右向左排列元素
     - column：从上到下垂直排列元素
     - column-reverse：从下到上垂直排列元素

   - flex-wrap：控制换行(默认不换行)

     - nowrap：不拆行或不拆列
     - wrap：在必要的时候拆行或拆列
     - wrap-reverse：在必要的时候以相反的顺序拆行或拆列

   - flex-flow：是 flex-direction 与 flex-wrap 的组合简写模式

   - justify-content：元素在主轴对齐方式

     - flex-start：紧靠主轴起点
     - flex-end：紧靠主轴终点
     - center：从弹性容器中心开始
     - space-between：第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
     - space-around：每个元素两侧的间隔相等
     - space-evenly：元素间距离平均分配

   - align-items：容器中**所有元素**在交叉轴对齐方式

     - center：位于容器的中心
     - flex-start：位于容器的交叉轴开头
     - flex-end：位于容器的交叉轴结尾
     - stretch：元素被拉伸以适应容器(默认值)

   - align-self：用于控制**单个元素**在交叉轴上的排列方式

   - align-content：只适用于多行显示的弹性容器，作用是当 flex 容器在交叉轴上有多余的空间时，对元素的对齐处理

     - stretch：将空间平均分配给元素
     - flex-start：元素紧靠主轴起点
     - flex-end：元素紧靠主轴终点
     - center：元素从弹性容器中心开始
     - space-between：第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
     - space-around：每个元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍
     - space-evenly：元素间距离平均分配

   - flex-grow：将弹性盒子的剩余可用空间，分配给弹性元素。以使用整数或小数声明

   - flex-shrink：与 flex-grow 相反 flex-shrink 是在弹性盒子装不下元素时定义的缩小值

   - flex-basis：定义了在分配多余空间之前，项目占据的主轴空间(main size)。浏览器根据这个属性，计算主轴是否有多余空间

   - flex：是 flex-grow、flex-shrink 、flex-basis 缩写组合。

7. **定位布局**

   - position:static 默认形为，参考文档流

     - 块级元素垂直堆叠

   - position:relative 相对定位

     - 相对于自己原来的位置移动，当元素发生位置偏移时，原位置留白
     - 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它(不脱离标准流，继续保留原来位置)

   - position:absolute 绝对定位

     - 不受文档流影响，就像漂浮在页面中的精灵，绝对定位元素拥有行内块特性
     - 相对于其最近的定位上下文
       - 如果祖先元素有定位(非静态定位的任意定位)，则**以最近一级的定位祖先元素为参考点**移动位置
       - 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位
     - 绝对定位不再占有原先的位置(脱离标准流)
     - 绝对定位的元素默认会待在自己静态定位时的地方

     - 在绝对定位的情况下

       - 如果没有显式声明元素大小，那么绝对定位元素的大小由自身包含内容的多少来决定。
       - 如果相对于定位上下文的各个边声明偏移值，那么元素会被拉伸以满足设定的规则

     - 应用场景

       - 利用初始位置
       - 创建三角形
       - 利用偏移实现自动大小 > 图片上放置一个半透明盒子，相对于右、下、左绝对定位

   - position:fixed 固定定位

     - 以浏览器的可视窗口为参照点移动元素，固定定位在某个位置
     - 跟父元素没有关系，**不随滚动条滚动**
     - 固定定位不占有原先的位置

   - position:sticky 粘性定位：相对定位和固定定位的混合

     - 以浏览器的可视窗口为参照点移动元素(固定定位特点)
     - 占有原先的位置(相对定位特点)
     - 必须添加 top、left、right、bottom 其中的一个才有效

8. **z-index**

   - 可以控制盒子层叠的次序。属性值越大，盒子在层叠中的次序就越靠近用户的眼睛

     - 谁大谁上；大小一样，后来居上

   - 在一个堆叠上下文内部，无论 z-index 值多大或多小，都不会影响其他堆叠上下文。

   - 堆叠上下文(stacking context)：影响的是元素 CSS 属性中的 z-index，父元素是否是堆叠上下文，对具有 z-index 属性的子元素的堆叠顺序有影响

     层叠上下文由满足以下任意一个条件的元素形成

     - 根元素(HTML)
     - z-index !== auto 的绝对/相对定位
     - position: fixed
     - z-index !== auto 的 flex item
     - opacity < 1
     - transform !== none
     - mix-blend-mode !== normal
     - filter !== none
     - perspective !== none
     - isolation: isolate
     - -webkit-overflow-scrolling: touch

   - z 轴元素堆叠顺序

     - 普通块级元素中：正 z-index > 内联元素 > 浮动元素 > 块级元素 > border > background >负 z-index

     - 堆叠上下文中：正 z-index > 内联元素 > 浮动元素 > 块级元素 > 负 z-index > border > background

9. **网格布局(Grid)**

10. **浮动布局**

    - float：定义元素在哪个方向浮动

      - left 向左浮动
      - right 向右浮动
      - none 不浮动

    - 元素浮动后会变为块元素，可以设置宽高

    - clear：用于清除元素浮动影响

11. **清除浮动**

    浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上

    - 浮动带来的问题：

      - 父元素的高度无法被撑开，影响与父元素同级的元素
      - 与浮动元素同级的非浮动元素（内联元素）会跟随其后
      - 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构

    - 清除浮动的方法：

      - 额外标签法：在父元素内部最后面添加一个没有高度的子元素，并使用 clear:both(不推荐)
      - 使用 ::after 伪元素为父元素添加后标签
      - 使用 before 和 after 双伪元素清除浮动
      - 通过添加父元素并设置 overflow:hidden (触发 BFC)

    - **overflow 原理**：该属性进行超出隐藏时需要计算盒子内所有元素的高度, 所以会隐式清除浮动

12. **元素垂直/居中**

    - 水平居中

      - 行内元素: text-align: center
      - 块级元素：margin: 0 auto
      - absolute + transform
      - flex + justify-content: center

    - 垂直居中

      - line-height: height
      - absolute + transform
      - flex + align-items: center
      - table

      - 行内块的垂直居中(display:inline-block)：vertical-align: middle
      - 容器元素中垂直居中：用::before 伪元素(占据 100%容器高度)，设置 vertical-align：middle

      - 容器内只有一个元素时，display:flex + margin:auto

    - 水平垂直居中
      - absolute + transform
      - flex + justify-content + align-items


    **未知宽高的元素水平垂直居中**

    1. 通过定位和 transform 来实现(absolute + transform)

       ```
       .parent {
         width: 100%;
         height: 400px;
         background: relative;
         position: relative;
       }

       .children {
         position: absolute;
         top: 50%;
         left: 50%;
         background: red;
         transform: translate(-50%, -50%);
       }
       ```

    2. 利用 flex 布局来实现(flex + justify-content + align-items)

       ```
       .parent {
         width: 100%;
         height: 400px;
         background: #666;
         display: flex;
         align-items: center;
         justify-content: center;
       }
       .children {
         background: red;
       }
       ```

    3. 将父元素设置为 table，子元素设置为 table-cell，利用 table 属性(table + table-cell + vertical-align + text-align)

       ```
       .parent {
         display: table;
         width: 100%;
         height: 400px;
         background: #666;
       }
       .children {
         display: table-cell;
         vertical-align: middle;
         text-align: center;
         background: red;
       }
       ```

    **高度不定，宽 100%，内一 p 高不确定，如何实现垂直居中?**

    - verticle-align: middle;
    - 绝对定位 50%加 translateY(-50%)
    - 绝对定位，上下左右全 0，margin:auto

13. **CSS 动画**

    先定义 @keyframes 规则（0%，100% | from，to）

    - from 表示起始点
    - to 表示终点

    然后定义 animation，以下参数可直接写在 animation 后面

    - animation-name: 定义动画名称
    - animation-duration: 指定动画持续时长
    - animation-timing-function: 指元素根据时间的推进来改变属性值的变换速率，即动画的播放方式
      - (ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , ))
    - animation-delay: 指定元素动画开始时间
    - animation-iteration-count：指定元素播放动画的循环次数
      - (infinite | number)
    - animation-direction： 指定元素动画播放的方向。
      - normal：从 0%到 100%运行动画(向前播放)
      - reverse：从 100%到 0%运行动画
      - alternate：先从 0%到 100%，然后从 100%到 0%(先正向播放，再逆向播放)
      - alternate-reverse：先从 100%到 0%，然后从 0%到 100%(先逆向播放，再正向播放)
    - animation-play-state：控制元素动画的播放状态
      - (running | paused )
    - animation：是一个简写属性，用于设置六个动画属性
      - animation-name
      - animation-duration
      - animation-timing-function
      - animation-delay
      - animation-iteration-count
      - animation-direction

14. **过渡延迟**

15. **link 与 @import 的区别**

    - link 功能较多，可以定义 RSS，定义 Rel 等作用，而@import 只能用于加载 css
    - 当解析到 link 时，页面会同步加载所引的 css，而@import 所引用的 css 会等到页面加载完才被加载
    - @import 需要 IE5 以上才能使用
    - link 可以使用 js 动态引入，@import 不行

16. **纯 css 实现三角形**

    ```
    // 宽高都给0，通过设置border来实现
    .box{
      width:0px;
      height:0px;
      border-top:50px solid rgba(0,0,0,0);
      border-right:50px solid  rgba(0,0,0,0);
      border-bottom:50px solid green;
      border-left:50px solid  rgba(0,0,0,0);
    }
    ```

17. **至少两种方式实现自适应搜索**

18. **CSS3 新特性**

    - 选择器

      ```
      :last-child：选择元素最后一个孩子
      :first-child：选择元素第一个孩子
      :nth-child(1)：按照第几个孩子给它设置样式
      :nth-child(even)：按照偶数
      :nth-child(odd)：按照奇数
      enabled：选择匹配E的所有可用UI元素。
      :disabled：选择每个禁用的E元素
      :checked：选择每个被选中的E元素
      :not(selector)：选择非 selector 元素的每个元素
      ::selection：选择被用户选取的元素部分
      ```

      - 伪类：用于向某些选择器添加特殊的效果（没有创建新元素）
      - 伪元素：创建了 html 中不存在的元素，用于将特殊的效果添加到某些选择器

    - @Font-face：加载字体样式。还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。

    - 边框

      - border-radius(圆角)
      - border-image(边框图片)
      - box-shadow / text-shadow(阴影)

    - 背景

      - background-size：规定背景图片的尺寸
      - background-origin：规定背景图片的定位区域

    - 颜色

      - rgba(rgb 为颜色值，a 为透明度)

    - 文本

      - text-shadow：向文本添加阴影
      - text-justify：规定当 text-align 设置为 “justify” 时所使用的对齐方法
      - text-emphasis：向元素的文本应用重点标记以及重点标记的前景色
      - text-outline：规定文本的轮廓
      - text-overflow：规定当文本溢出包含元素时发生的事情
      - text-wrap：规定文本的换行规则
      - word-break：规定非中日韩文本的换行规则
      - word-wrap：允许对长的不可分割的单词进行分割并换行到下一行
      - text-decoration：文本修饰符：overline(上划线)、line-through(中划线)、underline(下划线)

    - 渐变

      - linear-gradient()：创建一个线性渐变的 "图像"。
      - radial-gradient()：用径向渐变创建 "图像"

    - 2D 转换(transform)

      - translate()：元素从其当前位置移动，根据给定的 left(x 坐标) 和 top(y 坐标) 位置参数
      - rotate()：元素顺时针旋转给定的角度。若为负值，元素将逆时针旋转。
      - scale()：元素的尺寸会增加或减少，根据给定的宽度(X 轴)和高度(Y 轴)参数，也可以一个值(宽高)
      - skew()：元素翻转给定的角度，根据给定的水平线(X 轴)和垂直线(Y 轴)参数
      - matrix()：把所有 2D 转换方法组合在一起，需要六个参数，包含数学函数，允许：旋转、缩放、移动以及倾斜元素。

    - 3D 转换

      - rotateX()：元素围绕其 X 轴以给定的度数进行旋转
      - rotateY()：元素围绕其 Y 轴以给定的度数进行旋转
      - perspective：规定 3D 元素的透视效果

    - 动画 animation

    - 过渡 transition

      - transition-property ：执行动画对应的属性
      - transition-duration：过渡动画的一个持续时间
      - transition-timing-function：在延续时间段，动画变化的速率(ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier)
      - transition-delay：延迟多久后开始动画

    - 多列布局

      - column-count: 规定元素应该被分隔的列数
      - column-gap: 规定列之间的间隔
      - column-rule: 设置列之间的宽度、样式和颜色规则

    - 用户界面

      - resize：规定是否可由用户调整元素尺寸
        如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll
      - box-sizing：
        - content-box：W3C 的标准盒模型。元素宽度 = 内容宽度 + padding + border
        - border-box：怪异盒模型。元素宽度 = 设定的宽度，padding 和 border 包括进去了
        - inherit：规定应从父元素继承 box-sizing 属性的值
      - outline-offset：对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓

    - 弹性布局 flex
    - 栅格布局 Grid

    - 滤镜 Filter

19. **display:none 与 visibility:hidden 的区别**

    - display:none：元素不可见、**不占据空间**、资源会加载、DOM 可访问

    - visibility:hidden：元素不可见、不能点击、但**占据空间**、资源会加载，可以使用

    - 区别

      - display: none 的元素不占据任何空间；visibility: hidden 的元素空间保留

      - display: none 会影响 transition 过渡效果；visibility: hidden 不会

      - display: none 会触发重绘和回流；visibility: hidden 只会触发重绘

      - display: none 的节点和子孙节点元素全都不可见；visibility: hidden 的节点的子孙节点元素可以设置 visibility: visible 显示

        - visibility: hidden 属性值具有继承性，所以子孙元素默认继承了 hidden 而隐藏，但是当子孙元素重置为 visibility: visible 就不会被隐藏


    - 补充
      - opacity:0 意思是该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，那么点击该区域，是可以触发点击事件的
      - opacity会触发重绘

20. **可继承属性和非继承属性**

    - 常用不可继承属性

      - 宽高:height, width
      - 最小最大宽高：max-height, min-height, max-width, min-width
      - dispaly
      - 文本阴影：text-shadow
      - 背景属性：background
      - 浮动属性：float
      - 生成内容：content
      - 层级属性：z-index
      - 定位属性：position, left, right, top, bottom
      - 盒模型属性：margin, padding, border

    - 常用可继承属性

      - 字体系列属性：font-family, font-size
      - 文本系列属性：text-indent, line-height,color
      - 元素可见性：visibility
      - 表格布局属性：border-style
      - 列表布局属性：list-style, list-style-type
      - 光标属性：cursor

21. **CSS Sprites**

    - 将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background- repeat，background-position 的组合进行背景定位

    - 利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能

    - CSS Sprites 能减少图片的字节。

22. **行内元素和块元素**

    - 行内元素

      - 特征

        - 设置宽高无效
        - 设置 margin 仅左右方向有效，上下无效
        - 设置 padding 上下左右都有效，但会撑大自己的空间
        - 不会自动进行换行

      - 常见行内元素：span, a, strong, b, em, i, small, big, label, img, input, select, textarea

    - 块元素

      - 特征

        - 能够识别宽高
        - margin 和 padding 的上下左右均对其有效
        - 可以自动换行
        - 多个块状元素标签写在一起，默认排列方式为从上至下

      - 常见块级元素：div, h1-h6, p, ul, ol, dl, table, form, header, hr, audio, video, article, section, footer

    - 行内块状元素

      - 特征

        - 不自动换行
        - 能够识别宽高
        - 默认排列方式为从左到右

    - 行内元素、块元素、行内块元素相互转换
      - display:inline 转换为行内元素
      - display:block 转换为块状元素
      - display:inline-block 转换为行内块状元素

23. **如何实现两栏布局**

    - float + margin-left

      ```
      *{
        /*清除默认格式*/
        margin:0;
        padding:0；
      }

      .left{
        width:200px;
        background-color:red;
        float:left;
      }

      .right{
        background-color:green;
        margin-left:200px;//等于左边栏的宽度
      }
      ```

    - absolute + margin-left

      ```
      *{
        /*清除默认格式*/
        margin:0;
        padding:0；
      }

      .left{
        width:200px;
        background-color:red;
        float:left;
      }

      .right{
        background-color:green;
        margin-left:200px;//等于左边栏的宽度
      }
      ```


    - float + BFC
      - 左侧元素浮动 + 右侧元素BFC(overflow：hidden)

    - flex布局：父元素display:flex，右侧元素flex:1
      ```
      * {
        /*清除默认格式*/
        margin:0;
        padding:0;
      }
      .box {
        display:flex;
      }
      .box1 {

      }
      .box2 {
        flex:1;
      }
      ```

22. **三栏布局：两边固定中间自适应**

    - 浮动布局：左右两侧浮动(左侧左浮，右侧右浮) 中间设置 margin-left 和 margin-right

      - 按照 left、right、middle 顺序布局
      - 优点：简单，兼容性好
      - 缺点：浮动布局脱离文档流，需要清除浮动，否则会带来问题，比如：父容器高度塌陷等。

    - 绝对布局：左右两侧绝对定位 中间设置 margin-left margin-right

      - 按照 left、middle、right 顺序布局
      - 优点：方便快捷，问题少
      - 缺点：元素脱离文档流，导致后面的元素也会脱离文档流，可使用性比较差。

    - flex 布局：父容器 display:flex，middle 元素 flex：1

      - 按照 left、middle、right 顺序布局
      - 优点：移动端首选
      - 缺点：不兼容 ie9 及以下

    - table 布局：父容器设置 display:table，子元素 display:table-cell

      - 按照 left、middle、right 顺序布局
      - 优点：兼容性好
      - 缺点：曾经风靡一时，但是现在基本被放弃了

    - **grid 布局**：父容器设置 display:grid 和 grid-template-columns，子元素设置 min-height

      - **等 grid 看完再回来完善这里**

    - **margin 负值法**

      - 双飞翼布局(浮动元素 margin 负值)

        - middle 放在 content 里，left 和 right 在 content 外
          ```
          <div class="content">
            <div class="middle"></div>
          </div>
          <div class="left"></div>
          <div class="right"></div>
          ```
        - content 左浮
        - middle 设置 margin-left 和 margin-right
        - left 左浮设置 margin-left：-100%
        - right 右浮，margin-left：-100%(自身宽度)

        ```
        .content {
          float: left;
          width: 100%;
        }
        .main {
          height: 200px;
          margin-left: 110px;
          margin-right: 220px;
          background-color: green;
        }
        .left {
          float: left;
          height: 200px;
          width: 100px;
          margin-left: -100%;
          background-color: red;
        }
          .right {
          width: 200px;
          height: 200px;
          float: right;
          margin-left: -200px;
          background-color: blue;
        }
        ```

        - 优点：主体内容可以优先加载

      - 圣杯布局

        - 按照 middle、left、right 布局
        - middle、left、right 全都左浮
        - 父容器设置 margin-left 和 margin-right
        - left 设置 margin-left：-100% 和 left 负值
        - right 设置 margin-left：-100%和 right 负值

        ```
        .container {
          margin-left: 120px;
          margin-right: 220px;
        }
        .main {
          float: left;
            width: 100%;
            height: 300px;
            background-color: red;
          }

        .left {
          float: left;
          width: 100px;
          height: 300px;
          margin-left: -100%;
          position: relative;
          left: -120px;
          background-color: blue;
        }
        .right {
          float: left;
          width: 200px;
          height: 300px;
          margin-left: -200px;
          position: relative;
          right: -220px;
          background-color: green;
        }
        ```

23. **CSS modules**

24. **移动端用什么距离单位**

25. **逻辑像素, 物理像素, 设备像素比**

26. **背景属性**

    - background
    - background-color
    - background-image
    - background-repeat
    - background-position
      - (表示相对于左侧的偏移量 background-position-x，表示相对于右侧的偏移量 background-position-y)
    - background-clip
      - border-box
      - padding-box：将图片裁剪到内边距盒子以内
      - content-box：把图片位于内边距及其之外的部分裁剪掉
    - background-attachment
      - fixed 让背景图在页面滚动时"粘"在页面上
      - scroll(默认值) 会让背景图片相对于元素本身固定
      - local 会让背景图片相对于元素中的内容固定
    - background-size 背景大小
      - contain 可以让浏览器尽可能保持图片最大化，同时不改变图片的宽高比
      - cover 图片会缩放以保证覆盖元素的每一个像素，同时不会变形

# Sass

# LESS

# DOM 相关

1. **事件流**

2. **事件委托(代理)**

3. **Event 对象**

4. **手写 EventEmitter(发布订阅模式--简单版)**

5. **如何阻止事件冒泡和默认事件**

   - 阻止冒泡：stopPropagation()
     - ie8 以下：设置事件对象的 cancelBubble 属性为 true
   - 阻止默认事件：preventDefault()
     - ie：设置事件对象的 returnValue 属性为 false

# BOM 相关

# HTML 相关

1. **语义化**

   - 去掉或者丢失样式的时候能够让页面呈现出清晰的结构
   - 有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
   - 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
   - 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。

2. **H5 新特性**

   - 语义标签

     - \<header>, \<footer> , \<nav>, \<section>, \ <article>, \<aside>, \<details>, \<summary>, \ <dialog>, \<figure>, \<main>, \<mark>, \<time>

   - 增强型表单

     表单元素：

     - \<datalist> 用户会在他们输入数据时看到域定义选项的下拉列表
     - \<progress> 进度条，展示连接/下载进度
     - \<meter> 刻度值，用于某些计量，例如温度、重量等
     - \<keygen> 提供一种验证用户的可靠方法
     - \<output> 用于不同类型的输出

     表单属性：

     - placehoder 输入框默认提示文字
     - required 要求输入的内容是否可为空
     - pattern 描述一个正则表达式验证输入的值
     - min/max 设置元素最小/最大值
     - step 为输入域规定合法的数字间隔
     - height/wdith 用于 image 类型\<input>标签图像高度/宽度
     - autofocus 规定在页面加载时，域自动获得焦点
     - multiple 规定\<input>元素中可选择多个值

   - 音频和视频

     - \<audio>
     - \<video>

   - Canvas 绘图
   - SVG 绘图
   - 地理定位 getCurrentPosition()
   - 拖放 API
   - Web Worker
   - WebStorage
   - WebSocket

3. **Canvas 绘图**

4. **SVG 绘图**

5. **拖放 API**

   > `<div draggable="true"></div>`

   | 事件      | 产生事件的元素           | 描述                                     |
   | --------- | ------------------------ | ---------------------------------------- |
   | dragstart | 被拖放的元素             | 开始拖放操作                             |
   | drag      | 被拖放的元素             | 拖放过程中                               |
   | dragenter | 拖放过程中鼠标经过的元素 | 被拖放的元素开始进入本元素的范围内       |
   | dragover  | 拖放过程中鼠标经过的元素 | 被拖放的元素正在本元素的范围内移动       |
   | dragleave | 拖放过程中鼠标经过的元素 | 被拖放的元素离开本元素的范围             |
   | drop      | 拖放的目标元素           | 有其他元素被拖放到本元素中               |
   | dragend   | 拖放的对象元素           | 拖放操作结束                             |
   | dragexit  | 拖放的对象元素           | 当元素变得不再是拖动操作的选中目标时触发 |

# JavaScript 相关

1. **JavaScript 数据类型**

   基本数据类型：

   - undefined
   - null
   - boolean
   - number
   - string

   复杂数据类型：

   - object

2. **操作符**

   - 位操作符

     - ~(按位非)
     - &(按位与)
     - |(按位或)
     - ^(按位异或)
     - <<(左移)
     - ">>" (有符号右移)(保留正负号标记)
     - ">>>" (无符号右移)(会把负数的二进制码当成正数的二进制码)

   - 加性操作符(操作数存在字符串的情况)

     - 加法

       - 两个操作数都是字符串，则字符串拼接
       - 只有一个操作数是字符串，则另一个字符转换为字符串，再字符串拼接

     - 减法
       - 若一个操作数是字符串、布尔值、null 或者 undefined，则后台先将其隐式转换(Number)成数值，然后再计算
       - 若一个操作数是对象，则调用对象的 valueOf()方法取得该对象的值，然后再计算

   - 关系运算符
     - 若两个操作数都是字符串，则比较两个字符串对应的字符编码值

3. **typeof 和 instanceof 原理**

   - typeof 原理：不同的对象在底层都表示为二进制，在 Javascript 中二进制前（低）三位存储其类型信息。

     - 000: 对象
     - 010: 浮点数
     - 100：字符串
     - 110： 布尔
     - 1： 整数

     所以 typeof null === object

   - instanceof 原理：用来比较一个对象是否为某一个构造函数的实例。(注：只能用于对象，不适用原始类型的值。)

     即，能在实例的**原型对象链**中找到该构造函数的 **prototype**属性所指向的**原型对象**，就返回**true**。

     **instanceof 的语法：**

     ```
     object instanceof constructor
     // 等同于
     constructor.prototype.isPrototypeOf(object)
     ```

     **instanceof 的代码实现**

     ```
     function instanceof(L, R) { //L是表达式左边，R是表达式右边
       const O = R.prototype;
       L = L.__proto__;
       while(true) {
           if (L === null)
               return false;
           if (L === O) // 这里重点：当 L 严格等于 0 时，返回 true
               return true;
           L = L.__proto__;
       }
     }
     ```

     **instanceof 原理**：检测 constructor.prototype 是否存在于参数 object 的 原型链上。instanceof 查找的过程中会遍历 object 的原型链，直到找到 constructor 的 prototype ,如果查找失败，则会返回 false，告诉我们，object 并非是 constructor 的实例

4. **JavaScript 中判断对象类型的几种方法**

   - typeof
   - instanceOf

   - constructor 属性：JavaScript 中，每个对象都有一个 constructor 属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。如给定一个求知的值，通过 typeof 运算符来判断它是基本数据类型的值还是对象。如果是对象，就可以使用 constructor 属性来判断其类型

   - Object.prototype.toString.call()

     - 目前为止发现的判断一个对象类型的最好的办法

     ```
     const b = []
     Object.prototype.toString.call(b);  // "[object Array]"

     const c = {}
     Object.prototype.toString.call(c);  // "[object Object]"

     const d = new Date()
     Object.prototype.toString.call(d);  // "[object Date]"

     const e = new RegExp();
     Object.prototype.toString.call(e);  // "[object RegExp]"
     ```

5. **JavaScript 中函数调用的几种方法**

   - 函数调用：this 指向 window，返回值由 return 决定

     ```
     function f1() {
       console.log(this);
     }
     f1();
     ```

   - 方法调用(函数作为方法调用)：this 指向方法的调用者 ，返回值由 return 决定

     ```
     var obj = {
       hello: function() {
         return "hello," + this.username;
       },
       username: "selena"
     };
     obj.hello(); // "hello, selena"
     ```

     - 上述 hello()直接调用的时候，this 的指向就成了问题。在这种情况下，this 往往被指向全局对象(严格模式下 this 指向 undefined)

   - 构造函数调用：this 指向当前构造函数构建的对象

     - 返回值有以下几种情况

       - 没有返回值，返回 this

         ```
         function Person() {
           this.age = 20;
           this.name = "zs";
           console.log(this);
         }
         var p1 = new Person(); // {age: 20, name:"zs"}
         ```

       - return 了一个基本数据类型

         ```
         function P2() {
           this.age = 18;
           return "abc";
         }

         var p2 = new P2();
         console.log(p2); //{age: 18}
         ```

       - 返回了一个复杂数据类型

         ```
         function P3() {
           this.age = 10;
           return {};
         }

         var p3 = new P3();
         console.log(p3);     //Object {}
         console.log(p3.age); //undefined

         function P3() {
           this.age = 10;
           return {};
         }

         var p3 = new P3();
         console.log(p3);     //Object {}
         console.log(p3.age); //undefined
         ```

   - 上下文调用
     - call()/apply()
     - this 指向
       - 传递一个 null/undefined -> window
       - 传递一个数字/字符串/布尔值 -> 对应的基本包装类型的对象
       - 传递一个对象 -> 指向该对象
     - 返回值：由 return 语句决定
       ```
       f1.call(null);
       f1.call(undefined);
       f1.call("abc"); // String { "abc" }
       f1.call(true);  // Boolean { true }
       f1.call(1);     // Number { 1 }
       ```

6. **for-in 和 for-of**

   - for-in：循环一个指定的变量来循环一个对象所有可枚举的属性

     ```
     for(variable in object){
       statements;
     }
     ```

     - 注：

       - 返回的除了数字索引外，还有自己自定义的属性名字
       - 通过 for-in 循环输出的属性名的顺序是不可预测的
       - 为遍历对象属性而构建，不建议与数组一起使用

     - for-in 遍历数组会出现的问题：

       - index 值 会是字符串（String）类型
       - 循环不仅会遍历数组元素，还会遍历任意其他自定义添加的属性
       - 某些情况下，会以随机顺序循环数组

   - for-of：循环可迭代对象(Array, Map, Set, arguments 等)，对值的每一个特殊属性调用一次迭代

     ```
     for(variable of object) {
       statements;
     }
     ```

   - for-in 和 for-of 的区别

     - for-in 循环遍历数组的结果是数组元素的下标

     - for-of 循环遍历数组的结果是数组元素的值

7. **遍历数组**

   - every()：每一项都为 true，返回 true

     - `arr.every(callback(element[, index[, array]])[, thisArg])`

   - some()：至少有一项为 true，返回 true

     - `arr.some(callback(element[, index[, array]])[, thisArg])`

   - filter()：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素

     - var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])

   - forEach()：对数组的每个元素执行一次给定的函数

     - `arr.forEach(callback(currentValue [, index [, array]])[, thisArg])`
     - 与 map() 或者 reduce() 不同的是，它总是返回 undefined 值，并且不可链式调用
     - forEach 不会直接改变调用它的对象，但是那个对象可能会被 callback 函数改变
     - 除了抛出异常，无法中止或跳出 forEach()循环

   - map()：创建一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值

     ```
     var new_array = arr.map(function callback(currentValue[, index[, array]]) {
       // Return element for new_array
     }[, thisArg])
     ```

     - 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）
     - 调用 map 方法之后追加的数组元素不会被 callback 访问

   - reduce()：对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值

     - `arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])`

       - accumulator：累计器累计回调的返回值; 是上一次调用回调时返回的累积值，或 initialValue
       - currentValue：数组中正在处理的元素。
       - index：数组中正在处理的当前元素的索引。如果提供了 initialValue，则起始索引号为 0，否则从 1 起始
       - array：调用 reduce()的数组

   - reduceRight()：接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值

8. **创建对象方式**

   - 工厂模式

     ```
     function createPerson(name, age, job) {
       var o = new Object();
       o.name = name;
       o.age = age;
       o.job = job;
       o.sayName = function() {
         alert(this.name);
       };
       return o;
     }
     var p1 = createPerson("nic", 29, "software engineer");
     var p2 = createPerson("greg", 27, "doctor");
     ```

     - 虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题

   - 构造函数模式

     ```
     function Person(name, age, job) {
       this.name = name;
       this.age = age;
       this.job = job;
       this.sayName = function() {
         alert(this.name);
       };
     }
     var p1 = new Person("nic", 29, "software engineer");
     var p2 = new Person("greg", 27, "doctor");
     ```

     - 构造函数的主要问题

       - 每个方法都要再每个实例上重新创建一遍(因此不同实例上的同名函数是不相等的)

   - 原型模式

     ```
     function Person(){

     }

     Person.prototype.name = "nic";
     Person.prototype.age = 29;
     Person.prototype.jon = "software engineer";
     Person.prototype.sayName = function(){
       alert(this.name);
     };

     var p1 = new Person();
     p1.sayName(); // "nic"

     var p2 = new Person();
     p2.sayName(); // "nic"

     alert(p1.sayName == p2.sayName); // true
     ```

     - hasOwnProperty()：检测一个属性是存在于实例中还是原型中。

       - 如果给定属性存在于对象实例中，才会返回 true
       - 若是原型属性，返回 false

     - in 操作符：会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中

     - hasPrototypeProperty()

       - 属性先存在于原型中，返回 true
       - 当实例重写属性后，该属性就存在于实例中了，返回 false

     - Object.keys()：接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组

     - Object.getOwnPropertyNames()：得到所有实例属性，无论是否可枚举

     - 可以用一个包含所有属性和方法的对象字面量来重写整个原型对象

     - 原型的动态性

       - 对原型对象所做的任何修改都能够立即从实例上反映出来
         - 实例中的指针仅指向原型，而不指向构造函数

     - 原型对象的问题
       - 省略了为构造函数传递初始化参数这一环节，所有实例在默认情况下都将取得相同属性值
       - 其共享的本性(原型中所有属性被很多实例共享)

   - 组合使用构造函数模式和原型模式

     - 构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性

       - 每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用
       - 支持向构造函数传递参数

     ```
     function Person(name, age, job) {
       this.name = name;
       this.age = age;
       this.job = job;
       this.friends = ["shelby", "Court"];
     }

     Person.prototype = {
       constructor : Person,
       sayName : function() {
         alert(this.name);
       }
     }

     var p1 = new Person("nic", 29, "software engineer");
     var p2 = new Person("greg", 27, "doctor");

     p1.friends.push("van");
     alert(p1.friends); // "Shelby,Court,Van"
     alert(p2.friends); // "Shelby,Court"
     alert(p1.friends === p2.friends); // false
     alert(p1.sayName === p2.sayName); // true
     ```

   - 动态原型模式

     - 把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型(仅在必要的情况下)，又保持了同时使用构造函数和原型的优点。

     ```
     function Person(name, age, job) {
       this.name = name;
       this.age = age;
       this.job = job;

       // 方法
       if(typeof this.sayName != "function") {
         Person.prototype.sayName = function() {
           alert(this.name);
         };
       }
     }

     var friend = new Person("nic", 29, "software engineer");
     friend.sayName();
     ```

     - 使用动态原型模式时不能使用对象字面量重写原型(会切断现有实例与新原型之间的联系)。

   - 寄生构造函数模式

     - 基本思想：创建一个函数，该函数的作用仅是封装创建对象的代码，然后再返回新创建的对象

     ```
     function Person(name, age, job) {
       var o = new Object();
       o.name = name;
       o.age = age;
       o.job = job;
       o.sayName = function() {
         alert(this.name);
       };
       return o;
     }

     var friend = new Person("nic", 29, "software engineer");
     friend.sayName(); // "nic"
     ```

     - 注：返回的对象与构造函数或构造函数的原型属性之间没有关系
       - 即构造函数返回的对象与构造函数外部创建的对象没有什么不同(因此不能依赖 instanceof 来确定对象类型)

   - 稳妥构造函数模式

     - 遵循与寄生构造函数类似的模式，但有两点不同

       - 新创建对象的实例方法不引用 this
       - 不适用 new 操作符调用构造函数

     ```
     function Person(name, age, job) {
       // 创建要返回的对象、
       var o = new Object();

       // 可以在这里定义私有变量和函数

       // 添加方法
       o.sayName = function() {
         alert(name);
       };

       // 返回对象
       return o;
     }
     ```

     - 使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有什么意义

9. **执行上下文**

   - 定义了变量或函数有权访问的其他数据，决定了他们各自的行为

   - 包含三个部分

     - 变量对象
     - 作用域链
     - this 指向

   - 类型
     - 全局执行上下文
     - 函数执行上下文
     - eval 执行上下文

10. **作用域 和 作用域链**

    - 作用域指的是一个变量和函数的作用范围

      - 全局作用域
      - 块级作用域

    - 作用域链：JavaScript 上每一个函数执行时，会先在自己创建的 活动对象 (Activation Object )上找对应属性值。若找不到则往父函数的 AO 上找，再找不到则再上一层的 AO,直到找到大全局作用域( window)。 而这一条形成的“AO 链” 就是 JavaScript 中的作用域链。

      - LHS：赋值操作的目标是谁
      - RHS：谁是赋值操作的源头

        - LHS 和 RHS 的特性

          - 都会在所有作用域中查找
          - 严格模式下，找不到所需的变量时，引擎都会抛出 ReferenceError 异常
          - 非严格模式下，LHR 稍微比较特殊，会自动创建一个全局变量
          - 查询成功时，如果对变量的值进行不合理的操作，比如对一个非函数类型的值进行函数调用，引擎会抛出 TypeError 异常

      - 把作用域链比喻成一个建筑，这个建筑代表程序中的嵌套作用域链，第一层楼表示当前的执行作用域，建筑的顶层表示全局作用那个易，LHS 和 RHS 引用都会在当前楼层进行查找，如果没找到，就往上一层找，还是没找到，就继续往上找，直到达到顶层(全局作用域)，可能会找到，也可能没找到，但无论如何到了顶层就会停止查找。——_援引自小黄书_

    - 作用域链的用途：保证对执行环境有权访问的所有变量和函数的有序访问。

    - 延长作用域链
      - try-catch 语句的 catch 块
      - with 语句

11. **变量提升 & 函数提升**

    - 先有声明，后有赋值

    - 函数声明会提升，函数表达式不会提升

      - 声明本身会提升，而包括函数表达式在内的赋值操作并不会提升

      - _以下援引自小黄书_

      ```
      foo() // TypeError

      var foo = function bar() {
        // ...
      }
      ```

      - 该例中，变量标识符 foo()被提升并分配给所在作用域，因此 foo()不会导致 ReferenceError，但是 foo 此时并没有赋值(如果它是一个函数声明而不是函数表达式，那么就会赋值)，foo()由于对 undefined 值进行函数调用而导致导致非法操作，因此会抛出 TypeError 异常。

    - 函数声明和变量声明都会被提升

      - 函数会首先被提升，然后才是变量

    - 所有的声明(变量和函数)，都会被"移动"到各自作用域的顶端，这个过程被称为提升

12. **原型**

13. **原型链**

    - 基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。

    - 原型链：每个构造函数都有一个 prototype 属性，指向它的原型对象，原型对象都有一个 constructor 属性，指向构造函数，而每个构造函数的实例都包含一个\_\_proto\_\_属性，指向该实例构造函数的原型对象。构造函数、原型和实例形成一个原型链，是一个用来实现继承和共享属性的对象链。

    - 属性查找机制：当访问一个对象的属性(包括方法)时，首先查找这个对象自身有没有该属性，如果没有就查找它的原型，若还没有就查找原型对象的原型，以此类推，一直找到 Object 为止，若找到就输出，若找不到就输出 null。

    - 属性修改机制：只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用`b.prototype.x = function(){...}`，但是这样会造成所有继承于该对象的实例的属性发生改变。

14. **继承**

    - 原型链继承

      ```
      function SuperType() {
        this.property = true;
      }
      superType.prototype.getSuperValue = function() {
        return this.property;
      };

      function subType() {
        this.subproperty = false;
      }

      // 继承了SuperType
      SubType.prototype = new SuperType();

      SubType.prototype.getSubValue = function() {
       return this.subproperty;
      }

      var instance = new SubType();
      alert(instance.getSuperValue()); // true
      ```

      - 确定原型和实例的关系：instanceof 或者 isPrototypeOf()

      - 给原型添加方法的代码一定要放在替换原型的语句之后

      - 在通过原型链实现继承时，不能使用对象字面量创建原型
        方法，因为这样回重写原型链(原型链被切断)。

      - 原型链的问题

        - 包含引用类型值的原型属性会被所有实例共享。

        ```
        function SuperType() {
          this.colors = ["red", "blue", "green"];
        }

        function SubType() {
        }

        // 继承了SuperType
        SubType.prototype = new SuperType();

        var instance1 = new SubType();
        instance1.colors.push("black");
        alert(instance1.colors); // "red, blue, green, black"

        var instance2 = new SubType();
        alert(instance2.colors)  // "red, blue, green, black"
        ```

        - 在创建子类型的实例时，不能向超类型的构造函数中传递参数。(没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数)

    - 借用构造函数：call(), apply()

      - 在子类型构造函数的内部调用超类型构造函数

      ```
      function SuperType() {
        this.colors = ["red", "blue", "green"];
      }

      function SubType() {
        // 继承了SuperType
        SuperType.call(this);
      }

      var instance1 = new SubType();
      instance1.colors.push("black");
      alert(instance1.colors); // "red, blue, green, black"

      var instance2 = new SubType();
      alert(instance2.colors); // "red, blue, green"
      ```

      - 借用构造函数可以在子类型构造函数中向超类型构造函数传递参数

      - 借用构造函数的问题
        - 方法都在构造函数中定义，因此函数复用无从谈起
        - 在超类型的原型中定义的方法，对子类型是不可见的，结果所有类型都只能使用构造函数模式

    - 组合模式

      - 将原型链和借用构造函数结合在一起

      - 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
        - 这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的

      ```
      function SuperType(name) {
        this.name = name;
        this.colors = ["red", "blue", "green"];
      }

      SuperType.prototype.sayName = function() {
        alert(this.name);
      }

      function SubType(name, age) {
        // 继承属性
        SuperType.call(this, name); // 第二次调用
        this.age = age;
      }

      // 继承方法
      SubType.prototype = new SuperType(); // 第一次调用
      SubType.prototype.constructor = SubType;
      SubType.prototype.sayAge = function() {
        alert(this.age);
      };

      var instance1 = new SubType("Nicholas", 29);
      instance1.colors.push("black");
      alert(instance1.colors); // "red, blue, green, black"
      instance1.sayName();  // "Nicholas"
      instance1.sayAge();   // 29

      var instance2 = new SubType("Greg", 27);
      alert(instance2.colors); // "red, blue, green"
      instance1.sayName();  // "Greg"
      instance1.sayAge();   // 27
      ```

      - 问题：无论什么情况，都会调用两次超类型构造函数：
        - 在创建子类型原型的时候
        - 在子类型构造函数内部

    - 原型式继承

      - 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型

      ```
      function object(o) {
        function F() {}
        F.prototype = o;
        return new F();
      }
      ```

      - 先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。

      - Object.create()

        - Object.create(用作新对象原型的对象[, 为新对象定义额外属性的对象])
          `var p1 = Object.create(person)`

        ```
        var p2 = Object.create(person, {
          name: {
            value: "Greg"
          }
        });
        ```

    - 寄生式继承

      - 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再返回对象

      ```
      function createAnother(original) {
        var clone = object(original);  // 通过调用函数创建一个新对象
        clone.sayHi = function() {     // 以某种方式增强这个对象
          alert("hi");
        };
        return clone;                  // 返回这个对象
      }
      ```

      - 由于不能做到函数复用而降低效率

    - 寄生组合继承(最有效)

      - 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。(本质：使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型)

      ```
      function inheritPrototype(subType, superType){
        var prototype = object(superType.prototype); //创建对象
        prototype.constructor = subType; // 增强对象
        subType.prototype = prototype;   // 指定对象(将新创建的对象赋值给子类型的原型)
      }
      ```

      ```
      function SuperType(name) {
        this.name = name;
        this.colors = ["red", "blue", "green"];
      }

      SuperType.prototype.sayName = function() {
        alert(this.name);
      }

      function SubType(name, age) {
        // 继承属性
        SuperType.call(this, name);
        this.age = age;
      }

      inheritPrototype(SubType, SuperType);

      SubType.prototype.sayAge = function() {
        alert(this.age);
      };
      ```

      - 如此，便只调用一次 SuperType 构造函数，并且因此避免了在 SubType，prototype 上面创建不必要的、多余的属性。原型链也保持不变。

    - ES6 Class extends 继承
    - ES6 Class super 继承

15. **闭包**

    - 指有权访问另一个函数作用域中的变量的函数。本质是利用了作用域的机制，来达到外部作用域访问内部作用域的目的

      - 是 js 特有的**链式作用域**结构

      - 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。(援引自小黄书)

      - 父函数被销毁 的情况下，返回出的子函数的\[\[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包

    - 闭包的优点

      - 封闭住了变量作用域，有效地防止了全局污染
      - 可以读取其他函数内部的变量，让这些变量的值始终保持在内存中，不会随着函数的结束而自动销毁
      - 可以很巧妙地实现静态私有变量、私有函数方法等

    - 闭包的缺点

      - 通常当执行期上下文被销毁时，函数的激活对象也就被销毁了。当有闭包引用时，活动对象就不会被销毁，因为它仍然被引用。这意味着闭包比非隔离的函数需要更多的内存。

      - 闭包函数的执行期上下文的作用域链中保存了自己的 Activation Object(激活对象)，外层函数 assignEvents Execution Context(执行上下文)的 Activation Object(激活对象)，以及 Global Object(全局对象)。(携带包含它的函数的作用域，所以会比其他函数占用更多的内存)

      - 闭包会使得函数中的变量都被保存在内存中，所以存在内存泄露的风险

    - 应用场景

      - 模拟块级作用域
        ```
        function outputNumbers(count) {
          (function() {
            for(var i = 0; i < count; i++) {
              alert(i);
            }
          })();
          alert(i);  // ReferenceError
        }
        ```
      - 模拟私有属性

        ```
        function getGeneratorFunc () {
          var _name = 'John';
          var _age = 22;

          return function () {
            return {
              getName: function () {return _name;},
              getAge: function() {return _age;}
            };
          };
        }

        var obj = getGeneratorFunc()();
        obj.getName(); // John
        obj.getAge(); // 22
        obj._age; // undefined
        ```

      - 单例模式
      - 科里化
      - 回调函数：在定时器、事件监听器、ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要用了回调函数，实际上就是在使用闭包(援引自小黄书)。

16. **函数科里化**

17. **防抖和节流(性能和优化)**

18. **对象的拷贝**

    - ECMAScript 的数据类型

      - 基本数据类型(undefined，boolean，number，string，null)

        - 一般存放于内存中的**栈**区，存取速度快，存放量小

        - 基本数据类型值不可变(操作基本数据类型的方法看上去返回了一个修改后的值，实际上返回的是一个新值)

      - 引用类型(Object,Array,Function)

        - 一般存放与内存中的**堆**区，存取速度慢，存放量大，其引用指针存于栈区，并指向引用本身

    - 浅拷贝：两个 js 对象指向同一个内存地址，其中一个改变会影响另一个

      - 简单的赋值操作(=)

      - Object.assign()：把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。拷贝的是对象的属性的引用，而不是对象本身

      - \$.extend({},obj)：使用递归思路实现了浅拷贝和深拷贝，第一个参数类型为 Boolean，当为 false 的时候必须省略不写则是浅拷贝，当为 true 的时候为深拷贝

    - 深拷贝：复制后的新对象重新指向一个新的内存地址，两个对象改变互不影响

      - 简单深拷贝

        - 手动的赋值操作

          ```
          var obj = { a: 10, b: 20};
          var newObj = { a: obj.a, b: obj.b};
          newObj.b = 100;
          console.log(obj);    // { a: 10, b: 20}
          console.log(newObj); // { a: 10, b: 100};
          console.log(obj == newObj);    //  false
          console.log(obj === newObj);   //  false
          ```

        - Object.assign()
          ```
          var obj = { a: {a: "hello"}, b: 33 };
          var newObj = Object.assign({}, obj);
          newObj.b = 100;
          console.log(obj);    //  { a: "hello", b: 33 };
          console.log(newObj); //  { a: "hello", b: 100 };
          console.log(obj==newObj);   //  false
          console.log(obj===newObj);  //  false
          ```

      - 复杂深拷贝

        - JSON.parse(JSON.stringify(obj)): 性能最快

          - 具有循环引用的对象时，报错
          - 当值为正则表达式、函数、undefined、或 symbol 时，无法拷贝
          - 会抛弃对象的 constructor(也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成 Object)

        - \$.extend(true,{},obj)：使用递归思路可以实现深拷贝，要求第一个参数必须为 true

          ```
          var obj = { a: {a: "hello"}, b: 33 };
          var newObj = $.extend(true, {}, obj);
          newObj.a.a = "hello world";
          console.log(obj);    //  { a: "hello", b: 33 };
          console.log(newObj); //  { a: "hello world", b: 33 };
          console.log(obj==newObj);   //  false
          console.log(obj===newObj);  //  false
          ```

        - Loadsh.cloneDeep()

        - Array 的 slice()和 concat()

        - 自己实现一个简单的深拷贝 deepClone()

          ```
          function deepClone(obj){
            if(typeof obj !== "object") return;
            let newObj = obj instanceof Array ? [] : {};
            for(let key in obj){
              if(obj.hasOwnProperty(key)){
                newObj[key] = typeof obj[key] === "object" ? deepClone(obj[key]) : obj[key];
              }
            }

            return newObj;
          }
          let obj = {a: 11, b: function(){}, c: {d: 22}};
          deepClone(obj);  // {a: 11, b: f(), c: {d: 22}};
          ```

19. **js 的垃圾回收机制**

20. **js 事件循环机制**

21. **this 的指向**

    - this 是在函数被调用时发生的绑定，它指向什么取决于函数的调用位置

      - 既不指向函数自身，也不指向函数的词法作用域

    - this 的默认绑定

      - strict mode 下，会绑定到 undefined
      - 非严格模式，this 指向全局对象

    - this 的隐式绑定

      - 当函数引用中有上下文对象时，隐式绑定规则会把调用中的 this 绑定到这个上下文对象
        ```
        function foo() {
          console.log(this.a);
        }
        var obj = {
          a: 2,
          foo: foo
        };
        obj.foo(); // 2
        ```
      - 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用

    - this 的显式绑定

      - 硬绑定

        - call()
        - apply()
        - Function.prototype.bind() (ES5)

      - API 调用的"上下文"

    - new 绑定

    - 优先级：new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定

22. **new 运算符的执行过程**

    - 创建(/构造)一个全新的对象
    - 新对象链接到该函数的\[\[prototype\]\]原型
    - 新对象绑定函数调用的 this: apply(属性和方法被加入到对象中)
    - 返回新对象(如果构造函数有自己 retrun 时，则返回该值)

    ```
    var obj  = {};
    obj.__proto__ = Base.prototype;
    Base.call(obj);
    ```

23. **改变 this 的指向：call()、apply()、bind()**

    - **call()**

    - **apply()**

    - **bind()**

    - **call()、apply()、bind()的区别**

24. **V8 线程模式**

25. **V8 垃圾回收机制**

26. **前端模块化**

    - 有几种规范？
    - commonjs 和 es module 都是怎么实现的？有啥区别？

27. **前端性能优化**

# ES6 相关

1. **let、const**

   - let

   - const

2. **箭头函数**

3. **解构赋值**

4. **数组新增方法**

   - Array.of()
   - Array.from()
   - find()
   - findIndex()
   - fill()
   - copyWithin()
   - entries()
   - values()
   - keys()
   - includes()
   - flat()
   - flatMap()

5. **对象新增方法**

   - Object.is()
   - Object.getOwnPropertySymbols()
   - Object.setPrototypeOf()
   - Object.getPrototypeOf()
   - Object.assign()

6. **Number 新增方法**

   - Number.isNaN()
   - Number.isFinite()

7. **字符串新增方法**

   - String.raw()
   - repeat()
   - startsWith()
   - endsWith()
   - includes()
   - normalize()

8. **Map()**

9. **Set()**

10. **Symbol**

11. **Generator**

12. **Promise**

    - 封装异步操作

    - **promise 实现**

      ```
      <!-- resolve和reject两个回调函数 -->
      var myPromise = new Promise((resolve, reject) => {
        // 需要执行的代码...
        if (/* 异步执行成功 */) {
          resolve(value)
        } else if (/* 异步执行失败 */) {
          reject(error)
        }
      });

      <!-- 两个回调函数 -->
      myPromise.then((value) => {
        // 成功后调用, 使用 value 值
      }, (error) => {
        // 失败后调用, 获取错误信息 error
      })
      ```

      - resolve()和 reject()的使用(援引自小黄书)

        - 如果调用 reject，则 promise 被拒绝，如果有任何值传给 reject，则这个值就是被拒绝的原因值

        - 如果调用 resolve 且没有值传入，或者传入任何非 promise 值，这个 promise 就完成

        - 如果调用 resolve 并传入另外一个 promise，这个 promise 就会采用传入的 promise 的状态

    - **promise 特点**

    - **Promise 优缺点**

    - **promise 的应用**

13. **async & await**

14. **Class**

    - extends 继承

    - super 继承

# 浏览器相关

1. **跨标签页通讯**

   本质原理就是去运用一些可以 共享的中间介质

   - 通过父页面 window.open()和子页面 postMessage
   - 设置同域下共享的 localStorage 与监听 window.onstorage
     - 父标签页使用 localStorage.setItem(key,value)添加（修改、删除）内容
     - 子标签页监听 storage 事件
   - 设置共享 cookie 与不断轮询检查(setInterval)
   - 借助服务端或者中间层实现

2. **从输入 URL 到展示的过程**

   - 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP
   - TCP 三次握手建立连接
   - 向服务器发起 HTTP 请求，分析 url，设置请求报文(头，主体)
   - 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）
   - 浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构

     - HTML parser --> DOM Tree
     - CSS parser --> Style Tree(样式树)
     - attachment --> Render Tree(渲染树)
     - layout: 布局
     - GPU painting: 像素绘制页面
     - 载入解析到的资源文件，渲染页面

   - 当数据传送完毕，发起 TCP 四次挥手断开连接。

3. **存储(localStorage、sessionStorage、cookie)**(再仔细看一下)

   - cookie：http 中自动携带， 体积上限为 4K， 可自行设置过期时间(不可以跨域调用)

     - Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。

   - localStorage ：长久储存，除非主动删除数据，否则数据是永远不会过期的
   - sessionStorage：用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁， 体积限制为 4~5M

4. **重绘和回流**

5. **浏览器架构**

6. **浏览器下事件循环(Event Loop)**

   - 宏任务

   - 微任务

7. **Web Worker**

   现代浏览器为 JavaScript 创造的 多线程环境。
   可以新建并将部分任务分配到 worker 线程并行运行，两个线程可**独立运行，互不干扰**，可通过自带的**消息机制**相互通信。

   - postMessage //向 worker 发送数据
   - onmessage //接收 worker 传过来的数据函数

   **基本用法**

   ```
   // 创建 worker
   const worker = new Worker('work.js');

   // 向主进程推送消息
   worker.postMessage('Hello World');

   // 监听主进程来的消息
   worker.onmessage = function (event) {
     console.log('Received message ' + event.data);
   }
   ```

   **限制**

   - 同源限制
   - 无法使用 document / window / alert / confirm
   - 无法加载本地资源

8. **内存泄露**

# 服务端与网络相关

1. **http 和 https**

   - http：超文本传输协议(Hyper Text Transfer Protocol)
     从 WEB 服务器传输超文本标记语言(HTML)到本地浏览器的传送协议，可以使浏览器更加高效，使网络传输减少。

     - 原理

       - 基于 TCP/IP 通信协议来传递数据，传输的数据类型为 HTML 文件, 图片文件, 查询结果等
       - 一般用于 B/S 架构。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。

     - 特点

       - **基于请求和响应**：客户端发起请求，服务端响应
       - **无状态**：协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都**不做持久化处理**。这是为了更快地处理大量事务，确保协议的可伸缩性。
       - **无连接**：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接。不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录 http 状态的技术，一个叫做 Cookie,一个叫做 Session。
         - HTTP/1.1 和部分 HTTP/1.0 的改进：**持久连接**：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。
         - **管线化**：持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应。
       - **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。
       - **灵活**：HTTP 允许传输任意类型的数据对象。传输的类型由 Content-Type 加以标记。

     - http 工作流程
       - 地址解析：解析出协议名、主机名、端口、对象路径等部分
       - 封装 HTTP 请求数据包
       - 封装成 TCP 包，建立 TCP/IP 连接(TCP/IP 三次握手)
       - 客户端向服务端发起 HTTP 请求。(例如：POST/login.html http/1.1)
         - 最后会发送一空白行，标示客户端请求完毕
       - 服务器响应
         - 服务器向客户端发送应答头信息(例如：HTTP/1.1 200 OK)
         - 之后服务端也会发送一个空白行，表示应答头信息发送完毕，接着就以 Content-type 要求的数据格式发送数据给客户端
       - 服务端关闭 TCP 连接
         - 如果服务器或者客户端在其头信息加入 Connection:keep-alive，就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接

   - https：超文本传输安全协议(Hypertext Transfer Protocol Secure)。是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。

     - 原理

       - 客户端向服务器端索要并验证公钥。
         - 这一阶段使用的是非对称加密传输(RSA)，服务端将数字证书发给客户端。其中数字证书包括：公钥和数字签名。客户端在拿到后对两者进行校验.
       - 在非对称加密传输中,两端协商生成"对话密钥"。
       - 双方采用"对话密钥"进行对称加密通信。

     - 特点

       - 优点

         - 内容加密
         - 保护数据完整性
         - 对网站服务器进行真实身份认证

       - 缺点

         - https 协议握手阶段比较费时
         - https 连接缓存不如 http 高效，会增加数据开销和功耗
         - https 连接服务器端资源占用相比于 http 高很多， 会降低用户的访问速度
           - SSL 涉及到的安全算法会消耗 CPU 资源
         - 申请 SSL 证书需要钱，功能越强大的证书费用越高
         - SSL 证书通常需要绑定 IP，不能再同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗

     - https 工作流程

       - ![image](https://pics1.baidu.com/feed/023b5bb5c9ea15ce26b853cd9cdca2f73887b284.jpeg?token=5ee5bde0022bc60fbbcfb1fe34e739b7&s=7EAC3C6259DFC0C8485CE0DB0000C0B1)

       - 客户端通过 URL 访问服务器建立 SSL 连接。
       - 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
       - 客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。
       - 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
       - 服务器利用自己的私钥解密出会话密钥。
       - 服务器利用会话密钥加密与客户端之间的通信。

   - http 和 https 的区别
     - https 协议需要到 CA 申请证书，一般免费证书很少，需要交费
     - http 信息是明文传输，会被他人截获，不安全；https 通过 SSL\TLS 进行加密，传输信息不易被截获，非常安全
     - http 使用的端口是 80，HTTPS 是 443
     - http 的连接很简单,是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全
     - 在 OSI 网络模型中，http 工作于应用层，而 https 工作在传输层

2. **TCP 和 UDP 协议**

3. **DNS 域名解析**

4. **缓存策略: 强缓存 和 协商缓存**

   - 缓存：是一种保存资源副本并在下次请求时直接使用该副本的技术。浏览器缓存就是浏览器请求网站留下的资源副本.

   - 缓存的好处

     - 缓解服务器压力(不用每次去请求资源)
     - 减少页面加载时间，提升性能
     - 减少带宽消耗

   - 缓存的分类

     - 宏观

       - 私有缓存: 用户专享，各级代理不能缓存
       - 共享缓存: 能够被多个用户使用的缓存,也就是那些能被各级代理的缓存

     - 微观：浏览器缓存、代理服务器缓存、网关缓存、数据库缓存

   - 浏览器缓存

     - 浏览器缓存分为强缓存和协商缓存，强缓存会直接读取浏览器缓存，不会向服务器发送请求，而协商缓存先向访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据

     - 强缓存(Expires & Cache-Control)

       - 给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期，浏览器需要重新请求

       - 三种情况

         - 第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求
         - 存在缓存标识和缓存结果，但是缓存结果已经失效，则使用协商缓存
         - 存在缓存标识和缓存结果，且该结果尚未失效，强制缓存生效，直接返回该结果

       - Expires：HTTP/1.0 中的定义缓存的字段，告知客户端资源缓存失效的**绝对时间**

         > `Expires: Wed Feb 20 2019 11:25:41 GMT`

         - 弊端：Expires 返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致 Expires 很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入 Cache-Control:max-age 指令的原因之一。

       - Cache-Control:max-age：HTTP/1.1 定义的关于缓存的字段，它规定了缓存过期的一个**相对时间**

         - public：所有内容都将被缓存(客户端和代理服务器都可缓存)
         - private：所有内容只有客户端可以缓存，Cache-Control 的默认取值
         - no-cache：客户端缓存内容，每次使用需要经过协商缓存来验证决定是否可用
         - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
         - max-age=xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效

       - 优先级：**Cache-Control > Expires**

       - 缺点：该缓存方式优先级高，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源(所以有了协商缓存)

     - 协商缓存(Last-Modified & Etag)

       - 强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

       - 利用 Last-Modified，If-Modified-Since 和 ETag、If-None-Match 对资源做标识，然后由服务器做分析，如果资源未更新，则返回 304 状态码，那么浏览器则会从缓存中读取资源，否则重新请求资源

       - Last-Modified 与 If-Modified-Since

         - last-modified：资源在服务器上最后一次修改的时间
         - If-Modified-Since：上一次请求时返回的 Last-Modified 的值

         - 服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化

           - 若无变化，返回 304 Not Modified(response header 中不会再添加 Last-Modified 的 header)，不会返回资源内容

           - 若有变化，返回 200，正常返回资源内容

         - 浏览器收到 304 的响应后，就会从缓存中加载资源

         - 浏览器收到 200 的响应后，则从服务器加载新资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值

         - 缺点
           - 周期性修改，但内容未变时，会导致缓存失效
           - 以秒为单位进行更新，如果小于该单位高频进行更新的话，则不适合采用该方法，这时候协商缓存就不那么的可靠了。(所以就有了 ETag、If-None-Match)

       - Etag 与 If-None-Match

         - Etag(response 携带)：服务器根据当前请求的资源生成的一个唯一标识，是一个字符串，只要资源有变化这个标识就会不同，跟最后修改时间没有关系

         - If-None-Match：浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag 的值

         - 服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化

           - 若无变化，则返回 304 Not Modified，不会返回资源内容(由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化)

           - 若有变化，则返回 200，并正常返回资源内容

         - 浏览器收到 304 的响应后，就会从缓存中加载资源

         - 浏览器收到 200 的响应后，则从服务器加载新资源时，ETag 在重新加载时会被更新，下次请求时，If-None-Match 会启用上次返回的 ETag 值

       - ETag 相对于 Last-Modified 可更加准确地判断文件内容是否被修改，从而在实际操作中实用程度也更高；但由于需要对资源进行生成标识，性能方面势必有所牺牲

       - 强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道；协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道(协商缓存需要配合强缓存使用)

       - Last-Modified、If-Modified-Since 和 ETag、If-None-Match 一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。

         - 注：分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败

         - 分布式系统尽量关闭掉 ETag(每台机器生成的 ETag 都会不一样）

       * 优先级：**ETag/If-None-Match > Last-Modified/If-Modified-Since**, 同时存在时, 前者覆盖后者

     - 启发式缓存

       - 当请求头中确定缓存过期时间的字段一个都没有，会默认触发浏览器启发式缓存。

     - 缓存的优先级

       - 强缓存 > 协商缓存 > 启发式缓存
       - Cache-Control > Expires > ETag > Last-Modified

     - 浏览器整个缓存策略的过程：
       ![image](https://user-gold-cdn.xitu.io/2018/1/27/16137f262e0adf18?imageView2/0/w/1280/h/960/ignore-error/1)

       - 浏览器先检查 Cache-Control，如果为 no-store，则浏览器所有内容都不会缓存，强制缓存，协商缓存统统都不会触发

5. **http 状态码**

   常见状态码

   - 1xx: 接受，继续处理
   - 200: 成功，并返回数据
   - 201: 已创建
   - 202: 已接受
   - 203: 成功，但未授权
   - 204: 成功，无内容
   - 205: 成功，重置内容
   - 206: 成功，部分内容
   - 301: 永久移动，重定向
   - 302: 临时移动，可使用原有 URI
   - 304: 资源未修改，可使用缓存
   - 305: 需代理访问
   - 400: 请求语法错误
   - 401: 要求身份认证
   - 403: 拒绝请求
   - 404: 资源不存在
   - 500: 服务器错误

6. **WebSocket**

   特点：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的**双向平等对话**，属于服务器推送技术的一种。(不受同源政策影响)

   - 其他特点:

     - 建立在 TCP 协议之上，服务器端的实现比较容易
     - 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器
     - 数据格式比较轻量，性能开销小，通信高效
     - 可以发送文本，也可以发送二进制数据
     - 没有同源限制，客户端可以与任意服务器通信
     - 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL

   - 新建 WebSocket 实例：var ws = new WebSocket(url)
   - 指定连接成功后的回调函数：**ws.onopen** = fn
   - 指定连接关闭后的回调函数：**ws.onclose** = fn
   - 指定收到服务器数据后的回调函数：**ws.onmessage** = fn
   - 向服务器发送数据：**ws.send()**
   - 指定报错时的回调函数：**ws.onerror** = fn

   - webSocket.readyState

     - CONNECTING：值为 0，表示正在连接
     - OPEN：值为 1，表示连接成功，可以通信了
     - CLOSING：值为 2，表示连接正在关闭
     - CLOSED：值为 3，表示连接已经关闭，或者打开连接失败

7. **Ajax**

8. **get 和 post**

9. **fetch**

10. **跨域，同源策略，如何解决跨域问题**

    - **同源**指的是两个域需要协议，子域名，主域名与端口号都保持一致，四者有一个不同，即属于**跨域**

    - 同源政策的目的

      - 保证用户信息的安全，防止恶意的网站窃取数据

    - 同源策略限制内容

      - Cookie、LocalStorage、IndexedDB 等存储性内容
      - DOM 节点
      - AJAX 请求发送后，结果被浏览器拦截了

    - 跨域的**解决方案**

      - **JSONP**

        - 利用 script 标签可以不受限制的从其他域加载资源的能力，进行跨域通信

        - 由两部分组成：回调函数和数据

          - 回调函数是服务端响应带来时，应该调用的函数，需要在 URL 中指定
          - 数据就是服务器返回给浏览器的响应

          - 关键在于：**服务端响应数据是一个函数的调用，真正要发送给客户端的数据作为函数调用的参数**
            ```
            const data = fn({name: "zs", age:"20"});
            res.send(data);
            ```

      - JSONP 的使用

        - 动态创建一个 script 元素
        - 为 script 指定 src 属性的值，需要将回调函数名拼接给 url，形式为：`callback=functionName`
        - 然后动态地将 script 标签追加到 body 中

        - 由于使用 script 标签的 src 属性，因此只支持 get 方法

        - 简单实现

          ```
          function jsonp(req) {
            var script = document.createElement('script');
            var url = req.url + '?callback=' + req.callback.name;
            script.src = url;
            document = getElementsByTagName('head')[0].appendChild(script);
          }
          ```

          前端示例

          ```
          function hello(res) {
            alert('hello' + res.data);
          }

          jsonp({
            url : '',
            callback : hello
          });
          ```

          服务端代码(面试完换一下)

          ```
          (function(global) {
            var id = 0, container = document.getElementsByTagName("head")[0];

            function jsonp(options) {
              if(!options || !options.url) return;

              var scriptNode = document.createElement("script"),
                  data = options.data || {},
                  url = options.url,
                  callback = options.callback,
                  fnName = "jsonp" + id++;

               // 添加回调函数
               data["callback"] = fnName;

               // 拼接url
               var params = [];
               for(var key in data) {
                 params.push(encodeURIComponent(key) + "=" + encodeURIComponent(data[key]));
               }

               url = url.indexOf("?") > 0 ? (url + "&") : (url + "?");

               url += params.join("&");
               scriptNode.src = url;

               // 传递的是一个匿名的回调函数，要执行的话，暴露为一个全局方法
               global[fnName] = function (ret) {
                 callback && callback(ret);
                 container.removeChild(scriptNode);delete global[fnName];
               }

               // 出错处理
               scriptNode.onerror = function() {
                 callback && callback({error:"error"});
                 container.removeChild(scriptNode);
                 global[fnName] && delete global[fnName];
               }

               scriptNode.type = "text/javascript";
               container.appendChild(scriptNode);
            }
            global.jsonp = jsonp;
          })(this)
          ```


     - 通过 JQuery Ajax 发起 jsonp 请求

       ```
       $.ajax({
         // 请求方式
         type: "get",
         // 请求地址
         url: "http://169.254.200.238:8080/jsonp.do",
         // 标志跨域请求
         dataType: "jsonp",
         // 跨域函数名的键值，即服务端提取函数名的钥匙（默认为callback）
         jsonp: "callbackparam",
         // 客户端与服务端约定的函数名称
         jsonpCallback: "jsonpCallback",
         // 请求成功的回调函数，json既为我们想要获得的数据
         success: function(json) {
           console.log(json);
         },

         // 请求失败的回调函数
         error: function(e) {
           alert("error");
         }
       })
       ```

     - **CORS**(cross-origin-resource) 跨域资源共享

       - 浏览器一旦发现请求跨源，就会在请求报文中自动添加一些附加的origin头信息(包括页面源信息：协议、域名和端口号)，有时还会多出一次附加的请求；服务器收到请求报文后，如果同意该请求，则在响应报文头部加Access-Control-Allow-Origin，值与请求报文头的origin头部的值一致

       - 服务器端设置两个访问头
         - 允许那些客户端访问我
           `res.header('Access-Control-Allow-Origin','*')`
           > *即请求报文头的origin头部的值
         - 允许客户端使用那些请求方式访问我
           `res.header('Access-Control-Allow-Methods','get/post')`

     - **iframe**

       - window.name + iframe

       - location.hash + iframe

       - document.domain + iframe

     - **postMessage**

       - otherWindow.postMessage(message, targetOrigin, \[transfer]);
         - message: 将要发送到其他 window的数据
         - targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI
         - transfer(可选)：是一串和message 同时传递的 Transferable 对象

     - **WebSocket**

10. **三次握手 和 四次挥手**

    - 三次握手(根据 IP 建立 TCP 连接)

      - 客户端和服务端互相确认可以收发数据

      - 客户端发送一个 syn 包：即带有 SYN=1，Seq=x 的数据包到服务器端口，并进入 SYN_SENT 状态，等待服务器确认；(第一次握手，由浏览器向服务器发起，告诉服务器我要发生请求了)

      - 服务器收到 syn 包，必须确认客户的 SYN，同时发回一个带 SYN=1， ACK=x+1， Seq=y 的响应包以示传达确认信息，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；（第二次握手，由服务器发起，告诉浏览器我准备好接收信息了）

      - 客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK，即回传一个带 ACK=y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发送信息了，准备接收吧）

      ![image](https://user-gold-cdn.xitu.io/2019/2/22/16914083b8093f55?imageView2/0/w/1280/h/960/format/png/ignore-error/1)

      - 为何建立连接需要三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

    - 四次挥手(关闭 TCP 连接)

      - 通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)

      ![image](https://user-gold-cdn.xitu.io/2019/2/22/169140a85c0fec37?imageView2/0/w/1280/h/960/format/png/ignore-error/1)

      - 第一次挥手：客户端向服务端发送报文，Fin、Ack、Seq，表示已经没有数据传输了，并进入 FIN_WAIT_1 状态。(浏览器发起，发送给服务器，告知服务器请求报文发送完毕，你可以准备关闭了)

      - 第二次挥手：服务端收到 FIN 后，发送响应报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(服务器发起，告诉浏览器，我请求报文接收完了，准备关闭了，你也准备吧)

      - 第三次挥手：服务端向客户端发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(服务器告诉浏览器，我响应报文发送完了，你准备关闭吧)

      - 第四次挥手：客户端收到 FIN 后向服务端发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。服务端收到客户端的报文段后关闭连接(CLOSED)，客户端等待一定时间未收到回复，则正常关闭。(浏览器发起，告诉服务器，我响应报文接收完毕了，我准备关闭了，你也准备吧。)

      - 为什么关闭连接需要四次挥手：关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。

11. **CSRF 和 XSS 区别及防御**

12. **进程 和 线程**

# Vue 相关

1. **生命周期**

   - \_init\_

     - initLifecycle/Event，往 vm 上挂载各种属性
     - callHook: beforeCreated: 实例刚创建
     - initInjection/initState: 初始化注入和 data 响应性
     - created: 创建完成，属性已经绑定， 但还未生成真实 dom
     - 进行元素的挂载： $el / vm.$mount()
     - 是否有 template: 解析成 render function
       - \*.vue 文件: vue-loader 会将\<template>编译成 render function
     - beforeMount: 模板编译/挂载之前
     - 执行 render function，生成真实的 dom，并替换到 dom tree 中
     - mounted: 组件已挂载

   - update:

     - 执行 diff 算法，比对改变是否需要触发 UI 更新
     - flushScheduleQueue
     - watcher.before: 触发 beforeUpdate 钩子 - watcher.run(): 执行 watcher 中的 notify，通知所有依赖项更新 UI
     - 触发 updated 钩子: 组件已更新

   - actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活

   - destroy:
     - beforeDestroy: 销毁开始
     - 销毁自身且递归销毁子组件以及事件监听
     - remove(): 删除节点
     - watcher.teardown(): 清空依赖
     - vm.\$off(): 解绑监听
     - destroyed: 完成后触发钩子

```

new Vue({})

// 初始化 Vue 实例
function \_init() {
// 挂载属性
initLifeCycle(vm)
// 初始化事件系统，钩子函数等
initEvent(vm)
// 编译 slot、vnode
initRender(vm)
// 触发钩子
callHook(vm, 'beforeCreate')
// 添加 inject 功能
initInjection(vm)
// 完成数据响应性 props/data/watch/computed/methods
initState(vm)
// 添加 provide 功能
initProvide(vm)
// 触发钩子
callHook(vm, 'created')

     // 挂载节点
     if (vm.$options.el) {
         vm.$mount(vm.$options.el)
     }

}

// 挂载节点实现
function mountComponent(vm) {
// 获取 render function
if (!this.options.render) {
// template to render
// Vue.compile = compileToFunctions
let { render } = compileToFunctions()
this.options.render = render
}
// 触发钩子
callHook('beforeMounte')
// 初始化观察者
// render 渲染 vdom，
vdom = vm.render()
// update: 根据 diff 出的 patchs 挂载成真实的 dom
vm.\_update(vdom)
// 触发钩子
callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
// 遍历队列中所有修改
for(){
// beforeUpdate
watcher.before()

        // 依赖局部更新节点
        watcher.update()
        callHook('updated')
    }

}

// 销毁实例实现
Vue.prototype.$destory = function() {
   // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove()
    // 删除依赖
    watcher.teardown()
    // 删除监听
    vm.$off()
// 触发钩子
callHook(vm, 'destoryed')
}

```

![image text](https://user-gold-cdn.xitu.io/2018/1/27/16137f262e0adf18?imageView2/0/w/1280/h/960/ignore-error/1)

2. **表单输入绑定**

   - v-model 可创建数据双向绑定

     - 在内部为不同的输入元素使用不同的 property 并抛出不同的事件

   - **数据双向绑定原理**

     - 采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者。

       ```
       var obj  = {};
       Object.defineProperty(obj, 'name', {
         get: function() {
           console.log('获取了')
           return val;
         },
         set: function (newVal) {
             console.log('设置了')
         }
       })

       obj.name = 'yzg'; / /在给obj设置name属性的时候，触发了set这个方法
       var val = obj.name;  //在得到obj的name属性，会触发get方法
       ```

   - **解除双向绑定**

3. **v-if 和 v-show**

   - **v-if** 用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truethy 值的时候被渲染

     - 添加一个具有唯一值的 key attribute，表达“这两个元素是完全独立的，不要复用它们”

   - **v-show** 用于根据条件展示元素

     - 带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display

   - **v-if 和 v-show 的区别**

     - v-if：是"真正"的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建

       - 如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块

     - v-show：不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换

     - 一般来说 v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销

     - 当显示与隐藏切换频率高，用 v-show，只有一次切换: v-if

4. **创建组件**

   - 全局注册
   - 局部注册
   - 模块系统
     - 模块系统中局部注册
     - 基础组件的自动化全局注册

5. **为什么组件 data 必须是函数**

   > 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？

   - 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响(等于是子组件的 data 属性都指向这个对象的内存地址了)；
   - 如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；

   - new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。

6. **父子组件传递参数**

7. **vuex 组成和原理**

8. **jQuery 的优缺点，与 vue 的不同，vue 的优缺点**

   - jQuery

     - 优点: 比原生 js 更易书写, 封装了很多 api, 有丰富的插件库;
     - 缺点: 每次升级与之前版本不兼容, 只能手动开发, 操作 DOM 很慢, 不方便, 变量名污染, 作用域混淆等。

   - vue ：双向绑定, 虚拟 DOM, diff 算法, MVVM, 组件化, 通信方便, 路由分发等

9. **MVC 与 MVVM**

# webpack 相关

# 设计模式

1. **工厂模式**

2. **单例模式**

   - 单例模式思想在于保证一个特定类仅有一个实例，意味着当你第二次使用同一个类创建信对象时，应得到和第一次创建对象完全相同

   - 特点
     - 可以来划分命名空间，从而清除全局变量所带来的风险
     - 可以把代码组织的更为一体，便于阅读和维护
     - 可以被实例化，且实例化一次

   ```
   var Singleton = function(name) {
     this.name = name;
   };

   Singleton.prototype.getName = function() {
     return this.name;
   }

   // 获取实例对象
   var getInstance = (function() {
     var instance = null;
     return function(name) {
       if(!instance) {
         instance = new Singleton(name);
       }
       return instance;
     }
   })();

   var a = getInstance("aa");
   var b = getInstance("bb");
   console.log(b.getName()); // "aa"
   console.log(a === b);     // true
   ```

   - 应用示例：实现一个遮罩层，来防止用户中断页面操作

   ```
   var createMask = function() {
     var div = document.createElement("div");
     div.innerHTML = "遮罩层";
     div.style.display = 'none';
     document.body.appendChild(div);
     return div;
   }

   // 创建iframe
   var createIframe = function() {
     var iframe = document.createElement("iframe");
     document.body.appendChild(iframe);
     return iframe;
   }

   // 获取示例的封装代码
   var getInstance = function(fn) {
     var result;
     return function() {
       return result || (result = fn.call(this, arguments));
     }
   };

   // 测试创建遮罩层
   var createSingleMask = getInstance(createMask);
   document.querySelector("body").onclick = function(){
     var win = createSingleMask();
     win.style.display = "block";
   };

   // 测试创建iframe
   var createSingleIframe = getInstance(createIframe);
   document.querySelector("body").onclick = function(){
     var win = createSingleIframe();
     win.src = "https://www.example.com/";
   };
   ```

3. **模块模式**

   - 模块模式是为单例创建私有变量和特权方法，并减少全局变量的使用

   ```
   var singleMode = (function(){
     // 创建私有变量
     var privateNum = 112;
     // 创建私有方法
     function privateFunc(){},
     // 创建公有方法
     function publicMethod1(){},
     function publicMethod2(){},
     // 返回一个对象包含公有方法和属性
     return {
         publicMethod1: publicMethod1,
         publicMethod2: publicMethod2
     };
   })();
   ```

   - 以下代码援引自小黄书

   ```
   function CoolModule() {
     // 私有变量
     var something = "cool";
     var another = [1,2,3];

     function doSomething() {
       console.log( something );
     }

     function doAnother() {
       console.log( another.join(" ! "));
     }

     // 返回一个对象包含公有(特权)方法和属性
     return {
       doSomething: doSomething,
       doAnother: doAnother
     };
   }

   var foo = CoolModule();

   foo.doSomething(); // cool
   foo.doAnother(); // 1!2!3
   ```

   - 模块模式需要具备两个必要条件

     - 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)

     - 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

     - 总结模块模式的两个特点就是：调用包装了函数定义的包装函数，并且将返回值作为该模块的 API

       - 可以给将要作为公共 API 返回的对象命名，于是可以在内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值

   - 使用场景：创建一个对象时，需要进行内部初始化，同时对内部属性跟方法有访问权限限制，就需要使用模块模式了

4. **代理模式**

5. **发布-订阅模式(观察者模式)**

6. **适配器模式**

7. **策略模式**

8. **职责链模式**

# 算法相关

1. **排序对比**
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df75dc1d1a1c?imageView2/0/w/1280/h/960/ignore-error/1)
   **图片名词解释**： n: 数据规模 k:“桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存

2. **排序分类**
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df7d50eb7521?imageView2/0/w/1280/h/960/ignore-error/1)

3. **冒泡排序**：两层循环嵌套，相邻记录两两对比
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df8e57f21157?imageslim)

   ```
   function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len - 1 - i; j++) {
        //相邻元素两两对比
        if (arr[j] > arr[j+1]) {
          //通过解构完成元素交换
          [arr[j],arr[j+1]] = [arr[j+1],arr[j]]
        }
      }
    }
    return arr;
   }
   ```

4. **选择排序**：遍历自身以后的元素，最小/大元素跟自己调换位置
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df986135a5f6?imageslim)

   ```
   function selectSort(arr) {
     var len = arr.length;
     for (let i = 0; i < len - 1; i++) {
       for (let j = i; j < len; j++) {
         if (arr[i] > arr[j]) {
           [arr[i], arr[j]] = [arr[j], arr[i]];
         }
       }
     }
     return arr;
   }
   ```

5. **插入排序**：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df9f6afc4b04?imageslim)

   ```
   function insertSort(arr) {
     //外循环从1开始，默认arr[0]是有序段
     for (let i = 1; i < arr.length; i++) {
       // j = i,将arr[j]依次插入有序段中
       for (let j = i; j > 0; j--) {
         if (arr[j] < arr[j - 1]) {
           [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
         } else {
           break;
         }
       }
     }
     return arr;
   }
   ```

6. **快速排序**：找到一个数作为参考，比这个数字大的放在数字左边，比它小的放在右边； 然后分别再对左边和右变的序列做相同的操作(递归)。(在冒泡排序基础上的递归分治法。)
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfaa8bbf0e52?imageslim)

   - **注：涉及到递归的算法,一定要记得设置出口,跳出递归!**

   ```
   function quickSort(arr) {
     // 跳出递归
     if (arr.length <= 1) return arr;
     var left = [],
         right = [],
         current = arr[0];
     for (let i = 0; i < arr.length; i++) {
       if (arr[i] < current) {
         left.push(arr[i]) // 小的放在左边
       } else {
         right.push(arr[i]) // 大的放在右边
       }
     }
     return quickSort(left).concat(current, quickSort(right));
   }
   ```

   - 改进版

   ```
   function partition(arr, l, r){
     let pivot = arr[l]'
     while(l < r) {
       while(l < r && a[r] > pivot) {
         --r;
       }
       arr[l] = arr[r];
       while(l < r && arr[l] < pivot) {
         ++l;
       }
       arr[r] = arr[l];
     }
     arr[l] = pivot;
     return l;
   }

   function quickSort(arr) {
     let l = 0, r = arr.length - 1;
     if(l < r) {
       let pivot = partition(arr, l, r);
       quickSort(arr, l, pivot - 1);
       quickSort(arr, pivot + 1, r);
     }
     return arr;
   }
   ```

7. **希尔排序**(缩小增量排序)：是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。

   思路： 希尔排序其实大体思路很简单,就是将数组(长度为 len)分成间隔为 t1 的若干数组.进行插入排序;排完后,将数组再分成间隔为 t2(逐步减小)的若干数组,进行插入排序;然后继续上述操作,直到分成间隔为 1 的数组,再进行最后一次插入排序则完成.
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfc27c806ac3?imageslim)

   ```
   function shellSort(arr){
     var len = arr.length, temp, gap = 1;
     while(gap < len/5) {//动态定义间隔序列
       gap =gap*5+1;
     }

     for (gap; gap > 0; gap = Math.floor(gap/5)) {
       for (var i = gap; i < len; i++) {
         temp = arr[i];
         for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {
           arr[j+gap] = arr[j];
         }

         arr[j+gap] = temp;
       }
     }
     return arr;
   }
   ```

8. **归并排序**：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并

   **思路**：将数组分为左和右两部分,然后继续将左右两部分继续(递归)拆分,直到拆分成单个为止;然后将拆分为最小的两个数组,进行比较,合并排成一个数组.接着继续递归比较合并.直到最后合并为一个数组.

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfd071fc35a5?imageslim)

   **步骤**：

   - 把长度为 n 的输入序列分成两个长度为 n/2 的子序列
   - 对这两个子序列分别采用归并排序
   - 将两个排序好的子序列合并成一个最终的排序序列。

   ```
   function mergeSort(arr) {
     var len = arr.length;
     if(len < 2) {
       return arr;
     }

     var middle = Math.floor(len / 2),
     left = arr.slice(0, middle),
            right = arr.slice(middle);
     return merge(mergeSort(left), mergeSort(right));
   }

   function merge(left, right){
     var result = [];
     while (left.length && right.length) {
       if (left[0] <= right[0]) {
         result.push(left.shift());
       } else {
         result.push(right.shift());
       }
     }

     while (left.length){
       result.push(left.shift());
     }

     while (right.length){
       result.push(right.shift());
     }
     return result;
   }
   ```

9. **堆排序**

10. **计数排序**

11. **桶排序**

12. **基数排序**

13. **二叉树**

    - 节点：二叉树的最小元素是节点，所以先定义一个节点

      ```
      function Node(data,left,right) {
        this.left = left;
        this.right = right;
        this.data = data;
        this.show = () => {return this.data}
      }
      ```

    - **重建二叉树**

      ```
      var buildTree = function (preorder, inorder) {
        if (!preorder.length || !inorder.length) return null;

        // 前序遍历的第一个元素为根节点
        const rootVal = preorder[0];
        const node = new TreeNode(rootVal);

        let i = 0;
        // i有两个含义，一个是根节点在中序遍历结果中的下标
        // 另一个是当前左子树的节点个数
        for (; i < inorder.length; ++i) {
          if (inorder[i] === rootVal) {
            break;
          }
        }

        // 递归处理左右子树
        node.left = buildTree(preorder.slice(1, i + 1), inorder.slice(0, i));
        node.right = buildTree(preorder.slice(i + 1), inorder.slice(i + 1));
        return node;
      };
      ```

    - **前序遍历** (根节点->左子树->右子树)

      - 递归

      ```
      function preOrder(node) {
        if(node !== null) {
          //根节点->左子树->右子树
          console.log(node.show());
          preOrder(node.left);
          preOrder(node.right);
        }
      }
      ```

      - 非递归

      ```
      function preTraverse(tree) {
        var arr = [], node = null;
        arr.unshift(tree)
        while (arr.length) {
          node = arr.shift()
          console.log(node.root)
          if (node.right) arr.unshift(node.right)
          if (node.left) arr.unshift(node.left)
        }
      }
      ```

    - **中序遍历** (左子树->根节点->右子树)

      中序遍历是以从最小到最大的顺序访 问所有节点。中序遍历的一种应用就是对树进行排序操作。

      - 递归

      ```
      function middleTraverse(node) {
        if (node === null) return;

        middleTraverse(node.left);
        console.log(node.data);
        middleTraverse(node.right);
      }
      ```

      - 非递归

      ```
      // shift() 头删
      // unshift() 头插
      function middleTraverseUnRecursion(root) {
        let arr = [], node = root;

        while (arr.length !== 0 || node !== null) {
          if (node === null) {
            node = arr.shift();
            console.log(node.data);
            node = node.right;
          } else {
            arr.unshift(node);
            node = node.left;
          }
        }
      }
      ```

    - **后序遍历**(左子树->右子树->根节点)

      - 递归

      ```
      function lastTraverse(node) {
        if (node === null) return;
        lastTraverse(node.left);
        lastTraverse(node.right);
        console.log(node.data);
      }
      ```

    - **广度优先-层序遍历**

      - 递归

      ```
      var result = [];
      var stack = [tree];
      var count = 0;
      var bfs = function () {
        var node = stack[count];
        if (node) {
          result.push(node.value);
          if (node.left) stack.push(node.left);
          if (node.right) stack.push(node.right);
          count++;
          bfs();
        }
      }
      ```

      - 非递归

      ```
      function bfs(node) {
        var result = [];
        var queue = [];
        queue.push(node);
        while (queue.length) {
          node = queue.shift();
          result.push(node.value);
          node.left && queue.push(node.left);
          node.right && queue.push(node.right);
        }
        return result;
      }
      ```

    - **反转二叉树**
      ```
      var invertTree = function (root) {
        if (root !== null) {
          [root.left, root.right] = [root.right, root.left];
          invertTree(root.left);
          invertTree(root.right);
        }
        return root;
      }
      ```

14. **数组去重**
    - 双 for 循环, splice 剔除并 i--回退
    - indexOf 等于 index
    - filter indexOf === index
    - 新数组 indexOf === index
    - 使用空对象等

# jQuery 相关

# 参考资料

> 1. https://juejin.im/post/5c64d15d6fb9a049d37f9c20#heading-4
> 2. https://mp.weixin.qq.com/s/-4QzuupsTwr2NcknN590Dg
> 3. https://mp.weixin.qq.com/s/jdDwmPfMOf4qVnwYx0a6ew
> 4. https://juejin.im/post/5e6055e6f265da5762133c89
> 5. http://www.ruanyifeng.com/blog/2017/05/websocket.html
> 6. https://cn.vuejs.org/v2/guide/
> 7. https://github.com/yukkkkkki/Front-end-Interview-questions
> 8. https://www.cnblogs.com/ainyi/p/9777841.html
> 9. https://www.jianshu.com/p/56b7302d7f7f
> 10. https://www.cnblogs.com/binguo666/p/10928907.html
> 11. https://www.cnblogs.com/staven/p/4774263.html
> 12. https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API
> 13. https://zhuanlan.zhihu.com/p/72616216
> 14. https://juejin.im/post/5c6e5803f265da2dc0065437
> 15. https://juejin.im/post/59e4c02151882578d02f4aca
> 16. https://www.cnblogs.com/harsin/p/11418615.html
> 17. https://juejin.im/post/5c72280351882562914edb61#heading-7
> 18. NicholasC.Zakas, 泽卡斯, Zakas, 李松峰, & 曹力. (2010). JavaScript 高级程序设计. 人民邮电出版社.
> 19. https://juejin.im/post/5c6f9d24e51d4511dd3fd0a2#heading-14
> 20. https://zhuanlan.zhihu.com/p/34453198?group_id=957277540147056640
> 21. https://segmentfault.com/a/1190000017184701
> 22. https://juejin.im/post/5c6c9c99f265da2d896326ae#heading-5
> 23. https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-4
> 24. https://juejin.im/post/5d0a48d86fb9a07ea803cf23#heading-0
> 25. https://juejin.im/post/59ac1c4ef265da248e75892b#heading-12
> 26. https://www.itcodemonkey.com/article/2853.html
> 27. https://juejin.im/post/5ce607a7e51d454f6f16eb3d#heading-37
> 28. https://juejin.im/post/5d1d61766fb9a07ed2248aea#heading-5
> 29. https://www.cnblogs.com/Lina-zhu/p/8891616.html
> 30. https://www.cnblogs.com/ljwk/p/7090320.html
> 31. KyleSimpson, 辛普森, 赵望野, & 梁杰. (2015). 你不知道的 JavaScript. 人民邮电出版社.
> 32. https://juejin.im/post/5ec74c6a518825430956ae65#heading-9
> 33. https://juejin.im/post/5e7c94106fb9a009a0575bc5#heading-8
> 34. https://juejin.im/post/5ec74c6a518825430956ae65#heading-14
> 35. https://juejin.im/post/5c071f68e51d451dcd3c3077
> 36. https://juejin.im/post/5c071f2ff265da6115109302
> 37. https://blog.csdn.net/eva_lu/article/details/79633044
> 38. https://www.jianshu.com/p/1b75a3623d0d
> 39. https://juejin.im/entry/59085cd10ce463006180b4fc
> 40. https://zhangguixu.github.io/2016/12/02/jsonp/
> 41. https://juejin.im/post/5cb5c40ff265da03a158210e#heading-2
> 42. http://www.imooc.com/article/281277?block_id=tuijian_wz
> 43. https://juejin.im/post/5c8efeb1e51d45614372addd#heading-38
> 44. https://blog.csdn.net/u014346301/article/details/52689558
> 45. https://blog.csdn.net/Q846169253/article/details/81841919
> 46. https://juejin.im/post/5daebfc2518825502a44602a
> 47. https://juejin.im/post/5eb6f99b5188256d46198cad
> 48. https://zhuanlan.zhihu.com/p/25070186?refer=learncoding
> 49. https://juejin.im/post/5d63a2bbe51d453c2577b7b5
