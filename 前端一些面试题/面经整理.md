# CSS 相关

1.  BFC(Block Formatting Context)块级格式化上下文
    块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。（盒子里面的子元素的样式不会影响到外面的元素）

    - 规则

      - 属于同一个 BFC 的两个相邻 Box 垂直排列
      - 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠
      - BFC 中子元素的 margin box 的左边，与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)
      - BFC 的区域不会与 float 的元素区域重叠(防止浮动文字环绕)
      - 计算 BFC 的高度时，浮动子元素也参与计算
      - 文字层不会被浮动层覆盖，环绕于周围

    - 触发条件

      - 浮动元素,float 除 none 以外的值
      - 定位元素，position（absolute,fixed）
      - display: inline-block / table-cell/table-caption
      - overflow !== visible （为 hidden/auto/scroll）

    - 应用
      - 阻止 margin 重叠
      - 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div 都位于同一个 BFC 区域之中)
      - 自适应两栏布局
      - 可以阻止元素被浮动元素覆盖

2.  清除浮动
    当父元素不给高度的时候，内部元素不浮动时会撑开, 而浮动的时候，父元素变成一条线, 造成塌陷.

    - 额外标签法：在父元素内部最后面添加一个没有高度的子元素，并使用 clear:both(不推荐)
    - 使用 ::after 伪类为父元素添加后标签
    - 使用 before 和 after 双伪元素清除浮动
    - 通过添加父元素并设置 overflow:hidden (触发 BFC)

    **overflow 原理**：该属性进行超出隐藏时需要计算盒子内所有元素的高度, 所以会隐式清除浮动

3.  Flex 弹性布局

    - flex-direction：控制元素在主副轴排列的方向

      - row：从左到右水平排列元素（默认值）
      - row-reverse: 从右向左排列元素
      - column：从上到下垂直排列元素
      - column-reverse：从下到上垂直排列元素

    - flex-wrap：控制换行(默认不换行)

      - nowrap：不拆行或不拆列
      - wrap：在必要的时候拆行或拆列
      - wrap-reverse：在必要的时候以相反的顺序拆行或拆列

    - flex-flow：是 flex-direction 与 flex-wrap 的组合简写模式

    - justify-content：元素在主轴对齐方式

      - flex-start：紧靠主轴起点
      - flex-end：紧靠主轴终点
      - center：从弹性容器中心开始
      - space-between：第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
      - space-around：每个元素两侧的间隔相等
      - space-evenly：元素间距离平均分配

    - align-items：容器中**所有元素**在交叉轴对齐方式

      - center：位于容器的中心
      - flex-start：位于容器的交叉轴开头
      - flex-end：位于容器的交叉轴结尾
      - stretch：元素被拉伸以适应容器(默认值)

    - align-self：用于控制**单个元素**在交叉轴上的排列方式

    - align-content：只适用于多行显示的弹性容器，作用是当 flex 容器在交叉轴上有多余的空间时，对元素的对齐处理

      - stretch：将空间平均分配给元素
      - flex-start：元素紧靠主轴起点
      - flex-end：元素紧靠主轴终点
      - center：元素从弹性容器中心开始
      - space-between：第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
      - space-around：每个元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍
      - space-evenly：元素间距离平均分配

    - flex-grow：将弹性盒子的可用空间，分配给弹性元素。以使用整数或小数声明

    - flex-shrink：与 flex-grow 相反 flex-shrink 是在弹性盒子装不下元素时定义的缩小值

    - flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间

    - flex：是 flex-grow、flex-shrink 、flex-basis 缩写组合。

4.  盒模型

    外边距(margin)、边框(border)、内边距(padding)、内容(content)
    两种模式

    - 标准模式: box-sizing: content-box; 宽高不包括内边距和边框
    - 怪异模式: box-sizing: border-box

5.  选择器优先级

    !important > 行内样式 > #id > .class > tag > \* > 继承 > 默认

6.  居中布局

    - 水平居中

      - 行内元素: text-align: center
      - 块级元素：margin: 0 auto
      - absolute + transform
      - flex + justify-content: center

    - 垂直居中

      - line-height: height
      - absolute + transform
      - flex + align-items: center
      - table

    - 水平垂直居中
      - absolute + transform
      - flex + justify-content + align-items

    **未知宽高的元素水平垂直居中**

    1. 通过定位和 transform 来实现(absolute + transform)

       ```
       .parent {
         width: 100%;
         height: 400px;
         background: relative;
         position: relative;
       }
       .children {
         position: absolute;
         top: 50%;
         left: 50%;
         background: red;
         transform: translate(-50%, -50%);
       }
       ```

    2. 利用 flex 布局来实现(flex + justify-content + align-items)

       ```
       .parent {
         width: 100%;
         height: 400px;
         background: #666;
         display: flex;
         align-items: center;
         justify-content: center;
       }
       .children {
         background: red;
       }
       ```

    3. 将父元素设置为 table，子元素设置为 table-cell，利用 table 属性(table + table-cell + vertical-align + text-align)

       ```
       .parent {
         display: table;
         width: 100%;
         height: 400px;
         background: #666;
       }
       .children {
         display: table-cell;
         vertical-align: middle;
         text-align: center;
         background: red;
       }
       ```

    **高度不定，宽 100%，内一 p 高不确定，如何实现垂直居中?**

    - verticle-align: middle;
    - 绝对定位 50%加 translateY(-50%)
    - 绝对定位，上下左右全 0，margin:auto

7.  网格布局(Grid)

8.  CSS 动画

    先定义 @keyframes 规则（0%，100% | from，to）

    - from 表示起始点
    - to 表示终点

    然后定义 animation，以下参数可直接写在 animation 后面

    - animation-name: 定义动画名称
    - animation-duration: 指定动画持续时长
    - animation-timing-function: 指元素根据时间的推进来改变属性值的变换速率，即动画的播放方式
      - (ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , ))
    - animation-delay: 指定元素动画开始时间
    - animation-iteration-count：指定元素播放动画的循环次数
      - (infinite | number)
    - animation-direction： 指定元素动画播放的方向。
      - normal：从 0%到 100%运行动画(向前播放)
      - reverse：从 100%到 0%运行动画
      - alternate：先从 0%到 100%，然后从 100%到 0%(先正向播放，再逆向播放)
      - alternate-reverse：先从 100%到 0%，然后从 0%到 100%(先逆向播放，再正向播放)
    - animation-play-state：控制元素动画的播放状态
      - (running | paused )
    - animation：是一个简写属性，用于设置六个动画属性
      - animation-name
      - animation-duration
      - animation-timing-function
      - animation-delay
      - animation-iteration-count
      - animation-direction

9.  link 与 @import 的区别

    - link 功能较多，可以定义 RSS，定义 Rel 等作用，而@import 只能用于加载 css
    - 当解析到 link 时，页面会同步加载所引的 css，而@import 所引用的 css 会等到页面加载完才被加载
    - @import 需要 IE5 以上才能使用
    - link 可以使用 js 动态引入，@import 不行

10. 纯 css 实现三角形

    ```
    // 宽高都给0，通过设置border来实现
    .box{
      width:0px;
      height:0px;
      border-top:50px solid rgba(0,0,0,0);
      border-right:50px solid  rgba(0,0,0,0);
      border-bottom:50px solid green;
      border-left:50px solid  rgba(0,0,0,0);
    }
    ```

11. 至少两种方式实现自适应搜索

12. CSS3 新特性

    - 选择器

      ```
      :last-child：选择元素最后一个孩子
      :first-child：选择元素第一个孩子
      :nth-child(1)：按照第几个孩子给它设置样式
      :nth-child(even)：按照偶数
      :nth-child(odd)：按照奇数
      enabled：选择匹配E的所有可用UI元素。
      :disabled：选择每个禁用的E元素
      :checked：选择每个被选中的E元素
      :not(selector)：选择非 selector 元素的每个元素
      ::selection：选择被用户选取的元素部分
      ```

      - 伪类：用于向某些选择器添加特殊的效果（没有创建新元素）
      - 伪元素：创建了 html 中不存在的元素，用于将特殊的效果添加到某些选择器

    - @Font-face：加载字体样式。还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。

    - 边框

      - border-radius(圆角)
      - border-image(边框图片)
      - box-shadow / text-shadow(阴影)

    - 背景

      - background-size：规定背景图片的尺寸
      - background-origin：规定背景图片的定位区域

    - 颜色

      - rgba(rgb 为颜色值，a 为透明度)

    - 文本

      - text-shadow：向文本添加阴影
      - text-justify：规定当 text-align 设置为 “justify” 时所使用的对齐方法
      - text-emphasis：向元素的文本应用重点标记以及重点标记的前景色
      - text-outline：规定文本的轮廓
      - text-overflow：规定当文本溢出包含元素时发生的事情
      - text-wrap：规定文本的换行规则
      - word-break：规定非中日韩文本的换行规则
      - word-wrap：允许对长的不可分割的单词进行分割并换行到下一行
      - text-decoration：文本修饰符：overline(上划线)、line-through(中划线)、underline(下划线)

    - 渐变

      - linear-gradient()：创建一个线性渐变的 "图像"。
      - radial-gradient()：用径向渐变创建 "图像"

    - 2D 转换(transform)

      - translate()：元素从其当前位置移动，根据给定的 left(x 坐标) 和 top(y 坐标) 位置参数
      - rotate()：元素顺时针旋转给定的角度。若为负值，元素将逆时针旋转。
      - scale()：元素的尺寸会增加或减少，根据给定的宽度(X 轴)和高度(Y 轴)参数，也可以一个值(宽高)
      - skew()：元素翻转给定的角度，根据给定的水平线(X 轴)和垂直线(Y 轴)参数
      - matrix()：把所有 2D 转换方法组合在一起，需要六个参数，包含数学函数，允许：旋转、缩放、移动以及倾斜元素。

    - 3D 转换

      - rotateX()：元素围绕其 X 轴以给定的度数进行旋转
      - rotateY()：元素围绕其 Y 轴以给定的度数进行旋转
      - perspective：规定 3D 元素的透视效果

    - 动画 animation

    - 过渡 transition

      - transition-property ：执行动画对应的属性
      - transition-duration：过渡动画的一个持续时间
      - transition-timing-function：在延续时间段，动画变化的速率(ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier)
      - transition-delay：延迟多久后开始动画

    - 多列布局

      - column-count: 规定元素应该被分隔的列数
      - column-gap: 规定列之间的间隔
      - column-rule: 设置列之间的宽度、样式和颜色规则

    - 用户界面

      - resize：规定是否可由用户调整元素尺寸
        如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll
      - box-sizing：
        - content-box：W3C 的标准盒模型。元素宽度 = 内容宽度 + padding + border
        - border-box：怪异盒模型。元素宽度 = 设定的宽度，padding 和 border 包括进去了
        - inherit：规定应从父元素继承 box-sizing 属性的值
      - outline-offset：对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓

    - 弹性布局 flex
    - 栅格布局 Grid

    - 滤镜 Filter

# DOM 相关

1. 事件流

2. 事件委托(代理)

3. Event 对象

4. 手写 EventEmitter(发布订阅模式--简单版)

5. 如何阻止事件冒泡和默认事件
   - 阻止冒泡：stopPropagation()
     - ie8 以下：设置事件对象的 cancelBubble 属性为 true
   - 阻止默认事件：preventDefault()
     - ie：设置事件对象的 returnValue 属性为 false

# BOM 相关

# HTML 相关

1. 语义化

   - 去掉或者丢失样式的时候能够让页面呈现出清晰的结构
   - 有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
   - 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
   - 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。

2. H5 新特性

   - 语义标签

     - \<header>, \<footer> , \<nav>, \<section>, \ <article>, \<aside>, \<details>, \<summary>, \ <dialog>, \<figure>, \<main>, \<mark>, \<time>

   - 增强型表单

     表单元素：

     - \<datalist> 用户会在他们输入数据时看到域定义选项的下拉列表
     - \<progress> 进度条，展示连接/下载进度
     - \<meter> 刻度值，用于某些计量，例如温度、重量等
     - \<keygen> 提供一种验证用户的可靠方法
     - \<output> 用于不同类型的输出

     表单属性：

     - placehoder 输入框默认提示文字
     - required 要求输入的内容是否可为空
     - pattern 描述一个正则表达式验证输入的值
     - min/max 设置元素最小/最大值
     - step 为输入域规定合法的数字间隔
     - height/wdith 用于 image 类型<input>标签图像高度/宽度
     - autofocus 规定在页面加载时，域自动获得焦点
     - multiple 规定<input>元素中可选择多个值

   - 音频和视频

     - \<audio>
     - \<video>

   - Canvas 绘图
   - SVG 绘图
   - 地理定位 getCurrentPosition()
   - 拖放 API
   - Web Worker
   - WebStorage
   - WebSocket

3. Canvas 绘图

4. SVG 绘图

5. 拖放 API

   > `<div draggable="true"></div>`

   | 事件      | 产生事件的元素           | 描述                                     |
   | --------- | ------------------------ | ---------------------------------------- |
   | dragstart | 被拖放的元素             | 开始拖放操作                             |
   | drag      | 被拖放的元素             | 拖放过程中                               |
   | dragenter | 拖放过程中鼠标经过的元素 | 被拖放的元素开始进入本元素的范围内       |
   | dragover  | 拖放过程中鼠标经过的元素 | 被拖放的元素正在本元素的范围内移动       |
   | dragleave | 拖放过程中鼠标经过的元素 | 被拖放的元素离开本元素的范围             |
   | drop      | 拖放的目标元素           | 有其他元素被拖放到本元素中               |
   | dragend   | 拖放的对象元素           | 拖放操作结束                             |
   | dragexit  | 拖放的对象元素           | 当元素变得不再是拖动操作的选中目标时触发 |

# JavaScript 相关

1. JavaScript 数据类型
   基本数据类型：

   - undefined
   - null
   - boolean
   - number
   - string

   复杂数据类型：

   - object

2. typeof 和 instanceof 原理

   - typeof 原理：不同的对象在底层都表示为二进制，在 Javascript 中二进制前（低）三位存储其类型信息。

     - 000: 对象
     - 010: 浮点数
     - 100：字符串
     - 110： 布尔
     - 1： 整数

     所以 typeof null === object

   - instanceof 原理：用来比较一个对象是否为某一个构造函数的实例。(注：只能用于对象，不适用原始类型的值。)

     即，能在实例的**原型对象链**中找到该构造函数的 **prototype**属性所指向的**原型对象**，就返回**true**。(看一下原型链)

     **instanceof 的语法：**

     ```
     object instanceof constructor
     // 等同于
     constructor.prototype.isPrototypeOf(object)
     ```

     **instanceof 的代码实现**

     ```
     function instanceof(L, R) { //L是表达式左边，R是表达式右边
       const O = R.prototype;
       L = L.__proto__;
       while(true) {
           if (L === null)
               return false;
           if (L === O) // 这里重点：当 L 严格等于 0 时，返回 true
               return true;
           L = L.__proto__;
       }
     }
     ```

     **instanceof 原理**：检测 constructor.prototype 是否存在于参数 object 的 原型链上。instanceof 查找的过程中会遍历 object 的原型链，直到找到 constructor 的 prototype ,如果查找失败，则会返回 false，告诉我们，object 并非是 constructor 的实例

3. new 运算符的执行过程

   - 创建(/构造)一个全新的对象
   - 新对象链接到该函数的\[\[prototype\]\]原型
   - 新对象绑定函数调用的 this: apply(属性和方法被加入到对象中)
   - 返回新对象(如果构造函数有自己 retrun 时，则返回该值)

     ```
     var obj  = {};
     obj.__proto__ = Base.prototype;
     Base.call(obj);
     ```

4. for-in 和 for-of 的区别

5. 创建对象方式

6. 继承

7. 原型链

8. 闭包

9. 防抖和节流(性能和优化)

10. call()、apply()、bind()的区别

11. 深拷贝和浅拷贝

12. js 的垃圾回收机制

13. js 事件循环机制

# ES6 相关

1. let、const

2. 箭头函数

3. 解构赋值

4. 数组新增方法

   - Array.of()
   - Array.from()
   - find()
   - findIndex()
   - fill()
   - copyWithin()
   - map()
   - reduce()

5. Generator

6. Promise

   **手写 promise 实现**

   ```
   var myPromise = new Promise((resolve, reject) => {
   // 需要执行的代码
   ...
   if (/* 异步执行成功 */) {
    resolve(value)
   } else if (/* 异步执行失败 */) {
    reject(error)
   }
   });
   myPromise.then((value) => {
     // 成功后调用, 使用 value 值
   }, (error) => {
     // 失败后调用, 获取错误信息 error
   })
   ```

   **Promise 优缺点**

# 浏览器相关

1. 跨标签页通讯

   本质原理就是去运用一些可以 共享的中间介质

   - 通过父页面 window.open()和子页面 postMessage
   - 设置同域下共享的 localStorage 与监听 window.onstorage
     - 父标签页使用 localStorage.setItem(key,value)添加（修改、删除）内容
     - 子标签页监听 storage 事件
   - 设置共享 cookie 与不断轮询检查(setInterval)
   - 借助服务端或者中间层实现

2. 从输入 URL 到展示的过程

   - 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP
   - TCP 三次握手
   - 向服务器发起请求，分析 url，设置请求报文(头，主体)
   - 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）
   - 浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构
     - HTML parser --> DOM Tree
     - CSS parser --> Style Tree(样式树)
     - attachment --> Render Tree(渲染树)
     - layout: 布局
     - GPU painting: 像素绘制页面
     - 载入解析到的资源文件，渲染页面，完成

3. 存储(localStorage、sessionStorage、cookie)

4. 重绘和回流

5. 浏览器架构

6. 浏览器下事件循环(Event Loop)

7. Web Worker

   现代浏览器为 JavaScript 创造的 多线程环境。
   可以新建并将部分任务分配到 worker 线程并行运行，两个线程可**独立运行，互不干扰**，可通过自带的**消息机制**相互通信。

   - postMessage //向 worker 发送数据
   - onmessage //接收 worker 传过来的数据函数

   **基本用法**

   ```
   // 创建 worker
   const worker = new Worker('work.js');

   // 向主进程推送消息
   worker.postMessage('Hello World');

   // 监听主进程来的消息
   worker.onmessage = function (event) {
     console.log('Received message ' + event.data);
   }
   ```

   **限制**

   - 同源限制
   - 无法使用 document / window / alert / confirm
   - 无法加载本地资源

8. 内存泄露

# 服务端与网络相关

1. http 和 https

2. TCP 和 UDP 协议

3. http 状态码
   常见状态码

- 1xx: 接受，继续处理
- 200: 成功，并返回数据
- 201: 已创建
- 202: 已接受
- 203: 成功，但未授权
- 204: 成功，无内容
- 205: 成功，重置内容
- 206: 成功，部分内容
- 301: 永久移动，重定向
- 302: 临时移动，可使用原有 URI
- 304: 资源未修改，可使用缓存
- 305: 需代理访问
- 400: 请求语法错误
- 401: 要求身份认证
- 403: 拒绝请求
- 404: 资源不存在
- 500: 服务器错误

4. WebSocket

特点：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的**双向平等对话**，属于服务器推送技术的一种。(不受同源政策影响)

- 其他特点:

  - 建立在 TCP 协议之上，服务器端的实现比较容易
  - 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器
  - 数据格式比较轻量，性能开销小，通信高效
  - 可以发送文本，也可以发送二进制数据
  - 没有同源限制，客户端可以与任意服务器通信
  - 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL

- 新建 WebSocket 实例：var ws = new WebSocket(url)
- 指定连接成功后的回调函数：**ws.onopen** = fn
- 指定连接关闭后的回调函数：**ws.onclose** = fn
- 指定收到服务器数据后的回调函数：**ws.onmessage** = fn
- 向服务器发送数据：**ws.send()**
- 指定报错时的回调函数：**ws.onerror** = fn

- webSocket.readyState
  - CONNECTING：值为 0，表示正在连接
  - OPEN：值为 1，表示连接成功，可以通信了
  - CLOSING：值为 2，表示连接正在关闭
  - CLOSED：值为 3，表示连接已经关闭，或者打开连接失败

5. Ajax

6. get 和 post

7. 跨域，同源策略，如何解决跨域问题

8. 三次握手和四次挥手

9. CSRF 和 XSS 区别及防御

10. 进程和线程的区别

# Vue 相关

1. 生命周期

- \_init\_

  - initLifecycle/Event，往 vm 上挂载各种属性
  - callHook: beforeCreated: 实例刚创建
  - initInjection/initState: 初始化注入和 data 响应性
  - created: 创建完成，属性已经绑定， 但还未生成真实 dom
  - 进行元素的挂载： $el / vm.$mount()
  - 是否有 template: 解析成 render function
    - \*.vue 文件: vue-loader 会将\<template>编译成 render function
  - beforeMount: 模板编译/挂载之前
  - 执行 render function，生成真实的 dom，并替换到 dom tree 中
  - mounted: 组件已挂载

- update:

  - 执行 diff 算法，比对改变是否需要触发 UI 更新
  - flushScheduleQueue
  - watcher.before: 触发 beforeUpdate 钩子 - watcher.run(): 执行 watcher 中的 notify，通知所有依赖项更新 UI
  - 触发 updated 钩子: 组件已更新

- actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活

- destroy:
  - beforeDestroy: 销毁开始
  - 销毁自身且递归销毁子组件以及事件监听
  - remove(): 删除节点
  - watcher.teardown(): 清空依赖
  - vm.\$off(): 解绑监听
  - destroyed: 完成后触发钩子

```

new Vue({})

// 初始化 Vue 实例
function \_init() {
// 挂载属性
initLifeCycle(vm)
// 初始化事件系统，钩子函数等
initEvent(vm)
// 编译 slot、vnode
initRender(vm)
// 触发钩子
callHook(vm, 'beforeCreate')
// 添加 inject 功能
initInjection(vm)
// 完成数据响应性 props/data/watch/computed/methods
initState(vm)
// 添加 provide 功能
initProvide(vm)
// 触发钩子
callHook(vm, 'created')

     // 挂载节点
     if (vm.$options.el) {
         vm.$mount(vm.$options.el)
     }

}

// 挂载节点实现
function mountComponent(vm) {
// 获取 render function
if (!this.options.render) {
// template to render
// Vue.compile = compileToFunctions
let { render } = compileToFunctions()
this.options.render = render
}
// 触发钩子
callHook('beforeMounte')
// 初始化观察者
// render 渲染 vdom，
vdom = vm.render()
// update: 根据 diff 出的 patchs 挂载成真实的 dom
vm.\_update(vdom)
// 触发钩子
callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
// 遍历队列中所有修改
for(){
// beforeUpdate
watcher.before()

        // 依赖局部更新节点
        watcher.update()
        callHook('updated')
    }

}

// 销毁实例实现
Vue.prototype.$destory = function() {
   // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove()
    // 删除依赖
    watcher.teardown()
    // 删除监听
    vm.$off()
// 触发钩子
callHook(vm, 'destoryed')
}

```

![image text](https://cn.vuejs.org/images/lifecycle.png?_sw-precache=b3251a15e5779fcfec925b78a149f5c8)

# webpack 相关

# 算法相关

> 参考资料
>
> 1. https://juejin.im/post/5c64d15d6fb9a049d37f9c20#heading-4
> 2. https://mp.weixin.qq.com/s/-4QzuupsTwr2NcknN590Dg
> 3. https://mp.weixin.qq.com/s/jdDwmPfMOf4qVnwYx0a6ew
> 4. https://juejin.im/post/5e6055e6f265da5762133c89
> 5. http://www.ruanyifeng.com/blog/2017/05/websocket.html
> 6. https://cn.vuejs.org/v2/guide/
> 7. https://github.com/yukkkkkki/Front-end-Interview-questions
> 8. https://www.cnblogs.com/ainyi/p/9777841.html
> 9. https://www.jianshu.com/p/56b7302d7f7f
> 10. https://www.cnblogs.com/binguo666/p/10928907.html
> 11. https://www.cnblogs.com/staven/p/4774263.html
> 12. https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API
