# CSS 相关

1.  BFC(Block Formatting Context)块级格式化上下文
    块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。（盒子里面的子元素的样式不会影响到外面的元素）

    - 规则

      - 属于同一个 BFC 的两个相邻 Box 垂直排列
      - 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠
      - BFC 中子元素的 margin box 的左边，与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)
      - BFC 的区域不会与 float 的元素区域重叠(防止浮动文字环绕)
      - 计算 BFC 的高度时，浮动子元素也参与计算
      - 文字层不会被浮动层覆盖，环绕于周围

    - 触发条件

      - 浮动元素,float 除 none 以外的值
      - 定位元素，position（absolute,fixed）
      - display: inline-block / table-cell/table-caption
      - overflow !== visible （为 hidden/auto/scroll）

    - 应用
      - 阻止 margin 重叠
      - 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div 都位于同一个 BFC 区域之中)
      - 自适应两栏布局
      - 可以阻止元素被浮动元素覆盖

2.  清除浮动
    当父元素不给高度的时候，内部元素不浮动时会撑开, 而浮动的时候，父元素变成一条线, 造成塌陷.

    - 额外标签法：在父元素内部最后面添加一个没有高度的子元素，并使用 clear:both(不推荐)
    - 使用 ::after 伪类为父元素添加后标签
    - 使用 before 和 after 双伪元素清除浮动
    - 通过添加父元素并设置 overflow:hidden (触发 BFC)

    **overflow 原理**：该属性进行超出隐藏时需要计算盒子内所有元素的高度, 所以会隐式清除浮动

3.  Flex 弹性布局

    - flex-direction：控制元素在主副轴排列的方向

      - row：从左到右水平排列元素（默认值）
      - row-reverse: 从右向左排列元素
      - column：从上到下垂直排列元素
      - column-reverse：从下到上垂直排列元素

    - flex-wrap：控制换行(默认不换行)

      - nowrap：不拆行或不拆列
      - wrap：在必要的时候拆行或拆列
      - wrap-reverse：在必要的时候以相反的顺序拆行或拆列

    - flex-flow：是 flex-direction 与 flex-wrap 的组合简写模式

    - justify-content：元素在主轴对齐方式

      - flex-start：紧靠主轴起点
      - flex-end：紧靠主轴终点
      - center：从弹性容器中心开始
      - space-between：第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
      - space-around：每个元素两侧的间隔相等
      - space-evenly：元素间距离平均分配

    - align-items：容器中**所有元素**在交叉轴对齐方式

      - center：位于容器的中心
      - flex-start：位于容器的交叉轴开头
      - flex-end：位于容器的交叉轴结尾
      - stretch：元素被拉伸以适应容器(默认值)

    - align-self：用于控制**单个元素**在交叉轴上的排列方式

    - align-content：只适用于多行显示的弹性容器，作用是当 flex 容器在交叉轴上有多余的空间时，对元素的对齐处理

      - stretch：将空间平均分配给元素
      - flex-start：元素紧靠主轴起点
      - flex-end：元素紧靠主轴终点
      - center：元素从弹性容器中心开始
      - space-between：第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
      - space-around：每个元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍
      - space-evenly：元素间距离平均分配

    - flex-grow：将弹性盒子的可用空间，分配给弹性元素。以使用整数或小数声明

    - flex-shrink：与 flex-grow 相反 flex-shrink 是在弹性盒子装不下元素时定义的缩小值

    - flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间

    - flex：是 flex-grow、flex-shrink 、flex-basis 缩写组合。

4.  盒模型

    外边距(margin)、边框(border)、内边距(padding)、内容(content)
    两种模式

    - 标准模式: box-sizing: content-box; 宽高不包括内边距和边框
    - 怪异模式: box-sizing: border-box

5.  选择器优先级

    !important > 行内样式 > #id > .class > tag > \* > 继承 > 默认

6.  居中布局

    - 水平居中

      - 行内元素: text-align: center
      - 块级元素：margin: 0 auto
      - absolute + transform
      - flex + justify-content: center

    - 垂直居中

      - line-height: height
      - absolute + transform
      - flex + align-items: center
      - table

    - 水平垂直居中
      - absolute + transform
      - flex + justify-content + align-items

    **未知宽高的元素水平垂直居中**

    1. 通过定位和 transform 来实现(absolute + transform)

       ```
       .parent {
         width: 100%;
         height: 400px;
         background: relative;
         position: relative;
       }
       .children {
         position: absolute;
         top: 50%;
         left: 50%;
         background: red;
         transform: translate(-50%, -50%);
       }
       ```

    2. 利用 flex 布局来实现(flex + justify-content + align-items)

       ```
       .parent {
         width: 100%;
         height: 400px;
         background: #666;
         display: flex;
         align-items: center;
         justify-content: center;
       }
       .children {
         background: red;
       }
       ```

    3. 将父元素设置为 table，子元素设置为 table-cell，利用 table 属性(table + table-cell + vertical-align + text-align)

       ```
       .parent {
         display: table;
         width: 100%;
         height: 400px;
         background: #666;
       }
       .children {
         display: table-cell;
         vertical-align: middle;
         text-align: center;
         background: red;
       }
       ```

    **高度不定，宽 100%，内一 p 高不确定，如何实现垂直居中?**

    - verticle-align: middle;
    - 绝对定位 50%加 translateY(-50%)
    - 绝对定位，上下左右全 0，margin:auto

7.  网格布局(Grid)

8.  CSS 动画

    先定义 @keyframes 规则（0%，100% | from，to）

    - from 表示起始点
    - to 表示终点

    然后定义 animation，以下参数可直接写在 animation 后面

    - animation-name: 定义动画名称
    - animation-duration: 指定动画持续时长
    - animation-timing-function: 指元素根据时间的推进来改变属性值的变换速率，即动画的播放方式
      - (ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , ))
    - animation-delay: 指定元素动画开始时间
    - animation-iteration-count：指定元素播放动画的循环次数
      - (infinite | number)
    - animation-direction： 指定元素动画播放的方向。
      - normal：从 0%到 100%运行动画(向前播放)
      - reverse：从 100%到 0%运行动画
      - alternate：先从 0%到 100%，然后从 100%到 0%(先正向播放，再逆向播放)
      - alternate-reverse：先从 100%到 0%，然后从 0%到 100%(先逆向播放，再正向播放)
    - animation-play-state：控制元素动画的播放状态
      - (running | paused )
    - animation：是一个简写属性，用于设置六个动画属性
      - animation-name
      - animation-duration
      - animation-timing-function
      - animation-delay
      - animation-iteration-count
      - animation-direction

9.  link 与 @import 的区别

    - link 功能较多，可以定义 RSS，定义 Rel 等作用，而@import 只能用于加载 css
    - 当解析到 link 时，页面会同步加载所引的 css，而@import 所引用的 css 会等到页面加载完才被加载
    - @import 需要 IE5 以上才能使用
    - link 可以使用 js 动态引入，@import 不行

10. 纯 css 实现三角形

    ```
    // 宽高都给0，通过设置border来实现
    .box{
      width:0px;
      height:0px;
      border-top:50px solid rgba(0,0,0,0);
      border-right:50px solid  rgba(0,0,0,0);
      border-bottom:50px solid green;
      border-left:50px solid  rgba(0,0,0,0);
    }
    ```

11. 至少两种方式实现自适应搜索

12. CSS3 新特性

    - 选择器

      ```
      :last-child：选择元素最后一个孩子
      :first-child：选择元素第一个孩子
      :nth-child(1)：按照第几个孩子给它设置样式
      :nth-child(even)：按照偶数
      :nth-child(odd)：按照奇数
      enabled：选择匹配E的所有可用UI元素。
      :disabled：选择每个禁用的E元素
      :checked：选择每个被选中的E元素
      :not(selector)：选择非 selector 元素的每个元素
      ::selection：选择被用户选取的元素部分
      ```

      - 伪类：用于向某些选择器添加特殊的效果（没有创建新元素）
      - 伪元素：创建了 html 中不存在的元素，用于将特殊的效果添加到某些选择器

    - @Font-face：加载字体样式。还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。

    - 边框

      - border-radius(圆角)
      - border-image(边框图片)
      - box-shadow / text-shadow(阴影)

    - 背景

      - background-size：规定背景图片的尺寸
      - background-origin：规定背景图片的定位区域

    - 颜色

      - rgba(rgb 为颜色值，a 为透明度)

    - 文本

      - text-shadow：向文本添加阴影
      - text-justify：规定当 text-align 设置为 “justify” 时所使用的对齐方法
      - text-emphasis：向元素的文本应用重点标记以及重点标记的前景色
      - text-outline：规定文本的轮廓
      - text-overflow：规定当文本溢出包含元素时发生的事情
      - text-wrap：规定文本的换行规则
      - word-break：规定非中日韩文本的换行规则
      - word-wrap：允许对长的不可分割的单词进行分割并换行到下一行
      - text-decoration：文本修饰符：overline(上划线)、line-through(中划线)、underline(下划线)

    - 渐变

      - linear-gradient()：创建一个线性渐变的 "图像"。
      - radial-gradient()：用径向渐变创建 "图像"

    - 2D 转换(transform)

      - translate()：元素从其当前位置移动，根据给定的 left(x 坐标) 和 top(y 坐标) 位置参数
      - rotate()：元素顺时针旋转给定的角度。若为负值，元素将逆时针旋转。
      - scale()：元素的尺寸会增加或减少，根据给定的宽度(X 轴)和高度(Y 轴)参数，也可以一个值(宽高)
      - skew()：元素翻转给定的角度，根据给定的水平线(X 轴)和垂直线(Y 轴)参数
      - matrix()：把所有 2D 转换方法组合在一起，需要六个参数，包含数学函数，允许：旋转、缩放、移动以及倾斜元素。

    - 3D 转换

      - rotateX()：元素围绕其 X 轴以给定的度数进行旋转
      - rotateY()：元素围绕其 Y 轴以给定的度数进行旋转
      - perspective：规定 3D 元素的透视效果

    - 动画 animation

    - 过渡 transition

      - transition-property ：执行动画对应的属性
      - transition-duration：过渡动画的一个持续时间
      - transition-timing-function：在延续时间段，动画变化的速率(ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier)
      - transition-delay：延迟多久后开始动画

    - 多列布局

      - column-count: 规定元素应该被分隔的列数
      - column-gap: 规定列之间的间隔
      - column-rule: 设置列之间的宽度、样式和颜色规则

    - 用户界面

      - resize：规定是否可由用户调整元素尺寸
        如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll
      - box-sizing：
        - content-box：W3C 的标准盒模型。元素宽度 = 内容宽度 + padding + border
        - border-box：怪异盒模型。元素宽度 = 设定的宽度，padding 和 border 包括进去了
        - inherit：规定应从父元素继承 box-sizing 属性的值
      - outline-offset：对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓

    - 弹性布局 flex
    - 栅格布局 Grid

    - 滤镜 Filter

# DOM 相关

1. 事件流

2. 事件委托(代理)

3. Event 对象

4. 手写 EventEmitter(发布订阅模式--简单版)

5. 如何阻止事件冒泡和默认事件
   - 阻止冒泡：stopPropagation()
     - ie8 以下：设置事件对象的 cancelBubble 属性为 true
   - 阻止默认事件：preventDefault()
     - ie：设置事件对象的 returnValue 属性为 false

# BOM 相关

# HTML 相关

1. 语义化

   - 去掉或者丢失样式的时候能够让页面呈现出清晰的结构
   - 有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
   - 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
   - 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。

2. H5 新特性

   - 语义标签

     - \<header>, \<footer> , \<nav>, \<section>, \ <article>, \<aside>, \<details>, \<summary>, \ <dialog>, \<figure>, \<main>, \<mark>, \<time>

   - 增强型表单

     表单元素：

     - \<datalist> 用户会在他们输入数据时看到域定义选项的下拉列表
     - \<progress> 进度条，展示连接/下载进度
     - \<meter> 刻度值，用于某些计量，例如温度、重量等
     - \<keygen> 提供一种验证用户的可靠方法
     - \<output> 用于不同类型的输出

     表单属性：

     - placehoder 输入框默认提示文字
     - required 要求输入的内容是否可为空
     - pattern 描述一个正则表达式验证输入的值
     - min/max 设置元素最小/最大值
     - step 为输入域规定合法的数字间隔
     - height/wdith 用于 image 类型<input>标签图像高度/宽度
     - autofocus 规定在页面加载时，域自动获得焦点
     - multiple 规定<input>元素中可选择多个值

   - 音频和视频

     - \<audio>
     - \<video>

   - Canvas 绘图
   - SVG 绘图
   - 地理定位 getCurrentPosition()
   - 拖放 API
   - Web Worker
   - WebStorage
   - WebSocket

3. Canvas 绘图

4. SVG 绘图

5. 拖放 API

   > `<div draggable="true"></div>`

   | 事件      | 产生事件的元素           | 描述                                     |
   | --------- | ------------------------ | ---------------------------------------- |
   | dragstart | 被拖放的元素             | 开始拖放操作                             |
   | drag      | 被拖放的元素             | 拖放过程中                               |
   | dragenter | 拖放过程中鼠标经过的元素 | 被拖放的元素开始进入本元素的范围内       |
   | dragover  | 拖放过程中鼠标经过的元素 | 被拖放的元素正在本元素的范围内移动       |
   | dragleave | 拖放过程中鼠标经过的元素 | 被拖放的元素离开本元素的范围             |
   | drop      | 拖放的目标元素           | 有其他元素被拖放到本元素中               |
   | dragend   | 拖放的对象元素           | 拖放操作结束                             |
   | dragexit  | 拖放的对象元素           | 当元素变得不再是拖动操作的选中目标时触发 |

# JavaScript 相关

1. JavaScript 数据类型
   基本数据类型：

   - undefined
   - null
   - boolean
   - number
   - string

   复杂数据类型：

   - object

2. typeof 和 instanceof 原理

   - typeof 原理：不同的对象在底层都表示为二进制，在 Javascript 中二进制前（低）三位存储其类型信息。

     - 000: 对象
     - 010: 浮点数
     - 100：字符串
     - 110： 布尔
     - 1： 整数

     所以 typeof null === object

   - instanceof 原理：用来比较一个对象是否为某一个构造函数的实例。(注：只能用于对象，不适用原始类型的值。)

     即，能在实例的**原型对象链**中找到该构造函数的 **prototype**属性所指向的**原型对象**，就返回**true**。(看一下原型链)

     **instanceof 的语法：**

     ```
     object instanceof constructor
     // 等同于
     constructor.prototype.isPrototypeOf(object)
     ```

     **instanceof 的代码实现**

     ```
     function instanceof(L, R) { //L是表达式左边，R是表达式右边
       const O = R.prototype;
       L = L.__proto__;
       while(true) {
           if (L === null)
               return false;
           if (L === O) // 这里重点：当 L 严格等于 0 时，返回 true
               return true;
           L = L.__proto__;
       }
     }
     ```

     **instanceof 原理**：检测 constructor.prototype 是否存在于参数 object 的 原型链上。instanceof 查找的过程中会遍历 object 的原型链，直到找到 constructor 的 prototype ,如果查找失败，则会返回 false，告诉我们，object 并非是 constructor 的实例

3. new 运算符的执行过程

   - 创建(/构造)一个全新的对象
   - 新对象链接到该函数的\[\[prototype\]\]原型
   - 新对象绑定函数调用的 this: apply(属性和方法被加入到对象中)
   - 返回新对象(如果构造函数有自己 retrun 时，则返回该值)

     ```
     var obj  = {};
     obj.__proto__ = Base.prototype;
     Base.call(obj);
     ```

4. for-in 和 for-of 的区别

5. 创建对象方式

6. 作用域

7. 作用域链

8. 原型链

   - 基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。

   - 原型链：每个构造函数都有一个 prototype 属性，指向它的原型对象，原型对象都有一个 constructor 属性，指向构造函数，而每个构造函数的实例都包含一个\_\_proto\_\_属性，指向该实例构造函数的原型对象。构造函数、原型和实例形成一个原型链，是一个用来实现继承和共享属性的对象链。

   - 属性查找机制：当访问一个对象的属性(包括方法)时，首先查找这个对象自身有没有该属性，如果没有就查找它的原型，若还没有就查找原型对象的原型，以此类推，一直找到 Object 为止，若找到就输出，若找不到就输出 null。

   - 属性修改机制：只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用`b.prototype.x = function(){...}`，但是这样会造成所有继承于该对象的实例的属性发生改变。

9. 继承

   - 原型链继承

     ```
     function SuperType() {
       this.property = true;
     }
     superType.prototype.getSuperValue = function() {
       return this.property;
     };

     function subType() {
       this.subproperty = false;
     }
     // 继承了SuperType
     SubType.prototype = new SuperType();
     SubType.prototype.getSubValue = function() {
      return this.subproperty;
     }

     var instance = new SubType();
     alert(instance.getSuperValue()); // true
     ```

     - 确定原型和实例的关系：instanceof 或者 isPrototypeOf()

     - 给原型添加方法的代码一定要放在替换原型的语句之后

     - 在通过原型链实现继承时，不能使用对象字面量创建原型
       方法，因为这样回重写原型链(原型链被切断)。

     - 原型链的问题

       - 包含引用类型值的原型属性会被所有实例共享。

       ```
       function SuperType() {
         this.colors = ["red", "blue", "green"];
       }

       function SubType() {
       }

       // 继承了SuperType
       SubType.prototype = new SuperType();

       var instance1 = new SubType();
       instance1.colors.push("black");
       alert(instance1.colors); // "red, blue, green, black"

       var instance2 = new SubType();
       alert(instance2.colors)  // "red, blue, green, black"
       ```

       - 在创建子类型的实例时，不能向超类型的构造函数中传递参数。(没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数)

   - 借用构造函数：call(), apply()

     - 在子类型构造函数的内部调用超类型构造函数

     ```
     function SuperType() {
       this.colors = ["red", "blue", "green"];
     }

     function SubType() {
       // 继承了SuperType
       SuperType.call(this);
     }

     var instance1 = new SubType();
     instance1.colors.push("black");
     alert(instance1.colors); // "red, blue, green, black"

     var instance2 = new SubType();
     alert(instance2.colors); // "red, blue, green"
     ```

     - 借用构造函数可以在子类型构造函数中向超类型构造函数传递参数

     - 借用构造函数的问题
       - 方法都在构造函数中定义，因此函数复用无从谈起
       - 在超类型的原型中定义的方法，对子类型是不可见的，结果所有类型都只能使用构造函数模式

   - 组合模式

     - 将原型链和借用构造函数结合在一起

     - 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
       - 这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的

     ```
     function SuperType(name) {
       this.name = name;
       this.colors = ["red", "blue", "green"];
     }

     SuperType.prototype.sayName = function() {
       alert(this.name);
     }

     function SubType(name, age) {
       // 继承属性
       SuperType.call(this, name); // 第二次调用
       this.age = age;
     }

     // 继承方法
     SubType.prototype = new SuperType(); // 第一次调用
     SubType.prototype.constructor = SubType;
     SubType.prototype.sayAge = function() {
       alert(this.age);
     };

     var instance1 = new SubType("Nicholas", 29);
     instance1.colors.push("black");
     alert(instance1.colors); // "red, blue, green, black"
     instance1.sayName();  // "Nicholas"
     instance1.sayAge();   // 29

     var instance2 = new SubType("Greg", 27);
     alert(instance2.colors); // "red, blue, green"
     instance1.sayName();  // "Greg"
     instance1.sayAge();   // 27
     ```

     - 问题：无论什么情况，都会调用两次超类型构造函数：
       - 在创建子类型原型的时候
       - 在子类型构造函数内部

   - 原型式继承

     - 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型

     ```
     function object(o) {
       function F() {}
       F.prototype = o;
       return new F();
     }
     ```

     - 先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。

     - Object.create()

       - Object.create(用作新对象原型的对象[, 为新对象定义额外属性的对象])
         `var p1 = Object.create(person)`

       ```
       var p2 = Object.create(person, {
         name: {
           value: "Greg"
         }
       });
       ```

   - 寄生式继承

     - 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再返回对象

     ```
     function createAnother(original) {
       var clone = object(original);  // 通过调用函数创建一个新对象
       clone.sayHi = function() {     // 以某种方式增强这个对象
         alert("hi");
       };
       return clone;                  // 返回这个对象
     }
     ```

     - 由于不能做到函数复用而降低效率

   - 寄生组合继承(最有效)

     - 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。(本质：使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型)

     ```
     function inheritPrototype(subType, superType){
       var prototype = object(superType.prototype); //创建对象
       prototype.constructor = subType; // 增强对象
       subType.prototype = prototype;   // 指定对象(将新创建的对象赋值给子类型的原型)
     }
     ```

     ```
     function SuperType(name) {
       this.name = name;
       this.colors = ["red", "blue", "green"];
     }

     SuperType.prototype.sayName = function() {
       alert(this.name);
     }

     function SubType(name, age) {
       // 继承属性
       SuperType.call(this, name);
       this.age = age;
     }

     inheritPrototype(SubType, SuperType);

     SubType.prototype.sayAge = function() {
       alert(this.age);
     };
     ```

     - 如此，便只调用一次 SuperType 构造函数，并且因此避免了在 SubType，prototype 上面创建不必要的、多余的属性。原型链也保持不变。

10. 执行上下文

11. 闭包

12. 防抖和节流(性能和优化)

13. call()、apply()、bind()的区别

14. 对象的拷贝

    - 深拷贝

    - 浅拷贝

15. js 的垃圾回收机制

16. js 事件循环机制

# ES6 相关

1. let、const

2. 箭头函数

3. 解构赋值

4. 数组新增方法

   - Array.of()
   - Array.from()
   - find()
   - findIndex()
   - fill()
   - copyWithin()
   - map()
   - reduce()

5. Generator

6. Promise

   **手写 promise 实现**

   ```
   var myPromise = new Promise((resolve, reject) => {
   // 需要执行的代码
   ...
   if (/* 异步执行成功 */) {
    resolve(value)
   } else if (/* 异步执行失败 */) {
    reject(error)
   }
   });
   myPromise.then((value) => {
     // 成功后调用, 使用 value 值
   }, (error) => {
     // 失败后调用, 获取错误信息 error
   })
   ```

   **Promise 优缺点**

# 浏览器相关

1. 跨标签页通讯

   本质原理就是去运用一些可以 共享的中间介质

   - 通过父页面 window.open()和子页面 postMessage
   - 设置同域下共享的 localStorage 与监听 window.onstorage
     - 父标签页使用 localStorage.setItem(key,value)添加（修改、删除）内容
     - 子标签页监听 storage 事件
   - 设置共享 cookie 与不断轮询检查(setInterval)
   - 借助服务端或者中间层实现

2. 从输入 URL 到展示的过程

   - 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP
   - TCP 三次握手建立连接
   - 向服务器发起 HTTP 请求，分析 url，设置请求报文(头，主体)
   - 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）
   - 浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构

     - HTML parser --> DOM Tree
     - CSS parser --> Style Tree(样式树)
     - attachment --> Render Tree(渲染树)
     - layout: 布局
     - GPU painting: 像素绘制页面
     - 载入解析到的资源文件，渲染页面

   - 当数据传送完毕，发起 TCP 四次挥手断开连接。

3. 存储(localStorage、sessionStorage、cookie)

4. 重绘和回流

5. 浏览器架构

6. 浏览器下事件循环(Event Loop)

7. Web Worker

   现代浏览器为 JavaScript 创造的 多线程环境。
   可以新建并将部分任务分配到 worker 线程并行运行，两个线程可**独立运行，互不干扰**，可通过自带的**消息机制**相互通信。

   - postMessage //向 worker 发送数据
   - onmessage //接收 worker 传过来的数据函数

   **基本用法**

   ```
   // 创建 worker
   const worker = new Worker('work.js');

   // 向主进程推送消息
   worker.postMessage('Hello World');

   // 监听主进程来的消息
   worker.onmessage = function (event) {
     console.log('Received message ' + event.data);
   }
   ```

   **限制**

   - 同源限制
   - 无法使用 document / window / alert / confirm
   - 无法加载本地资源

8. 内存泄露

9. 事件循环(Event Loop)

# 服务端与网络相关

1. http 和 https

   - http：超文本传输协议(Hyper Text Transfer Protocol)
     从 WEB 服务器传输超文本标记语言(HTML)到本地浏览器的传送协议，可以使浏览器更加高效，使网络传输减少。

     - 原理

       - 基于 TCP/IP 通信协议来传递数据，传输的数据类型为 HTML 文件, 图片文件, 查询结果等
       - 一般用于 B/S 架构。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。

     - 特点

       - **基于请求和响应**：客户端发起请求，服务端响应
       - **无状态**：协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都**不做持久化处理**。这是为了更快地处理大量事务，确保协议的可伸缩性。
       - **无连接**：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接。不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录 http 状态的技术，一个叫做 Cookie,一个叫做 Session。
         - HTTP/1.1 和部分 HTTP/1.0 的改进：**持久连接**：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。
         - **管线化**：持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应。
       - **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。
       - **灵活**：HTTP 允许传输任意类型的数据对象。传输的类型由 Content-Type 加以标记。

     - http 工作流程
       - 地址解析：解析出协议名、主机名、端口、对象路径等部分
       - 封装 HTTP 请求数据包
       - 封装成 TCP 包，建立 TCP/IP 连接(TCP/IP 三次握手)
       - 客户端向服务端发起 HTTP 请求。(例如：POST/login.html http/1.1)
         - 最后会发送一空白行，标示客户端请求完毕
       - 服务器响应
         - 服务器向客户端发送应答头信息(例如：HTTP/1.1 200 OK)
         - 之后服务端也会发送一个空白行，表示应答头信息发送完毕，接着就以 Content-type 要求的数据格式发送数据给客户端
       - 服务端关闭 TCP 连接
         - 如果服务器或者客户端在其头信息加入 Connection:keep-alive，就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接

   - https：超文本传输安全协议(Hypertext Transfer Protocol Secure)。是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。

     - 原理

       - 客户端向服务器端索要并验证公钥。
         - 这一阶段使用的是非对称加密传输(RSA)，服务端将数字证书发给客户端。其中数字证书包括：公钥和数字签名。客户端在拿到后对两者进行校验.
       - 在非对称加密传输中,两端协商生成"对话密钥"。
       - 双方采用"对话密钥"进行对称加密通信。

     - 特点

       - 优点

         - 内容加密
         - 保护数据完整性
         - 对网站服务器进行真实身份认证

       - 缺点

         - https 协议握手阶段比较费时
         - https 连接缓存不如 http 高效，会增加数据开销和功耗
         - https 连接服务器端资源占用相比于 http 高很多， 会降低用户的访问速度
           - SSL 涉及到的安全算法会消耗 CPU 资源
         - 申请 SSL 证书需要钱，功能越强大的证书费用越高
         - SSL 证书通常需要绑定 IP，不能再同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗

     - https 工作流程

       - ![image](https://pics1.baidu.com/feed/023b5bb5c9ea15ce26b853cd9cdca2f73887b284.jpeg?token=5ee5bde0022bc60fbbcfb1fe34e739b7&s=7EAC3C6259DFC0C8485CE0DB0000C0B1)

       - 客户端通过 URL 访问服务器建立 SSL 连接。
       - 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
       - 客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。
       - 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
       - 服务器利用自己的私钥解密出会话密钥。
       - 服务器利用会话密钥加密与客户端之间的通信。

   - http 和 https 的区别
     - https 协议需要到 CA 申请证书，一般免费证书很少，需要交费
     - http 信息是明文传输，会被他人截获，不安全；https 通过 SSL\TLS 进行加密，传输信息不易被截获，非常安全
     - http 使用的端口是 80，HTTPS 是 443
     - http 的连接很简单,是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全
     - 在 OSI 网络模型中，http 工作于应用层，而 https 工作在传输层

2. TCP 和 UDP 协议

3. 缓存策略: 强缓存 和 协商缓存

4. http 状态码
   常见状态码

   - 1xx: 接受，继续处理
   - 200: 成功，并返回数据
   - 201: 已创建
   - 202: 已接受
   - 203: 成功，但未授权
   - 204: 成功，无内容
   - 205: 成功，重置内容
   - 206: 成功，部分内容
   - 301: 永久移动，重定向
   - 302: 临时移动，可使用原有 URI
   - 304: 资源未修改，可使用缓存
   - 305: 需代理访问
   - 400: 请求语法错误
   - 401: 要求身份认证
   - 403: 拒绝请求
   - 404: 资源不存在
   - 500: 服务器错误

5. WebSocket

   特点：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的**双向平等对话**，属于服务器推送技术的一种。(不受同源政策影响)

   - 其他特点:

     - 建立在 TCP 协议之上，服务器端的实现比较容易
     - 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器
     - 数据格式比较轻量，性能开销小，通信高效
     - 可以发送文本，也可以发送二进制数据
     - 没有同源限制，客户端可以与任意服务器通信
     - 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL

   - 新建 WebSocket 实例：var ws = new WebSocket(url)
   - 指定连接成功后的回调函数：**ws.onopen** = fn
   - 指定连接关闭后的回调函数：**ws.onclose** = fn
   - 指定收到服务器数据后的回调函数：**ws.onmessage** = fn
   - 向服务器发送数据：**ws.send()**
   - 指定报错时的回调函数：**ws.onerror** = fn

   - webSocket.readyState
     - CONNECTING：值为 0，表示正在连接
     - OPEN：值为 1，表示连接成功，可以通信了
     - CLOSING：值为 2，表示连接正在关闭
     - CLOSED：值为 3，表示连接已经关闭，或者打开连接失败

6. Ajax

7. get 和 post

8. 跨域，同源策略，如何解决跨域问题

9. 三次握手和四次挥手

   - 三次握手(根据 IP 建立 TCP 连接)

     - 客户端和服务端互相确认可以收发数据

     - 客户端发送一个 syn 包：即带有 SYN=1，Seq=x 的数据包到服务器端口，并进入 SYN_SENT 状态，等待服务器确认；(第一次握手，由浏览器向服务器发起，告诉服务器我要发生请求了)

     - 服务器收到 syn 包，必须确认客户的 SYN，同时发回一个带 SYN=1， ACK=x+1， Seq=y 的响应包以示传达确认信息，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；（第二次握手，由服务器发起，告诉浏览器我准备好接收信息了）

     - 客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK，即回传一个带 ACK=y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发送信息了，准备接收吧）

     ![image](https://user-gold-cdn.xitu.io/2019/2/22/16914083b8093f55?imageView2/0/w/1280/h/960/format/png/ignore-error/1)

     - 为何建立连接需要三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

   - 四次挥手(关闭 TCP 连接)

     - 通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)

     ![image](https://user-gold-cdn.xitu.io/2019/2/22/169140a85c0fec37?imageView2/0/w/1280/h/960/format/png/ignore-error/1)

     - 第一次挥手：客户端向服务端发送报文，Fin、Ack、Seq，表示已经没有数据传输了，并进入 FIN_WAIT_1 状态。(浏览器发起，发送给服务器，告知服务器请求报文发送完毕，你可以准备关闭了)

     - 第二次挥手：服务端收到 FIN 后，发送响应报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(服务器发起，告诉浏览器，我请求报文接收完了，准备关闭了，你也准备吧)

     - 第三次挥手：服务端向客户端发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(服务器告诉浏览器，我响应报文发送完了，你准备关闭吧)

     - 第四次挥手：客户端收到 FIN 后向服务端发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。服务端收到客户端的报文段后关闭连接(CLOSED)，客户端等待一定时间未收到回复，则正常关闭。(浏览器发起，告诉服务器，我响应报文接收完毕了，我准备关闭了，你也准备吧。)

     - 为什么关闭连接需要四次挥手：关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。

10. CSRF 和 XSS 区别及防御

11. 进程 和 线程

# Vue 相关

1. 生命周期

   - \_init\_

     - initLifecycle/Event，往 vm 上挂载各种属性
     - callHook: beforeCreated: 实例刚创建
     - initInjection/initState: 初始化注入和 data 响应性
     - created: 创建完成，属性已经绑定， 但还未生成真实 dom
     - 进行元素的挂载： $el / vm.$mount()
     - 是否有 template: 解析成 render function
       - \*.vue 文件: vue-loader 会将\<template>编译成 render function
     - beforeMount: 模板编译/挂载之前
     - 执行 render function，生成真实的 dom，并替换到 dom tree 中
     - mounted: 组件已挂载

   - update:

     - 执行 diff 算法，比对改变是否需要触发 UI 更新
     - flushScheduleQueue
     - watcher.before: 触发 beforeUpdate 钩子 - watcher.run(): 执行 watcher 中的 notify，通知所有依赖项更新 UI
     - 触发 updated 钩子: 组件已更新

   - actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活

   - destroy:
     - beforeDestroy: 销毁开始
     - 销毁自身且递归销毁子组件以及事件监听
     - remove(): 删除节点
     - watcher.teardown(): 清空依赖
     - vm.\$off(): 解绑监听
     - destroyed: 完成后触发钩子

```

new Vue({})

// 初始化 Vue 实例
function \_init() {
// 挂载属性
initLifeCycle(vm)
// 初始化事件系统，钩子函数等
initEvent(vm)
// 编译 slot、vnode
initRender(vm)
// 触发钩子
callHook(vm, 'beforeCreate')
// 添加 inject 功能
initInjection(vm)
// 完成数据响应性 props/data/watch/computed/methods
initState(vm)
// 添加 provide 功能
initProvide(vm)
// 触发钩子
callHook(vm, 'created')

     // 挂载节点
     if (vm.$options.el) {
         vm.$mount(vm.$options.el)
     }

}

// 挂载节点实现
function mountComponent(vm) {
// 获取 render function
if (!this.options.render) {
// template to render
// Vue.compile = compileToFunctions
let { render } = compileToFunctions()
this.options.render = render
}
// 触发钩子
callHook('beforeMounte')
// 初始化观察者
// render 渲染 vdom，
vdom = vm.render()
// update: 根据 diff 出的 patchs 挂载成真实的 dom
vm.\_update(vdom)
// 触发钩子
callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
// 遍历队列中所有修改
for(){
// beforeUpdate
watcher.before()

        // 依赖局部更新节点
        watcher.update()
        callHook('updated')
    }

}

// 销毁实例实现
Vue.prototype.$destory = function() {
   // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove()
    // 删除依赖
    watcher.teardown()
    // 删除监听
    vm.$off()
// 触发钩子
callHook(vm, 'destoryed')
}

```

![image text](https://cn.vuejs.org/images/lifecycle.png?_sw-precache=b3251a15e5779fcfec925b78a149f5c8)

# webpack 相关

# 算法相关

1. 排序对比
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df75dc1d1a1c?imageView2/0/w/1280/h/960/ignore-error/1)
   **图片名词解释**： n: 数据规模 k:“桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存

2. 排序分类
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df7d50eb7521?imageView2/0/w/1280/h/960/ignore-error/1)

3. 冒泡排序：两层循环嵌套，相邻记录两两对比
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df8e57f21157?imageslim)

   ```
   function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len - 1 - i; j++) {
        //相邻元素两两对比
        if (arr[j] > arr[j+1]) {
          //通过解构完成元素交换
          [arr[j],arr[j+1]] = [arr[j+1],arr[j]]
        }
      }
    }
    return arr;
   }
   ```

4. 选择排序：遍历自身以后的元素，最小/大元素跟自己调换位置
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df986135a5f6?imageslim)

   ```
   function selectSort(arr) {
     var len = arr.length;
     for (let i = 0; i < len - 1; i++) {
       for (let j = i; j < len; j++) {
         if (arr[i] > arr[j]) {
           [arr[i], arr[j]] = [arr[j], arr[i]];
         }
       }
     }
     return arr;
   }
   ```

5. 插入排序：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df9f6afc4b04?imageslim)

   ```
   function insertSort(arr) {
     //外循环从1开始，默认arr[0]是有序段
     for (let i = 1; i < arr.length; i++) {
       // j = i,将arr[j]依次插入有序段中
       for (let j = i; j > 0; j--) {
         if (arr[j] < arr[j - 1]) {
           [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
         } else {
           break;
         }
       }
     }
     return arr;
   }
   ```

6. 快速排序：找到一个数作为参考，比这个数字大的放在数字左边，比它小的放在右边； 然后分别再对左边和右变的序列做相同的操作(递归)。(在冒泡排序基础上的递归分治法。)
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfaa8bbf0e52?imageslim)

   - **注：涉及到递归的算法,一定要记得设置出口,跳出递归!**

   ```
   function quickSort(arr) {
     // 跳出递归
     if (arr.length <= 1) return arr;
     var left = [],
         right = [],
         current = arr[0];
     for (let i = 0; i < arr.length; i++) {
       if (arr[i] < current) {
         left.push(arr[i]) // 小的放在左边
       } else {
         right.push(arr[i]) // 大的放在右边
       }
     }
     return quickSort(left).concat(current, quickSort(right));
   }
   ```

   - 改进版

   ```
   function partition(arr, l, r){
     let pivot = arr[l]'
     while(l < r) {
       while(l < r && a[r] > pivot) {
         --r;
       }
       arr[l] = arr[r];
       while(l < r && arr[l] < pivot) {
         ++l;
       }
       arr[r] = arr[l];
     }
     arr[l] = pivot;
     return l;
   }

   function quickSort(arr) {
     let l = 0, r = arr.length - 1;
     if(l < r) {
       let pivot = partition(arr, l, r);
       quickSort(arr, l, pivot - 1);
       quickSort(arr, pivot + 1, r);
     }
     return arr;
   }
   ```

7. 希尔排序(缩小增量排序)：是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。

   思路： 希尔排序其实大体思路很简单,就是将数组(长度为 len)分成间隔为 t1 的若干数组.进行插入排序;排完后,将数组再分成间隔为 t2(逐步减小)的若干数组,进行插入排序;然后继续上述操作,直到分成间隔为 1 的数组,再进行最后一次插入排序则完成.
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfc27c806ac3?imageslim)

   ```
   function shellSort(arr){
     var len = arr.length, temp, gap = 1;
     while(gap < len/5) {//动态定义间隔序列
       gap =gap*5+1;
     }

     for (gap; gap > 0; gap = Math.floor(gap/5)) {
       for (var i = gap; i < len; i++) {
         temp = arr[i];
         for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {
           arr[j+gap] = arr[j];
         }

         arr[j+gap] = temp;
       }
     }
     return arr;
   }
   ```

8. 归并排序：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并

   **思路**：将数组分为左和右两部分,然后继续将左右两部分继续(递归)拆分,直到拆分成单个为止;然后将拆分为最小的两个数组,进行比较,合并排成一个数组.接着继续递归比较合并.直到最后合并为一个数组.

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfd071fc35a5?imageslim)

   **步骤**：

   - 把长度为 n 的输入序列分成两个长度为 n/2 的子序列
   - 对这两个子序列分别采用归并排序
   - 将两个排序好的子序列合并成一个最终的排序序列。

   ```
   function mergeSort(arr) {
     var len = arr.length;
     if(len < 2) {
       return arr;
     }

     var middle = Math.floor(len / 2),
     left = arr.slice(0, middle),
            right = arr.slice(middle);
     return merge(mergeSort(left), mergeSort(right));
   }

   function merge(left, right){
     var result = [];
     while (left.length && right.length) {
       if (left[0] <= right[0]) {
         result.push(left.shift());
       } else {
         result.push(right.shift());
       }
     }

     while (left.length){
       result.push(left.shift());
     }

     while (right.length){
       result.push(right.shift());
     }
     return result;
   }
   ```

9. 堆排序

10. 计数排序

11. 桶排序

12. 基数排序

13. 二叉树

    - 节点：二叉树的最小元素是节点，所以先定义一个节点

      ```
      function Node(data,left,right) {
        this.left = left;
        this.right = right;
        this.data = data;
        this.show = () => {return this.data}
      }
      ```

    - 重建二叉树

      ```
      var buildTree = function (preorder, inorder) {
        if (!preorder.length || !inorder.length) return null;

        // 前序遍历的第一个元素为根节点
        const rootVal = preorder[0];
        const node = new TreeNode(rootVal);

        let i = 0;
        // i有两个含义，一个是根节点在中序遍历结果中的下标
        // 另一个是当前左子树的节点个数
        for (; i < inorder.length; ++i) {
          if (inorder[i] === rootVal) {
            break;
          }
        }

        // 递归处理左右子树
        node.left = buildTree(preorder.slice(1, i + 1), inorder.slice(0, i));
        node.right = buildTree(preorder.slice(i + 1), inorder.slice(i + 1));
        return node;
      };
      ```

    - 前序遍历 (根节点->左子树->右子树)

      - 递归

      ```
      function preOrder(node) {
        if(node !== null) {
          //根节点->左子树->右子树
          console.log(node.show());
          preOrder(node.left);
          preOrder(node.right);
          }
      }
      ```

      - 非递归

      ```
      function preTraverse(tree) {
        var arr = [], node = null;
        arr.unshift(tree)
        while (arr.length) {
          node = arr.shift()
          console.log(node.root)
          if (node.right) arr.unshift(node.right)
          if (node.left) arr.unshift(node.left)
        }
      }
      ```

    - 中序遍历 (左子树->根节点->右子树)

      中序遍历是以从最小到最大的顺序访 问所有节点。中序遍历的一种应用就是对树进行排序操作。

      - 递归

      ```
      function middleTraverse(node) {
        if (node === null) return;

        middleTraverse(node.left);
        console.log(node.data);
        middleTraverse(node.right);
      }
      ```

      - 非递归

      ```
      // shift() 头删
      // unshift() 头插
      function middleTraverseUnRecursion(root) {
        let arr = [], node = root;

        while (arr.length !== 0 || node !== null) {
          if (node === null) {
            node = arr.shift();
            console.log(node.data);
            node = node.right;
          } else {
            arr.unshift(node);
            node = node.left;
          }
        }
      }
      ```

    - 后序遍历(左子树->右子树->根节点)

      - 递归

      ```
      function lastTraverse(node) {
        if (node === null) return;
        lastTraverse(node.left);
        lastTraverse(node.right);
        console.log(node.data);
      }
      ```

    - 广度优先-层序遍历

      - 递归

      ```
      var result = [];
      var stack = [tree];
      var count = 0;
      var bfs = function () {
        var node = stack[count];
        if (node) {
          result.push(node.value);
          if (node.left) stack.push(node.left);
          if (node.right) stack.push(node.right);
          count++;
          bfs();
        }
      }
      ```

      - 非递归

      ```
      function bfs(node) {
        var result = [];
        var queue = [];
        queue.push(node);
        while (queue.length) {
          node = queue.shift();
          result.push(node.value);
          node.left && queue.push(node.left);
          node.right && queue.push(node.right);
        }
        return result;
      }
      ```

    - 反转二叉树
      ```
      var invertTree = function (root) {
        if (root !== null) {
          [root.left, root.right] = [root.right, root.left];
          invertTree(root.left);
          invertTree(root.right);
        }
        return root;
      }
      ```

14. 数组去重
    - 双 for 循环, splice 剔除并 i--回退
    - indexOf 等于 index
    - filter indexOf === index
    - 新数组 indexOf === index
    - 使用空对象等

# 参考资料

> 1. https://juejin.im/post/5c64d15d6fb9a049d37f9c20#heading-4
> 2. https://mp.weixin.qq.com/s/-4QzuupsTwr2NcknN590Dg
> 3. https://mp.weixin.qq.com/s/jdDwmPfMOf4qVnwYx0a6ew
> 4. https://juejin.im/post/5e6055e6f265da5762133c89
> 5. http://www.ruanyifeng.com/blog/2017/05/websocket.html
> 6. https://cn.vuejs.org/v2/guide/
> 7. https://github.com/yukkkkkki/Front-end-Interview-questions
> 8. https://www.cnblogs.com/ainyi/p/9777841.html
> 9. https://www.jianshu.com/p/56b7302d7f7f
> 10. https://www.cnblogs.com/binguo666/p/10928907.html
> 11. https://www.cnblogs.com/staven/p/4774263.html
> 12. https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API
> 13. https://zhuanlan.zhihu.com/p/72616216
> 14. https://juejin.im/post/5c6e5803f265da2dc0065437
> 15. https://juejin.im/post/59e4c02151882578d02f4aca
> 16. https://www.cnblogs.com/harsin/p/11418615.html
> 17. https://juejin.im/post/5c72280351882562914edb61#heading-7
> 18. NicholasC.Zakas, 泽卡斯, Zakas, 李松峰, & 曹力. (2010). JavaScript 高级程序设计. 人民邮电出版社.
> 19. https://juejin.im/post/5c6f9d24e51d4511dd3fd0a2#heading-14
> 20. https://zhuanlan.zhihu.com/p/34453198?group_id=957277540147056640
> 21. https://segmentfault.com/a/1190000017184701
