# CSS 相关

1. **BFC(Block Formatting Context)块级格式化上下文**
   块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。（盒子里面的子元素的样式不会影响到外面的元素）

   - 规则

     - 属于同一个 BFC 的两个相邻 Box 垂直排列
     - 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠
     - BFC 中子元素的 margin box 的左边，与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)
     - BFC 的区域不会与 float 的元素区域重叠(防止浮动文字环绕)
     - 计算 BFC 的高度时，浮动子元素也参与计算
     - 文字层不会被浮动层覆盖，环绕于周围

   - 触发条件

     - 浮动元素，float 除 none 以外的值
     - 定位元素，position（absolute,fixed）
     - display: inline-block / table-cell/table-caption
     - overflow !== visible （为 hidden/auto/scroll）

   - 应用
     - 阻止 margin 重叠
     - 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div 都位于同一个 BFC 区域之中)
     - 自适应两栏布局
     - 可以阻止元素被浮动元素覆盖

2. **盒模型**

   外边距(margin)、边框(border)、内边距(padding)、内容(content)
   两种模式

   - 标准模式: box-sizing: content-box(默认); 宽高不包括内边距和边框
   - 怪异模式: box-sizing: border-box

3. **CSS 选择器**

   - id 选择器(#myid)
   - 类选择器(.myclassname)
   - 标签选择器(div, h1, p)
   - 相邻选择器(h1 + p)
   - 子选择器(ul > li)
   - 后代选择器(li a)
   - 通配符选择器(\*)
   - 属性选择器(a\[rel=”external”])
   - 伪类选择器(a:hover, li:nth-child)

   - **选择器优先级**：!important > 行内样式 > #id > .class > tag > \* > 继承 > 默认

4. **Flex 弹性布局**

   - flex-direction：控制元素在主副轴排列的方向

     - row：从左到右水平排列元素（默认值）
     - row-reverse: 从右向左排列元素
     - column：从上到下垂直排列元素
     - column-reverse：从下到上垂直排列元素

   - flex-wrap：控制换行(默认不换行)

     - nowrap：不拆行或不拆列
     - wrap：在必要的时候拆行或拆列
     - wrap-reverse：在必要的时候以相反的顺序拆行或拆列

   - flex-flow：是 flex-direction 与 flex-wrap 的组合简写模式

   - justify-content：元素在主轴对齐方式

     - flex-start：紧靠主轴起点
     - flex-end：紧靠主轴终点
     - center：从弹性容器中心开始
     - space-between：第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
     - space-around：每个元素两侧的间隔相等
     - space-evenly：元素间距离平均分配

   - align-items：容器中**所有元素**在交叉轴对齐方式

     - center：位于容器的中心
     - flex-start：位于容器的交叉轴开头
     - flex-end：位于容器的交叉轴结尾
     - stretch：元素被拉伸以适应容器(默认值)

   - align-self：用于控制**单个元素**在交叉轴上的排列方式

   - align-content：只适用于多行显示的弹性容器，作用是当 flex 容器在交叉轴上有多余的空间时，对元素的对齐处理

     - stretch：将空间平均分配给元素
     - flex-start：元素紧靠主轴起点
     - flex-end：元素紧靠主轴终点
     - center：元素从弹性容器中心开始
     - space-between：第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间
     - space-around：每个元素两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍
     - space-evenly：元素间距离平均分配

   - flex-grow：将弹性盒子的可用空间，分配给弹性元素。以使用整数或小数声明

   - flex-shrink：与 flex-grow 相反 flex-shrink 是在弹性盒子装不下元素时定义的缩小值

   - flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间

   - flex：是 flex-grow、flex-shrink 、flex-basis 缩写组合。

5. **定位布局**

   - position:static 默认形为，参考文档流

   - position:relative 相对定位：相对于元素原来的位置控制，当元素发生位置偏移时，原位置留白

     - 相对于自己原来的位置移动
     - 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它（不脱离标准流，继续保留原来位置）

   - position:absolute 绝对定位：不受文档流影响，就像漂浮在页面中的精灵，绝对定位元素拥有行内块特性

     - 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位
     - 如果祖先元素有定位(相对、绝对、固定定位)，则以最近一级的定位祖先元素为参考点移动位置
     - 绝对定位不再占有原先的位置(脱离标准流)

   - position:fixed 固定定位：元素相对于页面固定定位在某个位置，固定定位元素不会在滚动时改变位置

     - 以浏览器的可视窗口为参照点移动元素
       - 跟父元素没有关系，不随滚动条滚动
     - 固定定位不占有原先的位置

   - position:sticky 粘性定位：相对定位和固定定位的混合

     - 以浏览器的可视窗口为参照点移动元素(固定定位特点)
     - 占有原先的位置(相对定位特点)
     - 必须添加 top、left、right、bottom 其中的一个才有效

6. **网格布局(Grid)**

7. **浮动布局**

   - float：定义元素在哪个方向浮动

     - left 向左浮动
     - right 向右浮动
     - none 不浮动

   - 元素浮动后会变为块元素，可以设置宽高

   - clear：用于清除元素浮动影响

8. **清除浮动**

   浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上

   - 浮动带来的问题：

     - 父元素的高度无法被撑开，影响与父元素同级的元素
     - 与浮动元素同级的非浮动元素（内联元素）会跟随其后
     - 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构

   - 清除浮动的方法：

     - 额外标签法：在父元素内部最后面添加一个没有高度的子元素，并使用 clear:both(不推荐)
     - 使用 ::after 伪类为父元素添加后标签
     - 使用 before 和 after 双伪元素清除浮动
     - 通过添加父元素并设置 overflow:hidden (触发 BFC)

   - **overflow 原理**：该属性进行超出隐藏时需要计算盒子内所有元素的高度, 所以会隐式清除浮动

9. **元素垂直/居中**

   - 水平居中

     - 行内元素: text-align: center
     - 块级元素：margin: 0 auto
     - absolute + transform
     - flex + justify-content: center

   - 垂直居中

     - line-height: height
     - absolute + transform
     - flex + align-items: center
     - table

   - 水平垂直居中
     - absolute + transform
     - flex + justify-content + align-items

   **未知宽高的元素水平垂直居中**

   1. 通过定位和 transform 来实现(absolute + transform)

      ```
      .parent {
        width: 100%;
        height: 400px;
        background: relative;
        position: relative;
      }
      .children {
        position: absolute;
        top: 50%;
        left: 50%;
        background: red;
        transform: translate(-50%, -50%);
      }
      ```

   2. 利用 flex 布局来实现(flex + justify-content + align-items)

      ```
      .parent {
        width: 100%;
        height: 400px;
        background: #666;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .children {
        background: red;
      }
      ```

   3. 将父元素设置为 table，子元素设置为 table-cell，利用 table 属性(table + table-cell + vertical-align + text-align)

      ```
      .parent {
        display: table;
        width: 100%;
        height: 400px;
        background: #666;
      }
      .children {
        display: table-cell;
        vertical-align: middle;
        text-align: center;
        background: red;
      }
      ```

   **高度不定，宽 100%，内一 p 高不确定，如何实现垂直居中?**

   - verticle-align: middle;
   - 绝对定位 50%加 translateY(-50%)
   - 绝对定位，上下左右全 0，margin:auto

10. **CSS 动画**

    先定义 @keyframes 规则（0%，100% | from，to）

    - from 表示起始点
    - to 表示终点

    然后定义 animation，以下参数可直接写在 animation 后面

    - animation-name: 定义动画名称
    - animation-duration: 指定动画持续时长
    - animation-timing-function: 指元素根据时间的推进来改变属性值的变换速率，即动画的播放方式
      - (ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , ))
    - animation-delay: 指定元素动画开始时间
    - animation-iteration-count：指定元素播放动画的循环次数
      - (infinite | number)
    - animation-direction： 指定元素动画播放的方向。
      - normal：从 0%到 100%运行动画(向前播放)
      - reverse：从 100%到 0%运行动画
      - alternate：先从 0%到 100%，然后从 100%到 0%(先正向播放，再逆向播放)
      - alternate-reverse：先从 100%到 0%，然后从 0%到 100%(先逆向播放，再正向播放)
    - animation-play-state：控制元素动画的播放状态
      - (running | paused )
    - animation：是一个简写属性，用于设置六个动画属性
      - animation-name
      - animation-duration
      - animation-timing-function
      - animation-delay
      - animation-iteration-count
      - animation-direction

11. **过渡延迟**

12. **link 与 @import 的区别**

    - link 功能较多，可以定义 RSS，定义 Rel 等作用，而@import 只能用于加载 css
    - 当解析到 link 时，页面会同步加载所引的 css，而@import 所引用的 css 会等到页面加载完才被加载
    - @import 需要 IE5 以上才能使用
    - link 可以使用 js 动态引入，@import 不行

13. **纯 css 实现三角形**

    ```
    // 宽高都给0，通过设置border来实现
    .box{
      width:0px;
      height:0px;
      border-top:50px solid rgba(0,0,0,0);
      border-right:50px solid  rgba(0,0,0,0);
      border-bottom:50px solid green;
      border-left:50px solid  rgba(0,0,0,0);
    }
    ```

14. **至少两种方式实现自适应搜索**

15. **CSS3 新特性**

    - 选择器

      ```
      :last-child：选择元素最后一个孩子
      :first-child：选择元素第一个孩子
      :nth-child(1)：按照第几个孩子给它设置样式
      :nth-child(even)：按照偶数
      :nth-child(odd)：按照奇数
      enabled：选择匹配E的所有可用UI元素。
      :disabled：选择每个禁用的E元素
      :checked：选择每个被选中的E元素
      :not(selector)：选择非 selector 元素的每个元素
      ::selection：选择被用户选取的元素部分
      ```

      - 伪类：用于向某些选择器添加特殊的效果（没有创建新元素）
      - 伪元素：创建了 html 中不存在的元素，用于将特殊的效果添加到某些选择器

    - @Font-face：加载字体样式。还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。

    - 边框

      - border-radius(圆角)
      - border-image(边框图片)
      - box-shadow / text-shadow(阴影)

    - 背景

      - background-size：规定背景图片的尺寸
      - background-origin：规定背景图片的定位区域

    - 颜色

      - rgba(rgb 为颜色值，a 为透明度)

    - 文本

      - text-shadow：向文本添加阴影
      - text-justify：规定当 text-align 设置为 “justify” 时所使用的对齐方法
      - text-emphasis：向元素的文本应用重点标记以及重点标记的前景色
      - text-outline：规定文本的轮廓
      - text-overflow：规定当文本溢出包含元素时发生的事情
      - text-wrap：规定文本的换行规则
      - word-break：规定非中日韩文本的换行规则
      - word-wrap：允许对长的不可分割的单词进行分割并换行到下一行
      - text-decoration：文本修饰符：overline(上划线)、line-through(中划线)、underline(下划线)

    - 渐变

      - linear-gradient()：创建一个线性渐变的 "图像"。
      - radial-gradient()：用径向渐变创建 "图像"

    - 2D 转换(transform)

      - translate()：元素从其当前位置移动，根据给定的 left(x 坐标) 和 top(y 坐标) 位置参数
      - rotate()：元素顺时针旋转给定的角度。若为负值，元素将逆时针旋转。
      - scale()：元素的尺寸会增加或减少，根据给定的宽度(X 轴)和高度(Y 轴)参数，也可以一个值(宽高)
      - skew()：元素翻转给定的角度，根据给定的水平线(X 轴)和垂直线(Y 轴)参数
      - matrix()：把所有 2D 转换方法组合在一起，需要六个参数，包含数学函数，允许：旋转、缩放、移动以及倾斜元素。

    - 3D 转换

      - rotateX()：元素围绕其 X 轴以给定的度数进行旋转
      - rotateY()：元素围绕其 Y 轴以给定的度数进行旋转
      - perspective：规定 3D 元素的透视效果

    - 动画 animation

    - 过渡 transition

      - transition-property ：执行动画对应的属性
      - transition-duration：过渡动画的一个持续时间
      - transition-timing-function：在延续时间段，动画变化的速率(ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier)
      - transition-delay：延迟多久后开始动画

    - 多列布局

      - column-count: 规定元素应该被分隔的列数
      - column-gap: 规定列之间的间隔
      - column-rule: 设置列之间的宽度、样式和颜色规则

    - 用户界面

      - resize：规定是否可由用户调整元素尺寸
        如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll
      - box-sizing：
        - content-box：W3C 的标准盒模型。元素宽度 = 内容宽度 + padding + border
        - border-box：怪异盒模型。元素宽度 = 设定的宽度，padding 和 border 包括进去了
        - inherit：规定应从父元素继承 box-sizing 属性的值
      - outline-offset：对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓

    - 弹性布局 flex
    - 栅格布局 Grid

    - 滤镜 Filter

16. **display:none 与 visibility:hidden 的区别**

    - display:none：元素不可见、**不占据空间**、资源会加载、DOM 可访问

    - visibility:hidden：元素不可见、不能点击、但**占据空间**、资源会加载，可以使用

    - 区别

      - display: none 的元素不占据任何空间，visibility: hidden 的元素空间保留

      - display: none 会影响 transition 过渡效果，visibility: hidden 不会

      - display: none 隐藏产生重绘和回流，visibility: hidden 只会触发重绘

      - display: none 的节点和子孙节点元素全都不可见，visibility: hidden 的节点的子孙节点元素可以设置 visibility: visible 显示

        - visibility: hidden 属性值具有继承性，所以子孙元素默认继承了 hidden 而隐藏，但是当子孙元素重置为 visibility: visible 就不会被隐藏

17. **可继承属性和非继承属性**

    - 常用不可继承属性

      - 宽高:height, width
      - 最小最大宽高：max-height, min-height, max-width, min-width
      - dispaly
      - 文本阴影：text-shadow
      - 背景属性：background
      - 浮动属性：float
      - 生成内容：content
      - 层级属性：z-index
      - 定位属性：position, left, right, top, bottom
      - 盒模型属性：margin, padding, border

    - 常用可继承属性

      - 字体系列属性：font-family, font-size
      - 文本系列属性：text-indent, line-height,color
      - 元素可见性：visibility
      - 表格布局属性：border-style
      - 列表布局属性：list-style, list-style-type
      - 光标属性：cursor

18. **CSS Sprites**

    - 将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background- repeat，background-position 的组合进行背景定位
    - 利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能
    - CSS Sprites 能减少图片的字节。

# DOM 相关

1. **事件流**

2. **事件委托(代理)**

3. **Event 对象**

4. **手写 EventEmitter(发布订阅模式--简单版)**

5. **如何阻止事件冒泡和默认事件**

   - 阻止冒泡：stopPropagation()
     - ie8 以下：设置事件对象的 cancelBubble 属性为 true
   - 阻止默认事件：preventDefault()
     - ie：设置事件对象的 returnValue 属性为 false

# BOM 相关

# HTML 相关

1. **语义化**

   - 去掉或者丢失样式的时候能够让页面呈现出清晰的结构
   - 有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
   - 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
   - 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。

2. **H5 新特性**

   - 语义标签

     - \<header>, \<footer> , \<nav>, \<section>, \ <article>, \<aside>, \<details>, \<summary>, \ <dialog>, \<figure>, \<main>, \<mark>, \<time>

   - 增强型表单

     表单元素：

     - \<datalist> 用户会在他们输入数据时看到域定义选项的下拉列表
     - \<progress> 进度条，展示连接/下载进度
     - \<meter> 刻度值，用于某些计量，例如温度、重量等
     - \<keygen> 提供一种验证用户的可靠方法
     - \<output> 用于不同类型的输出

     表单属性：

     - placehoder 输入框默认提示文字
     - required 要求输入的内容是否可为空
     - pattern 描述一个正则表达式验证输入的值
     - min/max 设置元素最小/最大值
     - step 为输入域规定合法的数字间隔
     - height/wdith 用于 image 类型\<input>标签图像高度/宽度
     - autofocus 规定在页面加载时，域自动获得焦点
     - multiple 规定\<input>元素中可选择多个值

   - 音频和视频

     - \<audio>
     - \<video>

   - Canvas 绘图
   - SVG 绘图
   - 地理定位 getCurrentPosition()
   - 拖放 API
   - Web Worker
   - WebStorage
   - WebSocket

3. **Canvas 绘图**

4. **SVG 绘图**

5. **拖放 API**

   > `<div draggable="true"></div>`

   | 事件      | 产生事件的元素           | 描述                                     |
   | --------- | ------------------------ | ---------------------------------------- |
   | dragstart | 被拖放的元素             | 开始拖放操作                             |
   | drag      | 被拖放的元素             | 拖放过程中                               |
   | dragenter | 拖放过程中鼠标经过的元素 | 被拖放的元素开始进入本元素的范围内       |
   | dragover  | 拖放过程中鼠标经过的元素 | 被拖放的元素正在本元素的范围内移动       |
   | dragleave | 拖放过程中鼠标经过的元素 | 被拖放的元素离开本元素的范围             |
   | drop      | 拖放的目标元素           | 有其他元素被拖放到本元素中               |
   | dragend   | 拖放的对象元素           | 拖放操作结束                             |
   | dragexit  | 拖放的对象元素           | 当元素变得不再是拖动操作的选中目标时触发 |

# JavaScript 相关

1. **JavaScript 数据类型**

   基本数据类型：

   - undefined
   - null
   - boolean
   - number
   - string

   复杂数据类型：

   - object

2. **typeof 和 instanceof 原理**

   - typeof 原理：不同的对象在底层都表示为二进制，在 Javascript 中二进制前（低）三位存储其类型信息。

     - 000: 对象
     - 010: 浮点数
     - 100：字符串
     - 110： 布尔
     - 1： 整数

     所以 typeof null === object

   - instanceof 原理：用来比较一个对象是否为某一个构造函数的实例。(注：只能用于对象，不适用原始类型的值。)

     即，能在实例的**原型对象链**中找到该构造函数的 **prototype**属性所指向的**原型对象**，就返回**true**。(看一下原型链)

     **instanceof 的语法：**

     ```
     object instanceof constructor
     // 等同于
     constructor.prototype.isPrototypeOf(object)
     ```

     **instanceof 的代码实现**

     ```
     function instanceof(L, R) { //L是表达式左边，R是表达式右边
       const O = R.prototype;
       L = L.__proto__;
       while(true) {
           if (L === null)
               return false;
           if (L === O) // 这里重点：当 L 严格等于 0 时，返回 true
               return true;
           L = L.__proto__;
       }
     }
     ```

     **instanceof 原理**：检测 constructor.prototype 是否存在于参数 object 的 原型链上。instanceof 查找的过程中会遍历 object 的原型链，直到找到 constructor 的 prototype ,如果查找失败，则会返回 false，告诉我们，object 并非是 constructor 的实例

3. **new 运算符的执行过程**

   - 创建(/构造)一个全新的对象
   - 新对象链接到该函数的\[\[prototype\]\]原型
   - 新对象绑定函数调用的 this: apply(属性和方法被加入到对象中)
   - 返回新对象(如果构造函数有自己 retrun 时，则返回该值)

     ```
     var obj  = {};
     obj.__proto__ = Base.prototype;
     Base.call(obj);
     ```

4. **for-in 和 for-of**

   - for-in：循环一个指定的变量来循环一个对象所有可枚举的属性

     ```
     for(variable in object){
       statements;
     }
     ```

     - 注：

       - 返回的除了数字索引外，还有自己自定义的属性名字
       - 通过 for-in 循环输出的属性名的顺序是不可预测的
       - 为遍历对象属性而构建，不建议与数组一起使用

     - for-in 遍历数组会出现的问题：

       - index 值 会是字符串（String）类型
       - 循环不仅会遍历数组元素，还会遍历任意其他自定义添加的属性
       - 某些情况下，会以随机顺序循环数组

   - for-of：循环可迭代对象(Array, Map, Set, arguments 等)，对值的每一个特殊属性调用一次迭代

     ```
     for(variable of object) {
       statements;
     }
     ```

   - for-in 和 for-of 的区别

     - for-in 循环遍历数组的结果是数组元素的下标

     - for-of 循环遍历数组的结果是数组元素的值

5. **遍历数组**

   - every()
   - some()
   - filter()
   - map()
   - forEach()
     - 除了抛出异常，无法中止或跳出 forEach()循环
   - reduce()
   - reduceRight()

6. **创建对象方式**

   - 工厂模式

     ```
     function createPerson(name, age, job) {
       var o = new Object();
       o.name = name;
       o.age = age;
       o.job = job;
       o.sayName = function() {
         alert(this.name);
       };
       return o;
     }
     var p1 = createPerson("nic", 29, "software engineer");
     var p2 = createPerson("greg", 27, "doctor");
     ```

     - 虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题

   - 构造函数模式

     ```
     function Person(name, age, job) {
       this.name = name;
       this.age = age;
       this.job = job;
       this.sayName = function() {
         alert(this.name);
       };
     }
     var p1 = new Person("nic", 29, "software engineer");
     var p2 = new Person("greg", 27, "doctor");
     ```

     - 构造函数的主要问题
       - 每个方法都要再每个实例上重新创建一遍(因此不同实例上的同名函数是不相等的)

   - 原型模式

     ```
     function Person(){

     }

     Person.prototype.name = "nic";
     Person.prototype.age = 29;
     Person.prototype.jon = "software engineer";
     Person.prototype.sayName = function(){
       alert(this.name);
     };

     var p1 = new Person();
     p1.sayName(); // "nic"

     var p2 = new Person();
     p2.sayName(); // "nic"

     alert(p1.sayName == p2.sayName); // true
     ```

     - hasOwnProperty()：检测一个属性是存在于实例中还是原型中。

       - 如果给定属性存在于对象实例中，才会返回 true
       - 若是原型属性，返回 false

     - in 操作符：会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中

     - hasPrototypeProperty()

       - 属性先存在于原型中，返回 true
       - 当实例重写属性后，该属性就存在于实例中了，返回 false

     - Object.keys()：接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组

     - Object.getOwnPropertyNames()：得到所有实例属性，无论是否可枚举

     - 可以用一个包含所有属性和方法的对象字面量来重写整个原型对象

     - 原型的动态性

       - 对原型对象所做的任何修改都能够立即从实例上反映出来
         - 实例中的指针仅指向原型，而不指向构造函数

     - 原型对象的问题
       - 省略了为构造函数传递初始化参数这一环节，所有实例在默认情况下都将取得相同属性值
       - 其共享的本性(原型中所有属性被很多实例共享)

   - 组合使用构造函数模式和原型模式

     - 构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性

       - 每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用
       - 支持向构造函数传递参数

     ```
     function Person(name, age, job) {
       this.name = name;
       this.age = age;
       this.job = job;
       this.friends = ["shelby", "Court"];
     }

     Person.prototype = {
       constructor : Person,
       sayName : function() {
         alert(this.name);
       }
     }

     var p1 = new Person("nic", 29, "software engineer");
     var p2 = new Person("greg", 27, "doctor");

     p1.friends.push("van");
     alert(p1.friends); // "Shelby,Court,Van"
     alert(p2.friends); // "Shelby,Court"
     alert(p1.friends === p2.friends); // false
     alert(p1.sayName === p2.sayName); // true
     ```

   - 动态原型模式

     - 把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型(仅在必要的情况下)，又保持了同时使用构造函数和原型的优点。

     ```
     function Person(name, age, job) {
       this.name = name;
       this.age = age;
       this.job = job;

       // 方法
       if(typeof this.sayName != "function") {
         Person.prototype.sayName = function() {
           alert(this.name);
         };
       }
     }

     var friend = new Person("nic", 29, "software engineer");
     friend.sayName();
     ```

     - 使用动态原型模式时不能使用对象字面量重写原型(会切断现有实例与新原型之间的联系)。

   - 寄生构造函数模式

     - 基本思想：创建一个函数，该函数的作用仅是封装创建对象的代码，然后再返回新创建的对象

     ```
     function Person(name, age, job) {
       var o = new Object();
       o.name = name;
       o.age = age;
       o.job = job;
       o.sayName = function() {
         alert(this.name);
       };
       return o;
     }

     var friend = new Person("nic", 29, "software engineer");
     friend.sayName(); // "nic"
     ```

     - 注：返回的对象与构造函数或构造函数的原型属性之间没有关系
       - 即构造函数返回的对象与构造函数外部创建的对象没有什么不同(因此不能依赖 instanceof 来确定对象类型)

   - 稳妥构造函数模式

     - 遵循与寄生构造函数类似的模式，但有两点不同

       - 新创建对象的实例方法不引用 this
       - 不适用 new 操作符调用构造函数

     ```
     function Person(name, age, job) {
       // 创建要返回的对象、
       var o = new Object();

       // 可以在这里定义私有变量和函数

       // 添加方法
       o.sayName = function() {
         alert(name);
       };

       // 返回对象
       return o;
     }
     ```

     - 使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有什么意义

7. **作用域**

8. **作用域链**

9. **原型链**

   - 基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。

   - 原型链：每个构造函数都有一个 prototype 属性，指向它的原型对象，原型对象都有一个 constructor 属性，指向构造函数，而每个构造函数的实例都包含一个\_\_proto\_\_属性，指向该实例构造函数的原型对象。构造函数、原型和实例形成一个原型链，是一个用来实现继承和共享属性的对象链。

   - 属性查找机制：当访问一个对象的属性(包括方法)时，首先查找这个对象自身有没有该属性，如果没有就查找它的原型，若还没有就查找原型对象的原型，以此类推，一直找到 Object 为止，若找到就输出，若找不到就输出 null。

   - 属性修改机制：只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用`b.prototype.x = function(){...}`，但是这样会造成所有继承于该对象的实例的属性发生改变。

10. **继承**

    - 原型链继承

      ```
      function SuperType() {
        this.property = true;
      }
      superType.prototype.getSuperValue = function() {
        return this.property;
      };

      function subType() {
        this.subproperty = false;
      }
      // 继承了SuperType
      SubType.prototype = new SuperType();
      SubType.prototype.getSubValue = function() {
       return this.subproperty;
      }

      var instance = new SubType();
      alert(instance.getSuperValue()); // true
      ```

      - 确定原型和实例的关系：instanceof 或者 isPrototypeOf()

      - 给原型添加方法的代码一定要放在替换原型的语句之后

      - 在通过原型链实现继承时，不能使用对象字面量创建原型
        方法，因为这样回重写原型链(原型链被切断)。

      - 原型链的问题

        - 包含引用类型值的原型属性会被所有实例共享。

        ```
        function SuperType() {
          this.colors = ["red", "blue", "green"];
        }

        function SubType() {
        }

        // 继承了SuperType
        SubType.prototype = new SuperType();

        var instance1 = new SubType();
        instance1.colors.push("black");
        alert(instance1.colors); // "red, blue, green, black"

        var instance2 = new SubType();
        alert(instance2.colors)  // "red, blue, green, black"
        ```

        - 在创建子类型的实例时，不能向超类型的构造函数中传递参数。(没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数)

    - 借用构造函数：call(), apply()

      - 在子类型构造函数的内部调用超类型构造函数

      ```
      function SuperType() {
        this.colors = ["red", "blue", "green"];
      }

      function SubType() {
        // 继承了SuperType
        SuperType.call(this);
      }

      var instance1 = new SubType();
      instance1.colors.push("black");
      alert(instance1.colors); // "red, blue, green, black"

      var instance2 = new SubType();
      alert(instance2.colors); // "red, blue, green"
      ```

      - 借用构造函数可以在子类型构造函数中向超类型构造函数传递参数

      - 借用构造函数的问题
        - 方法都在构造函数中定义，因此函数复用无从谈起
        - 在超类型的原型中定义的方法，对子类型是不可见的，结果所有类型都只能使用构造函数模式

    - 组合模式

      - 将原型链和借用构造函数结合在一起

      - 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
        - 这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的

      ```
      function SuperType(name) {
        this.name = name;
        this.colors = ["red", "blue", "green"];
      }

      SuperType.prototype.sayName = function() {
        alert(this.name);
      }

      function SubType(name, age) {
        // 继承属性
        SuperType.call(this, name); // 第二次调用
        this.age = age;
      }

      // 继承方法
      SubType.prototype = new SuperType(); // 第一次调用
      SubType.prototype.constructor = SubType;
      SubType.prototype.sayAge = function() {
        alert(this.age);
      };

      var instance1 = new SubType("Nicholas", 29);
      instance1.colors.push("black");
      alert(instance1.colors); // "red, blue, green, black"
      instance1.sayName();  // "Nicholas"
      instance1.sayAge();   // 29

      var instance2 = new SubType("Greg", 27);
      alert(instance2.colors); // "red, blue, green"
      instance1.sayName();  // "Greg"
      instance1.sayAge();   // 27
      ```

      - 问题：无论什么情况，都会调用两次超类型构造函数：
        - 在创建子类型原型的时候
        - 在子类型构造函数内部

    - 原型式继承

      - 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型

      ```
      function object(o) {
        function F() {}
        F.prototype = o;
        return new F();
      }
      ```

      - 先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。

      - Object.create()

        - Object.create(用作新对象原型的对象[, 为新对象定义额外属性的对象])
          `var p1 = Object.create(person)`

        ```
        var p2 = Object.create(person, {
          name: {
            value: "Greg"
          }
        });
        ```

    - 寄生式继承

      - 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再返回对象

      ```
      function createAnother(original) {
        var clone = object(original);  // 通过调用函数创建一个新对象
        clone.sayHi = function() {     // 以某种方式增强这个对象
          alert("hi");
        };
        return clone;                  // 返回这个对象
      }
      ```

      - 由于不能做到函数复用而降低效率

    - 寄生组合继承(最有效)

      - 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。(本质：使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型)

      ```
      function inheritPrototype(subType, superType){
        var prototype = object(superType.prototype); //创建对象
        prototype.constructor = subType; // 增强对象
        subType.prototype = prototype;   // 指定对象(将新创建的对象赋值给子类型的原型)
      }
      ```

      ```
      function SuperType(name) {
        this.name = name;
        this.colors = ["red", "blue", "green"];
      }

      SuperType.prototype.sayName = function() {
        alert(this.name);
      }

      function SubType(name, age) {
        // 继承属性
        SuperType.call(this, name);
        this.age = age;
      }

      inheritPrototype(SubType, SuperType);

      SubType.prototype.sayAge = function() {
        alert(this.age);
      };
      ```

      - 如此，便只调用一次 SuperType 构造函数，并且因此避免了在 SubType，prototype 上面创建不必要的、多余的属性。原型链也保持不变。

11. **执行上下文**

12. **闭包**

13. **防抖和节流(性能和优化)**

14. **call()、apply()、bind()的区别**

15. **对象的拷贝**

    - ECMAScript 的数据类型

      - 基本数据类型(undefined，boolean，number，string，null)

        - 一般存放于内存中的**栈**区，存取速度快，存放量小

        - 基本数据类型值不可变(操作基本数据类型的方法看上去返回了一个修改后的值，实际上返回的是一个新值)

      - 引用类型(Object,Array,Function)

        - 一般存放与内存中的**堆**区，存取速度慢，存放量大，其引用指针存于栈区，并指向引用本身

    - 浅拷贝：两个 js 对象指向同一个内存地址，其中一个改变会影响另一个

      - 简单的赋值操作(=)

      - Object.assign()：把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。拷贝的是对象的属性的引用，而不是对象本身

      - \$.extend({},obj)：使用递归思路实现了浅拷贝和深拷贝，第一个参数类型为 Boolean，当为 false 的时候必须省略不写则是浅拷贝，当为 true 的时候为深拷贝

    - 深拷贝：复制后的新对象重新指向一个新的内存地址，两个对象改变互不影响

      - 简单深拷贝

        - 手动的赋值操作

          ```
          var obj = { a: 10, b: 20};
          var newObj = { a: obj.a, b: obj.b};
          newObj.b = 100;
          console.log(obj);    // { a: 10, b: 20}
          console.log(newObj); // { a: 10, b: 100};
          console.log(obj == newObj);    //  false
          console.log(obj === newObj);   //  false
          ```

        - Object.assign()
          ```
          var obj = { a: {a: "hello"}, b: 33 };
          var newObj = Object.assign({}, obj);
          newObj.b = 100;
          console.log(obj);    //  { a: "hello", b: 33 };
          console.log(newObj); //  { a: "hello", b: 100 };
          console.log(obj==newObj);   //  false
          console.log(obj===newObj);  //  false
          ```

      - 复杂深拷贝

        - JSON.parse(JSON.stringify(obj)): 性能最快

          - 具有循环引用的对象时，报错
          - 当值为正则表达式、函数、undefined、或 symbol 时，无法拷贝
          - 会抛弃对象的 constructor(也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成 Object)

        - \$.extend(true,{},obj)：使用递归思路可以实现深拷贝，要求第一个参数必须为 true

          ```
          var obj = { a: {a: "hello"}, b: 33 };
          var newObj = $.extend(true, {}, obj);
          newObj.a.a = "hello world";
          console.log(obj);    //  { a: "hello", b: 33 };
          console.log(newObj); //  { a: "hello world", b: 33 };
          console.log(obj==newObj);   //  false
          console.log(obj===newObj);  //  false
          ```

        - Loadsh.cloneDeep()

        - Array 的 slice()和 concat()

        - 自己实现一个简单的深拷贝 deepClone()

          ```
          function deepClone(obj){
            if(typeof obj !== "object") return;
            let newObj = obj instanceof Array ? [] : {};
            for(let key in obj){
              if(obj.hasOwnProperty(key)){
                newObj[key] = typeof obj[key] === "object" ? deepClone(obj[key]) : obj[key];
              }
            }

            return newObj;
          }
          let obj = {a: 11, b: function(){}, c: {d: 22}};
          deepClone(obj);  // {a: 11, b: f(), c: {d: 22}};
          ```

16. **js 的垃圾回收机制**

17. **js 事件循环机制**

# ES6 相关

1. **let、const**

2. **箭头函数**

3. **解构赋值**

4. **数组新增方法**

   - Array.of()
   - Array.from()
   - find()
   - findIndex()
   - fill()
   - copyWithin()
   - map()
   - reduce()
   - entries()
   - values()
   - keys()

5. **对象新增方法**

   - Object.is()
   - Object.getOwnPropertySymbols()
   - Object.setPrototypeOf()
   - Object.assign()

6. **Number 新增方法**

   - Number.isNaN()
   - Number.isFinite()

7. **字符串新增方法**

   - String.raw()
   - repeat()
   - startsWith()
   - endsWith()
   - includes()

8. **Map()**

9. **Set()**

10. **Symbol**

11. **Generator**

12. **Promise**

    **手写 promise 实现**

    ```
    var myPromise = new Promise((resolve, reject) => {
    // 需要执行的代码
    ...
    if (/* 异步执行成功 */) {
     resolve(value)
    } else if (/* 异步执行失败 */) {
     reject(error)
    }
    });
    myPromise.then((value) => {
      // 成功后调用, 使用 value 值
    }, (error) => {
      // 失败后调用, 获取错误信息 error
    })
    ```

    **Promise 优缺点**

# 浏览器相关

1. **跨标签页通讯**

   本质原理就是去运用一些可以 共享的中间介质

   - 通过父页面 window.open()和子页面 postMessage
   - 设置同域下共享的 localStorage 与监听 window.onstorage
     - 父标签页使用 localStorage.setItem(key,value)添加（修改、删除）内容
     - 子标签页监听 storage 事件
   - 设置共享 cookie 与不断轮询检查(setInterval)
   - 借助服务端或者中间层实现

2. **从输入 URL 到展示的过程**

   - 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP
   - TCP 三次握手建立连接
   - 向服务器发起 HTTP 请求，分析 url，设置请求报文(头，主体)
   - 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）
   - 浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构

     - HTML parser --> DOM Tree
     - CSS parser --> Style Tree(样式树)
     - attachment --> Render Tree(渲染树)
     - layout: 布局
     - GPU painting: 像素绘制页面
     - 载入解析到的资源文件，渲染页面

   - 当数据传送完毕，发起 TCP 四次挥手断开连接。

3. **存储(localStorage、sessionStorage、cookie)**

4. **重绘和回流**

5. **浏览器架构**

6. **浏览器下事件循环(Event Loop)**

7. **Web Worker**

   现代浏览器为 JavaScript 创造的 多线程环境。
   可以新建并将部分任务分配到 worker 线程并行运行，两个线程可**独立运行，互不干扰**，可通过自带的**消息机制**相互通信。

   - postMessage //向 worker 发送数据
   - onmessage //接收 worker 传过来的数据函数

   **基本用法**

   ```
   // 创建 worker
   const worker = new Worker('work.js');

   // 向主进程推送消息
   worker.postMessage('Hello World');

   // 监听主进程来的消息
   worker.onmessage = function (event) {
     console.log('Received message ' + event.data);
   }
   ```

   **限制**

   - 同源限制
   - 无法使用 document / window / alert / confirm
   - 无法加载本地资源

8. **内存泄露**

# 服务端与网络相关

1. **http 和 https**

   - http：超文本传输协议(Hyper Text Transfer Protocol)
     从 WEB 服务器传输超文本标记语言(HTML)到本地浏览器的传送协议，可以使浏览器更加高效，使网络传输减少。

     - 原理

       - 基于 TCP/IP 通信协议来传递数据，传输的数据类型为 HTML 文件, 图片文件, 查询结果等
       - 一般用于 B/S 架构。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。

     - 特点

       - **基于请求和响应**：客户端发起请求，服务端响应
       - **无状态**：协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都**不做持久化处理**。这是为了更快地处理大量事务，确保协议的可伸缩性。
       - **无连接**：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接。不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录 http 状态的技术，一个叫做 Cookie,一个叫做 Session。
         - HTTP/1.1 和部分 HTTP/1.0 的改进：**持久连接**：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。
         - **管线化**：持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应。
       - **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。
       - **灵活**：HTTP 允许传输任意类型的数据对象。传输的类型由 Content-Type 加以标记。

     - http 工作流程
       - 地址解析：解析出协议名、主机名、端口、对象路径等部分
       - 封装 HTTP 请求数据包
       - 封装成 TCP 包，建立 TCP/IP 连接(TCP/IP 三次握手)
       - 客户端向服务端发起 HTTP 请求。(例如：POST/login.html http/1.1)
         - 最后会发送一空白行，标示客户端请求完毕
       - 服务器响应
         - 服务器向客户端发送应答头信息(例如：HTTP/1.1 200 OK)
         - 之后服务端也会发送一个空白行，表示应答头信息发送完毕，接着就以 Content-type 要求的数据格式发送数据给客户端
       - 服务端关闭 TCP 连接
         - 如果服务器或者客户端在其头信息加入 Connection:keep-alive，就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接

   - https：超文本传输安全协议(Hypertext Transfer Protocol Secure)。是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。

     - 原理

       - 客户端向服务器端索要并验证公钥。
         - 这一阶段使用的是非对称加密传输(RSA)，服务端将数字证书发给客户端。其中数字证书包括：公钥和数字签名。客户端在拿到后对两者进行校验.
       - 在非对称加密传输中,两端协商生成"对话密钥"。
       - 双方采用"对话密钥"进行对称加密通信。

     - 特点

       - 优点

         - 内容加密
         - 保护数据完整性
         - 对网站服务器进行真实身份认证

       - 缺点

         - https 协议握手阶段比较费时
         - https 连接缓存不如 http 高效，会增加数据开销和功耗
         - https 连接服务器端资源占用相比于 http 高很多， 会降低用户的访问速度
           - SSL 涉及到的安全算法会消耗 CPU 资源
         - 申请 SSL 证书需要钱，功能越强大的证书费用越高
         - SSL 证书通常需要绑定 IP，不能再同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗

     - https 工作流程

       - ![image](https://pics1.baidu.com/feed/023b5bb5c9ea15ce26b853cd9cdca2f73887b284.jpeg?token=5ee5bde0022bc60fbbcfb1fe34e739b7&s=7EAC3C6259DFC0C8485CE0DB0000C0B1)

       - 客户端通过 URL 访问服务器建立 SSL 连接。
       - 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
       - 客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。
       - 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
       - 服务器利用自己的私钥解密出会话密钥。
       - 服务器利用会话密钥加密与客户端之间的通信。

   - http 和 https 的区别
     - https 协议需要到 CA 申请证书，一般免费证书很少，需要交费
     - http 信息是明文传输，会被他人截获，不安全；https 通过 SSL\TLS 进行加密，传输信息不易被截获，非常安全
     - http 使用的端口是 80，HTTPS 是 443
     - http 的连接很简单,是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全
     - 在 OSI 网络模型中，http 工作于应用层，而 https 工作在传输层

2. **TCP 和 UDP 协议**

3. **缓存策略: 强缓存 和 协商缓存**

   - 缓存：是一种保存资源副本并在下次请求时直接使用该副本的技术。浏览器缓存就是浏览器请求网站留下的资源副本.

   - 缓存的好处

     - 缓解服务器压力(不用每次去请求资源)
     - 减少页面加载时间，提升性能
     - 减少带宽消耗

   - 缓存的分类

     - 宏观

       - 私有缓存: 用户专享，各级代理不能缓存
       - 共享缓存: 能够被多个用户使用的缓存,也就是那些能被各级代理的缓存

     - 微观：浏览器缓存、代理服务器缓存、网关缓存、数据库缓存

   - 浏览器缓存

     - 强缓存：Expires & Cache-Control

       - 给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期，浏览器需要重新请求

       - Expires：HTTP/1.0 中的定义缓存的字段，告知客户端资源缓存失效的绝对时间

         > `Expires: Wed Feb 20 2019 11:25:41 GMT`

         - 弊端：Expires 返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致 Expires 很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入 Cache-Control:max-age 指令的原因之一。

       - Cache-Control:max-age：HTTP/1.1 定义的关于缓存的字段，它规定了缓存过期的一个相对时间

         > `Cache-control: max-age=666`

         > `Cache-Control: no-cache` no-cache 意思是可以缓存，但每次用应该去向服务器验证缓存是否可用

       - 优先级：**Cache-Control > Expires**

       - 缺点：该缓存方式优先级高，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源(所以有了协商缓存)

     - 协商缓存：Last-Modified & Etag

       - 利用 Last-Modified，If-Modified-Since 和 ETag、If-None-Match 对资源做标识，然后由服务器做分析，如果资源未更新，则返回 304 状态码，那么浏览器则会从缓存中读取资源，否则重新请求资源

       - Last-Modified 与 If-Modified-Since

         - last-modified：资源在服务器上最后一次修改的时间
         - If-Modified-Since：上一次请求时返回的 Last-Modified 的值

         - 服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化

           - 若无变化，返回 304 Not Modified(response header 中不会再添加 Last-Modified 的 header)，不会返回资源内容

           - 若有变化，返回 200，正常返回资源内容

         - 浏览器收到 304 的响应后，就会从缓存中加载资源

         - 浏览器收到 200 的响应后，则从服务器加载新资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值

         - 缺点
           - 周期性修改，但内容未变时，会导致缓存失效
           - 以秒为单位进行更新，如果小于该单位高频进行更新的话，则不适合采用该方法，这时候协商缓存就不那么的可靠了。(所以就有了 ETag、If-None-Match)

       - Etag 与 If-None-Match

         - Etag(response 携带)：服务器根据当前请求的资源生成的一个唯一标识，是一个字符串，只要资源有变化这个标识就会不同，跟最后修改时间没有关系

         - If-None-Match：浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag 的值

         - 服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化

           - 若无变化，则返回 304 Not Modified，不会返回资源内容(由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化)

           - 若有变化，则返回 200，并正常返回资源内容

         - 浏览器收到 304 的响应后，就会从缓存中加载资源

         - 浏览器收到 200 的响应后，则从服务器加载新资源时，ETag 在重新加载时会被更新，下次请求时，If-None-Match 会启用上次返回的 ETag 值

       - ETag 相对于 Last-Modified 可更加准确地判断文件内容是否被修改，从而在实际操作中实用程度也更高；但由于需要对资源进行生成标识，性能方面势必有所牺牲

       - 强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道；协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道(协商缓存需要配合强缓存使用)

       - Last-Modified、If-Modified-Since 和 ETag、If-None-Match 一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。

         - 注：分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败

         - 分布式系统尽量关闭掉 ETag(每台机器生成的 ETag 都会不一样）

       * 优先级：**ETag 与 If-None-Match > Last-Modified 与 If-Modified-Since**, 同时存在时, 前者覆盖后者

     - 启发式缓存

       - 当请求头中确定缓存过期时间的字段一个都没有，会默认触发浏览器启发式缓存。

     - 缓存的优先级

       - 强缓存>协商缓存>启发式缓存
       - Cache-Control > Expires > ETag > Last-Modified

     - 浏览器整个缓存策略的过程：
       ![image](https://user-gold-cdn.xitu.io/2018/1/27/16137f262e0adf18?imageView2/0/w/1280/h/960/ignore-error/1)

       - 浏览器先检查 Cache-Control，如果为 no-store，则浏览器所有内容都不会缓存，强制缓存，协商缓存统统都不会触发

4. **http 状态码**

   常见状态码

   - 1xx: 接受，继续处理
   - 200: 成功，并返回数据
   - 201: 已创建
   - 202: 已接受
   - 203: 成功，但未授权
   - 204: 成功，无内容
   - 205: 成功，重置内容
   - 206: 成功，部分内容
   - 301: 永久移动，重定向
   - 302: 临时移动，可使用原有 URI
   - 304: 资源未修改，可使用缓存
   - 305: 需代理访问
   - 400: 请求语法错误
   - 401: 要求身份认证
   - 403: 拒绝请求
   - 404: 资源不存在
   - 500: 服务器错误

5. **WebSocket**

   特点：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的**双向平等对话**，属于服务器推送技术的一种。(不受同源政策影响)

   - 其他特点:

     - 建立在 TCP 协议之上，服务器端的实现比较容易
     - 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器
     - 数据格式比较轻量，性能开销小，通信高效
     - 可以发送文本，也可以发送二进制数据
     - 没有同源限制，客户端可以与任意服务器通信
     - 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL

   - 新建 WebSocket 实例：var ws = new WebSocket(url)
   - 指定连接成功后的回调函数：**ws.onopen** = fn
   - 指定连接关闭后的回调函数：**ws.onclose** = fn
   - 指定收到服务器数据后的回调函数：**ws.onmessage** = fn
   - 向服务器发送数据：**ws.send()**
   - 指定报错时的回调函数：**ws.onerror** = fn

   - webSocket.readyState
     - CONNECTING：值为 0，表示正在连接
     - OPEN：值为 1，表示连接成功，可以通信了
     - CLOSING：值为 2，表示连接正在关闭
     - CLOSED：值为 3，表示连接已经关闭，或者打开连接失败

6. **Ajax**

7. **get 和 post**

8. **跨域，同源策略，如何解决跨域问题**

9. **三次握手 和 四次挥手**

   - 三次握手(根据 IP 建立 TCP 连接)

     - 客户端和服务端互相确认可以收发数据

     - 客户端发送一个 syn 包：即带有 SYN=1，Seq=x 的数据包到服务器端口，并进入 SYN_SENT 状态，等待服务器确认；(第一次握手，由浏览器向服务器发起，告诉服务器我要发生请求了)

     - 服务器收到 syn 包，必须确认客户的 SYN，同时发回一个带 SYN=1， ACK=x+1， Seq=y 的响应包以示传达确认信息，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；（第二次握手，由服务器发起，告诉浏览器我准备好接收信息了）

     - 客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK，即回传一个带 ACK=y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发送信息了，准备接收吧）

     ![image](https://user-gold-cdn.xitu.io/2019/2/22/16914083b8093f55?imageView2/0/w/1280/h/960/format/png/ignore-error/1)

     - 为何建立连接需要三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

   - 四次挥手(关闭 TCP 连接)

     - 通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)

     ![image](https://user-gold-cdn.xitu.io/2019/2/22/169140a85c0fec37?imageView2/0/w/1280/h/960/format/png/ignore-error/1)

     - 第一次挥手：客户端向服务端发送报文，Fin、Ack、Seq，表示已经没有数据传输了，并进入 FIN_WAIT_1 状态。(浏览器发起，发送给服务器，告知服务器请求报文发送完毕，你可以准备关闭了)

     - 第二次挥手：服务端收到 FIN 后，发送响应报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(服务器发起，告诉浏览器，我请求报文接收完了，准备关闭了，你也准备吧)

     - 第三次挥手：服务端向客户端发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(服务器告诉浏览器，我响应报文发送完了，你准备关闭吧)

     - 第四次挥手：客户端收到 FIN 后向服务端发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。服务端收到客户端的报文段后关闭连接(CLOSED)，客户端等待一定时间未收到回复，则正常关闭。(浏览器发起，告诉服务器，我响应报文接收完毕了，我准备关闭了，你也准备吧。)

     - 为什么关闭连接需要四次挥手：关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。

10. **CSRF 和 XSS 区别及防御**

11. **进程 和 线程**

# Vue 相关

1. **生命周期**

   - \_init\_

     - initLifecycle/Event，往 vm 上挂载各种属性
     - callHook: beforeCreated: 实例刚创建
     - initInjection/initState: 初始化注入和 data 响应性
     - created: 创建完成，属性已经绑定， 但还未生成真实 dom
     - 进行元素的挂载： $el / vm.$mount()
     - 是否有 template: 解析成 render function
       - \*.vue 文件: vue-loader 会将\<template>编译成 render function
     - beforeMount: 模板编译/挂载之前
     - 执行 render function，生成真实的 dom，并替换到 dom tree 中
     - mounted: 组件已挂载

   - update:

     - 执行 diff 算法，比对改变是否需要触发 UI 更新
     - flushScheduleQueue
     - watcher.before: 触发 beforeUpdate 钩子 - watcher.run(): 执行 watcher 中的 notify，通知所有依赖项更新 UI
     - 触发 updated 钩子: 组件已更新

   - actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活

   - destroy:
     - beforeDestroy: 销毁开始
     - 销毁自身且递归销毁子组件以及事件监听
     - remove(): 删除节点
     - watcher.teardown(): 清空依赖
     - vm.\$off(): 解绑监听
     - destroyed: 完成后触发钩子

```

new Vue({})

// 初始化 Vue 实例
function \_init() {
// 挂载属性
initLifeCycle(vm)
// 初始化事件系统，钩子函数等
initEvent(vm)
// 编译 slot、vnode
initRender(vm)
// 触发钩子
callHook(vm, 'beforeCreate')
// 添加 inject 功能
initInjection(vm)
// 完成数据响应性 props/data/watch/computed/methods
initState(vm)
// 添加 provide 功能
initProvide(vm)
// 触发钩子
callHook(vm, 'created')

     // 挂载节点
     if (vm.$options.el) {
         vm.$mount(vm.$options.el)
     }

}

// 挂载节点实现
function mountComponent(vm) {
// 获取 render function
if (!this.options.render) {
// template to render
// Vue.compile = compileToFunctions
let { render } = compileToFunctions()
this.options.render = render
}
// 触发钩子
callHook('beforeMounte')
// 初始化观察者
// render 渲染 vdom，
vdom = vm.render()
// update: 根据 diff 出的 patchs 挂载成真实的 dom
vm.\_update(vdom)
// 触发钩子
callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
// 遍历队列中所有修改
for(){
// beforeUpdate
watcher.before()

        // 依赖局部更新节点
        watcher.update()
        callHook('updated')
    }

}

// 销毁实例实现
Vue.prototype.$destory = function() {
   // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove()
    // 删除依赖
    watcher.teardown()
    // 删除监听
    vm.$off()
// 触发钩子
callHook(vm, 'destoryed')
}

```

![image text](https://user-gold-cdn.xitu.io/2018/1/27/16137f262e0adf18?imageView2/0/w/1280/h/960/ignore-error/1)

# webpack 相关

# 算法相关

1. **排序对比**
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df75dc1d1a1c?imageView2/0/w/1280/h/960/ignore-error/1)
   **图片名词解释**： n: 数据规模 k:“桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存

2. **排序分类**
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df7d50eb7521?imageView2/0/w/1280/h/960/ignore-error/1)

3. **冒泡排序**：两层循环嵌套，相邻记录两两对比
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df8e57f21157?imageslim)

   ```
   function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len - 1 - i; j++) {
        //相邻元素两两对比
        if (arr[j] > arr[j+1]) {
          //通过解构完成元素交换
          [arr[j],arr[j+1]] = [arr[j+1],arr[j]]
        }
      }
    }
    return arr;
   }
   ```

4. **选择排序**：遍历自身以后的元素，最小/大元素跟自己调换位置
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df986135a5f6?imageslim)

   ```
   function selectSort(arr) {
     var len = arr.length;
     for (let i = 0; i < len - 1; i++) {
       for (let j = i; j < len; j++) {
         if (arr[i] > arr[j]) {
           [arr[i], arr[j]] = [arr[j], arr[i]];
         }
       }
     }
     return arr;
   }
   ```

5. **插入排序**：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691df9f6afc4b04?imageslim)

   ```
   function insertSort(arr) {
     //外循环从1开始，默认arr[0]是有序段
     for (let i = 1; i < arr.length; i++) {
       // j = i,将arr[j]依次插入有序段中
       for (let j = i; j > 0; j--) {
         if (arr[j] < arr[j - 1]) {
           [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
         } else {
           break;
         }
       }
     }
     return arr;
   }
   ```

6. **快速排序**：找到一个数作为参考，比这个数字大的放在数字左边，比它小的放在右边； 然后分别再对左边和右变的序列做相同的操作(递归)。(在冒泡排序基础上的递归分治法。)
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfaa8bbf0e52?imageslim)

   - **注：涉及到递归的算法,一定要记得设置出口,跳出递归!**

   ```
   function quickSort(arr) {
     // 跳出递归
     if (arr.length <= 1) return arr;
     var left = [],
         right = [],
         current = arr[0];
     for (let i = 0; i < arr.length; i++) {
       if (arr[i] < current) {
         left.push(arr[i]) // 小的放在左边
       } else {
         right.push(arr[i]) // 大的放在右边
       }
     }
     return quickSort(left).concat(current, quickSort(right));
   }
   ```

   - 改进版

   ```
   function partition(arr, l, r){
     let pivot = arr[l]'
     while(l < r) {
       while(l < r && a[r] > pivot) {
         --r;
       }
       arr[l] = arr[r];
       while(l < r && arr[l] < pivot) {
         ++l;
       }
       arr[r] = arr[l];
     }
     arr[l] = pivot;
     return l;
   }

   function quickSort(arr) {
     let l = 0, r = arr.length - 1;
     if(l < r) {
       let pivot = partition(arr, l, r);
       quickSort(arr, l, pivot - 1);
       quickSort(arr, pivot + 1, r);
     }
     return arr;
   }
   ```

7. **希尔排序**(缩小增量排序)：是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。

   思路： 希尔排序其实大体思路很简单,就是将数组(长度为 len)分成间隔为 t1 的若干数组.进行插入排序;排完后,将数组再分成间隔为 t2(逐步减小)的若干数组,进行插入排序;然后继续上述操作,直到分成间隔为 1 的数组,再进行最后一次插入排序则完成.
   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfc27c806ac3?imageslim)

   ```
   function shellSort(arr){
     var len = arr.length, temp, gap = 1;
     while(gap < len/5) {//动态定义间隔序列
       gap =gap*5+1;
     }

     for (gap; gap > 0; gap = Math.floor(gap/5)) {
       for (var i = gap; i < len; i++) {
         temp = arr[i];
         for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {
           arr[j+gap] = arr[j];
         }

         arr[j+gap] = temp;
       }
     }
     return arr;
   }
   ```

8. **归并排序**：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并

   **思路**：将数组分为左和右两部分,然后继续将左右两部分继续(递归)拆分,直到拆分成单个为止;然后将拆分为最小的两个数组,进行比较,合并排成一个数组.接着继续递归比较合并.直到最后合并为一个数组.

   ![image](https://user-gold-cdn.xitu.io/2019/2/24/1691dfd071fc35a5?imageslim)

   **步骤**：

   - 把长度为 n 的输入序列分成两个长度为 n/2 的子序列
   - 对这两个子序列分别采用归并排序
   - 将两个排序好的子序列合并成一个最终的排序序列。

   ```
   function mergeSort(arr) {
     var len = arr.length;
     if(len < 2) {
       return arr;
     }

     var middle = Math.floor(len / 2),
     left = arr.slice(0, middle),
            right = arr.slice(middle);
     return merge(mergeSort(left), mergeSort(right));
   }

   function merge(left, right){
     var result = [];
     while (left.length && right.length) {
       if (left[0] <= right[0]) {
         result.push(left.shift());
       } else {
         result.push(right.shift());
       }
     }

     while (left.length){
       result.push(left.shift());
     }

     while (right.length){
       result.push(right.shift());
     }
     return result;
   }
   ```

9. **堆排序**

10. **计数排序**

11. **桶排序**

12. **基数排序**

13. **二叉树**

    - 节点：二叉树的最小元素是节点，所以先定义一个节点

      ```
      function Node(data,left,right) {
        this.left = left;
        this.right = right;
        this.data = data;
        this.show = () => {return this.data}
      }
      ```

    - **重建二叉树**

      ```
      var buildTree = function (preorder, inorder) {
        if (!preorder.length || !inorder.length) return null;

        // 前序遍历的第一个元素为根节点
        const rootVal = preorder[0];
        const node = new TreeNode(rootVal);

        let i = 0;
        // i有两个含义，一个是根节点在中序遍历结果中的下标
        // 另一个是当前左子树的节点个数
        for (; i < inorder.length; ++i) {
          if (inorder[i] === rootVal) {
            break;
          }
        }

        // 递归处理左右子树
        node.left = buildTree(preorder.slice(1, i + 1), inorder.slice(0, i));
        node.right = buildTree(preorder.slice(i + 1), inorder.slice(i + 1));
        return node;
      };
      ```

    - **前序遍历** (根节点->左子树->右子树)

      - 递归

      ```
      function preOrder(node) {
        if(node !== null) {
          //根节点->左子树->右子树
          console.log(node.show());
          preOrder(node.left);
          preOrder(node.right);
        }
      }
      ```

      - 非递归

      ```
      function preTraverse(tree) {
        var arr = [], node = null;
        arr.unshift(tree)
        while (arr.length) {
          node = arr.shift()
          console.log(node.root)
          if (node.right) arr.unshift(node.right)
          if (node.left) arr.unshift(node.left)
        }
      }
      ```

    - **中序遍历** (左子树->根节点->右子树)

      中序遍历是以从最小到最大的顺序访 问所有节点。中序遍历的一种应用就是对树进行排序操作。

      - 递归

      ```
      function middleTraverse(node) {
        if (node === null) return;

        middleTraverse(node.left);
        console.log(node.data);
        middleTraverse(node.right);
      }
      ```

      - 非递归

      ```
      // shift() 头删
      // unshift() 头插
      function middleTraverseUnRecursion(root) {
        let arr = [], node = root;

        while (arr.length !== 0 || node !== null) {
          if (node === null) {
            node = arr.shift();
            console.log(node.data);
            node = node.right;
          } else {
            arr.unshift(node);
            node = node.left;
          }
        }
      }
      ```

    - **后序遍历**(左子树->右子树->根节点)

      - 递归

      ```
      function lastTraverse(node) {
        if (node === null) return;
        lastTraverse(node.left);
        lastTraverse(node.right);
        console.log(node.data);
      }
      ```

    - **广度优先-层序遍历**

      - 递归

      ```
      var result = [];
      var stack = [tree];
      var count = 0;
      var bfs = function () {
        var node = stack[count];
        if (node) {
          result.push(node.value);
          if (node.left) stack.push(node.left);
          if (node.right) stack.push(node.right);
          count++;
          bfs();
        }
      }
      ```

      - 非递归

      ```
      function bfs(node) {
        var result = [];
        var queue = [];
        queue.push(node);
        while (queue.length) {
          node = queue.shift();
          result.push(node.value);
          node.left && queue.push(node.left);
          node.right && queue.push(node.right);
        }
        return result;
      }
      ```

    - **反转二叉树**
      ```
      var invertTree = function (root) {
        if (root !== null) {
          [root.left, root.right] = [root.right, root.left];
          invertTree(root.left);
          invertTree(root.right);
        }
        return root;
      }
      ```

14. **数组去重**
    - 双 for 循环, splice 剔除并 i--回退
    - indexOf 等于 index
    - filter indexOf === index
    - 新数组 indexOf === index
    - 使用空对象等

# 参考资料

> 1. https://juejin.im/post/5c64d15d6fb9a049d37f9c20#heading-4
> 2. https://mp.weixin.qq.com/s/-4QzuupsTwr2NcknN590Dg
> 3. https://mp.weixin.qq.com/s/jdDwmPfMOf4qVnwYx0a6ew
> 4. https://juejin.im/post/5e6055e6f265da5762133c89
> 5. http://www.ruanyifeng.com/blog/2017/05/websocket.html
> 6. https://cn.vuejs.org/v2/guide/
> 7. https://github.com/yukkkkkki/Front-end-Interview-questions
> 8. https://www.cnblogs.com/ainyi/p/9777841.html
> 9. https://www.jianshu.com/p/56b7302d7f7f
> 10. https://www.cnblogs.com/binguo666/p/10928907.html
> 11. https://www.cnblogs.com/staven/p/4774263.html
> 12. https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API
> 13. https://zhuanlan.zhihu.com/p/72616216
> 14. https://juejin.im/post/5c6e5803f265da2dc0065437
> 15. https://juejin.im/post/59e4c02151882578d02f4aca
> 16. https://www.cnblogs.com/harsin/p/11418615.html
> 17. https://juejin.im/post/5c72280351882562914edb61#heading-7
> 18. NicholasC.Zakas, 泽卡斯, Zakas, 李松峰, & 曹力. (2010). JavaScript 高级程序设计. 人民邮电出版社.
> 19. https://juejin.im/post/5c6f9d24e51d4511dd3fd0a2#heading-14
> 20. https://zhuanlan.zhihu.com/p/34453198?group_id=957277540147056640
> 21. https://segmentfault.com/a/1190000017184701
> 22. https://juejin.im/post/5c6c9c99f265da2d896326ae#heading-5
> 23. https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-4
> 24. https://juejin.im/post/5d0a48d86fb9a07ea803cf23#heading-0
> 25. https://juejin.im/post/59ac1c4ef265da248e75892b#heading-12
> 26. https://www.itcodemonkey.com/article/2853.html
> 27. https://juejin.im/post/5ce607a7e51d454f6f16eb3d#heading-37
> 28. https://juejin.im/post/5d1d61766fb9a07ed2248aea#heading-5
