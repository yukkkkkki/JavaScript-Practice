// 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

// 示例 1:
// 输入: 123
// 输出: 321

// 示例 2:
// 输入: -123
// 输出: -321

// 示例 3:
// 输入: 120
// 输出: 21

// 方法一
// 思路
// 如果将数字看成是有符号位的字符串，那么我们就能够通过使用 JS 提供的字符串方法来实现非符
// 号部分的翻转，又因为整数的翻转并不影响符号，所以我们最后补充符号，完成算法。
// 详解
// 1. 首先设置边界极值；
// 2. 使用字符串的翻转函数进行主逻辑；
// 3. 补充符号
// 4. 然后拼接最终结果
var reverse = function (x) {
  if (typeof x !== "number") return;

  // 极值
  const MAX = 2147483647;
  const MIN = -2147483648;

  // 识别数字剩余部分并翻转
  const rest =
    x > 0
      ? String(x).split("").reverse().join("")
      : String(x).slice(1).split("").reverse().join("");

  // 转换为正常值，区分正负数
  const res = x > 0 ? parseInt(rest, 10) : 0 - parseInt(rest, 10);

  // 边界情况
  if (res >= MIN && res <= MAX) {
    return res;
  }
  return 0;
};

// 方法二
// 思路
// 我们借鉴欧几里得求最大公约数的方法来解题。符号的处理逻辑同方法一，这里我们通过模 10 取
// 到最低位，然后又通过乘 10 将最低位迭代到最高位，完成翻转。
// 详解
// 1. 设置边界极值；
// 2. 取给定数值的绝对值，遍历循环生成每一位数字，借鉴欧几里得算法，从 num 的最后一位开
// 始取值拼成新的数
// 3. 同步剔除掉被消费的部分
// 4. 如果最终结果为异常值，则直接返回 0；如果原本数据为负数，则对最终结果取反
// 5. 返回最终结果
var reverse = function (x) {
  let int = Math.abs(x);

  // 极值
  const MAX = 2147483647;
  const MIN = -2147483648;
  let num = 0;

  // 遍历循环生成每一位数字
  while (int !== 0) {
    // 借鉴欧几里得算法，从 num 的最后一位开始取值拼成新的数
    num = (int % 10) + num * 10;
    // 剔除掉被消费的部分
    int = Math.floor(int / 10);
  }

  // 异常值
  if (num >= MAX || num <= MIN) {
    return 0;
  }

  if (x < 0) {
    return num * -1;
  }
  return num;
};
